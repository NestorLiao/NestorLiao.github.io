<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="cn" xml:lang="cn">
<head>
<!-- 2025-11-29 Sat 20:42 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>技术时代的生活与工作</title>
<meta name="author" content="Qingsong Liao" />
<meta name="description" content="廖青松，Qingsong Liao, NestorLiao, Liaoqingsong, LiaoQingSong, Emacs, Linux, ZMK, Eink, Rust, Zig, C, C++, OS, embedded, tutoria, Chongqing, 重庆, China, 中国" />
<meta name="keywords" content="技术时代的生活与工作, tech among life and work, NestorLiao, 廖青松, 重庆, CQUPT, FSF, Emacs, Linux, ZMK, Eink, Rust, Zig, C, C++, OS" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">技术时代的生活与工作</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org55cd022">1. 被技术改变的生活</a></li>
<li><a href="#org51e6459">2. 学技术的哲学</a>
<ul>
<li><a href="#org47970b2">2.1. 学习什么技术</a></li>
<li><a href="#org1e16f15">2.2. 怎么学习底层技术</a></li>
</ul>
</li>
<li><a href="#org6f57236">3. 编辑器哲学</a>
<ul>
<li><a href="#orgb2047f0">3.1. 如果人生还有一次，我还选emacs</a></li>
<li><a href="#org8293fda">3.2. 我告诉你，年轻人啊，学习老掉牙的emacs，就像是金庸小说里的年轻主人公学习失传的武林秘籍一般(只是小说剧情而矣)。</a></li>
</ul>
</li>
<li><a href="#orgd85554a">4. 操作系统哲学</a>
<ul>
<li><a href="#org3bd71ea">4.1. 我的操作系统特点</a></li>
<li><a href="#orgd0a0572">4.2. 用linux只为戒色</a></li>
<li><a href="#orgf688841">4.3. 学技术只为戒x</a></li>
</ul>
</li>
<li><a href="#org6d3175c">5. 键盘流哲学</a>
<ul>
<li><a href="#org79026a2">5.1. 设计哲学</a></li>
<li><a href="#org3b1709b">5.2. 分层</a></li>
<li><a href="#org702cd02">5.3. 本地刷录</a></li>
<li><a href="#orgc46aee4">5.4. 不只键盘</a></li>
</ul>
</li>
<li><a href="#org4413dde">6. 屏幕哲学</a>
<ul>
<li><a href="#orgafe8df1">6.1. Feels:</a></li>
<li><a href="#orgab6e275">6.2. Features:</a></li>
<li><a href="#org8e79962">6.3. Tips for mono:</a></li>
</ul>
</li>
<li><a href="#orgf29a285">7. fog.h</a>
<ul>
<li><a href="#orgc0778e1">7.1. Quick Start</a></li>
<li><a href="#orgc6dd579">7.2. "Just rewrite shit in C, Just rewrite shit in C " &#x2014; tsoding</a></li>
</ul>
</li>
<li><a href="#org0451751">8. 不用AI完成Leetcode刷题</a>
<ul>
<li><a href="#orga494768">8.1. 吃饭/做题/睡觉，论计算机技术革命及其后果</a></li>
<li><a href="#two-sumlink-easy">8.2. 1. Two Sum (Easy)</a></li>
<li><a href="#longest-substring-without-repeating-characterslink-medium">8.3. 3. Longest Substring Without Repeating Characters (Medium)</a></li>
<li><a href="#median-of-two-sorted-arrayslink-hard">8.4. 4. Median of Two Sorted Arrays (Hard)</a></li>
<li><a href="#longest-palindromic-substringlink-medium">8.5. 5. Longest Palindromic Substring (Medium)</a></li>
<li><a href="#regular-expression-matchinglink-hard">8.6. 10. Regular Expression Matching (Hard)</a></li>
<li><a href="#sumlink-medium">8.7. 15. 3Sum (Medium)</a></li>
<li><a href="#remove-nth-node-from-end-of-listlink-medium">8.8. 19. Remove Nth Node From End of List (Medium)</a></li>
<li><a href="#valid-parentheseslink-easy">8.9. 20. Valid Parentheses (Easy)</a></li>
<li><a href="#merge-k-sorted-listslink-hard">8.10. 23. Merge k Sorted Lists (Hard)</a></li>
<li><a href="#find-the-index-of-the-first-occurrence-in-a-stringlink-easy">8.11. 28. Find the Index of the First Occurrence in a String (Easy)</a></li>
<li><a href="#find-first-and-last-position-of-element-in-sorted-arraylink-medium">8.12. 34. Find First and Last Position of Element in Sorted Array (Medium)</a></li>
<li><a href="#sudoku-solverlink-hard">8.13. 37. Sudoku Solver (Hard)</a></li>
<li><a href="#combination-sum-iilink-medium">8.14. 40. Combination Sum II (Medium)</a></li>
<li><a href="#permutationslink-medium">8.15. 46. Permutations (Medium)</a></li>
<li><a href="#permutations-iilink-medium">8.16. 47. Permutations II (Medium)</a></li>
<li><a href="#rotate-imagelink-medium">8.17. 48. Rotate Image (Medium)</a></li>
<li><a href="#n-queenslink-hard">8.18. 51. N-Queens (Hard)</a></li>
<li><a href="#maximum-subarraylink-medium">8.19. 53. Maximum Subarray (Medium)</a></li>
<li><a href="#minimum-path-sumlink-medium">8.20. 64. Minimum Path Sum (Medium)</a></li>
<li><a href="#add-binarylink-easy">8.21. 67. Add Binary (Easy)</a></li>
<li><a href="#sqrtxlink-easy">8.22. 69. Sqrt(x) (Easy)</a></li>
<li><a href="#climbing-stairslink-easy">8.23. 70. Climbing Stairs (Easy)</a></li>
<li><a href="#edit-distancelink-medium">8.24. 72. Edit Distance (Medium)</a></li>
<li><a href="#sort-colorslink-medium">8.25. 75. Sort Colors (Medium)</a></li>
<li><a href="#minimum-window-substringlink-hard">8.26. 76. Minimum Window Substring (Hard)</a></li>
<li><a href="#combinationslink-medium">8.27. 77. Combinations (Medium)</a></li>
<li><a href="#word-searchlink-medium">8.28. 79. Word Search (Medium)</a></li>
<li><a href="#search-in-rotated-sorted-array-iilink-medium">8.29. 81. Search in Rotated Sorted Array II (Medium)</a></li>
<li><a href="#remove-duplicates-from-sorted-listlink-easy">8.30. 83. Remove Duplicates from Sorted List (Easy)</a></li>
<li><a href="#merge-sorted-arraylink-easy">8.31. 88. Merge Sorted Array (Easy)</a></li>
<li><a href="#decode-wayslink-medium">8.32. 91. Decode Ways (Medium)</a></li>
<li><a href="#binary-tree-inorder-traversallink-easy">8.33. 94. Binary Tree Inorder Traversal (Easy)</a></li>
<li><a href="#recover-binary-search-treelink-medium">8.34. 99. Recover Binary Search Tree (Medium)</a></li>
<li><a href="#symmetric-treelink-easy">8.35. 101. Symmetric Tree (Easy)</a></li>
<li><a href="#maximum-depth-of-binary-treelink-easy">8.36. 104. Maximum Depth of Binary Tree (Easy)</a></li>
<li><a href="#construct-binary-tree-from-preorder-and-inorder-traversallink-medium">8.37. 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</a></li>
<li><a href="#construct-binary-tree-from-inorder-and-postorder-traversallink-medium">8.38. 106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)</a></li>
<li><a href="#convert-sorted-list-to-binary-search-treelink-medium">8.39. 109. Convert Sorted List to Binary Search Tree (Medium)</a></li>
<li><a href="#balanced-binary-treelink-easy">8.40. 110. Balanced Binary Tree (Easy)</a></li>
<li><a href="#best-time-to-buy-and-sell-stocklink-easy">8.41. 121. Best Time to Buy and Sell Stock (Easy)</a></li>
<li><a href="#best-time-to-buy-and-sell-stock-iilink-medium">8.42. 122. Best Time to Buy and Sell Stock II (Medium)</a></li>
<li><a href="#word-ladder-iilink-hard">8.43. 126. Word Ladder II (Hard)</a></li>
<li><a href="#longest-consecutive-sequencelink-medium">8.44. 128. Longest Consecutive Sequence (Medium)</a></li>
<li><a href="#surrounded-regionslink-medium">8.45. 130. Surrounded Regions (Medium)</a></li>
<li><a href="#candylink-hard">8.46. 135. Candy (Hard)</a></li>
<li><a href="#single-numberlink-easy">8.47. 136. Single Number (Easy)</a></li>
<li><a href="#word-breaklink-medium">8.48. 139. Word Break (Medium)</a></li>
<li><a href="#linked-list-cycle-iilink-medium">8.49. 142. Linked List Cycle II (Medium)</a></li>
<li><a href="#binary-tree-preorder-traversallink-easy">8.50. 144. Binary Tree Preorder Traversal (Easy)</a></li>
<li><a href="#binary-tree-postorder-traversallink-easy">8.51. 145. Binary Tree Postorder Traversal (Easy)</a></li>
<li><a href="#lru-cachelink-medium">8.52. 146. LRU Cache (Medium)</a></li>
<li><a href="#sort-listlink-medium">8.53. 148. Sort List (Medium)</a></li>
<li><a href="#max-points-on-a-linelink-hard">8.54. 149. Max Points on a Line (Hard)</a></li>
<li><a href="#find-minimum-in-rotated-sorted-array-iilink-hard">8.55. 154. Find Minimum in Rotated Sorted Array II (Hard)</a></li>
<li><a href="#min-stacklink-medium">8.56. 155. Min Stack (Medium)</a></li>
<li><a href="#find-peak-elementlink-medium">8.57. 162. Find Peak Element (Medium)</a></li>
<li><a href="#two-sum-ii---input-array-is-sortedlink-medium">8.58. 167. Two Sum II - Input Array Is Sorted (Medium)</a></li>
<li><a href="#excel-sheet-column-titlelink-easy">8.59. 168. Excel Sheet Column Title (Easy)</a></li>
<li><a href="#majority-elementlink-easy">8.60. 169. Majority Element (Easy)</a></li>
<li><a href="#best-time-to-buy-and-sell-stock-ivlink-hard">8.61. 188. Best Time to Buy and Sell Stock IV (Hard)</a></li>
<li><a href="#reverse-bitslink-easy">8.62. 190. Reverse Bits (Easy)</a></li>
<li><a href="#house-robberlink-medium">8.63. 198. House Robber (Medium)</a></li>
<li><a href="#happy-numberlink-easy">8.64. 202. Happy Number (Easy)</a></li>
<li><a href="#isomorphic-stringslink-easy">8.65. 205. Isomorphic Strings (Easy)</a></li>
<li><a href="#implement-trie-prefix-treelink-medium">8.66. 208. Implement Trie (Prefix Tree) (Medium)</a></li>
<li><a href="#course-schedule-iilink-medium">8.67. 210. Course Schedule II (Medium)</a></li>
<li><a href="#house-robber-iilink-medium">8.68. 213. House Robber II (Medium)</a></li>
<li><a href="#kth-largest-element-in-an-arraylink-medium">8.69. 215. Kth Largest Element in an Array (Medium)</a></li>
<li><a href="#contains-duplicatelink-easy">8.70. 217. Contains Duplicate (Easy)</a></li>
<li><a href="#the-skyline-problemlink-hard">8.71. 218. The Skyline Problem (Hard)</a></li>
<li><a href="#maximal-squarelink-medium">8.72. 221. Maximal Square (Medium)</a></li>
<li><a href="#implement-stack-using-queueslink-easy">8.73. 225. Implement Stack using Queues (Easy)</a></li>
<li><a href="#invert-binary-treelink-easy">8.74. 226. Invert Binary Tree (Easy)</a></li>
<li><a href="#basic-calculator-iilink-medium">8.75. 227. Basic Calculator II (Medium)</a></li>
<li><a href="#implement-queue-using-stackslink-easy">8.76. 232. Implement Queue using Stacks (Easy)</a></li>
<li><a href="#lowest-common-ancestor-of-a-binary-search-treelink-medium">8.77. 235. Lowest Common Ancestor of a Binary Search Tree (Medium)</a></li>
<li><a href="#lowest-common-ancestor-of-a-binary-treelink-medium">8.78. 236. Lowest Common Ancestor of a Binary Tree (Medium)</a></li>
<li><a href="#product-of-array-except-selflink-medium">8.79. 238. Product of Array Except Self (Medium)</a></li>
<li><a href="#sliding-window-maximumlink-hard">8.80. 239. Sliding Window Maximum (Hard)</a></li>
<li><a href="#search-a-2d-matrix-iilink-medium">8.81. 240. Search a 2D Matrix II (Medium)</a></li>
<li><a href="#different-ways-to-add-parentheseslink-medium">8.82. 241. Different Ways to Add Parentheses (Medium)</a></li>
<li><a href="#valid-anagramlink-easy">8.83. 242. Valid Anagram (Easy)</a></li>
<li><a href="#binary-tree-pathslink-easy">8.84. 257. Binary Tree Paths (Easy)</a></li>
<li><a href="#single-number-iiilink-medium">8.85. 260. Single Number III (Medium)</a></li>
<li><a href="#missing-numberlink-easy">8.86. 268. Missing Number (Easy)</a></li>
<li><a href="#perfect-squareslink-medium">8.87. 279. Perfect Squares (Medium)</a></li>
<li><a href="#find-the-duplicate-numberlink-medium">8.88. 287. Find the Duplicate Number (Medium)</a></li>
<li><a href="#longest-increasing-subsequencelink-medium">8.89. 300. Longest Increasing Subsequence (Medium)</a></li>
<li><a href="#range-sum-query---immutablelink-easy">8.90. 303. Range Sum Query - Immutable (Easy)</a></li>
<li><a href="#range-sum-query-2d---immutablelink-medium">8.91. 304. Range Sum Query 2D - Immutable (Medium)</a></li>
<li><a href="#range-sum-query---mutablelink-medium">8.92. 307. Range Sum Query - Mutable (Medium)</a></li>
<li><a href="#best-time-to-buy-and-sell-stock-with-cooldownlink-medium">8.93. 309. Best Time to Buy and Sell Stock with Cooldown (Medium)</a></li>
<li><a href="#minimum-height-treeslink-medium">8.94. 310. Minimum Height Trees (Medium)</a></li>
<li><a href="#burst-balloonslink-hard">8.95. 312. Burst Balloons (Hard)</a></li>
<li><a href="#super-ugly-numberlink-medium">8.96. 313. Super Ugly Number (Medium)</a></li>
<li><a href="#maximum-product-of-word-lengthslink-medium">8.97. 318. Maximum Product of Word Lengths (Medium)</a></li>
<li><a href="#coin-changelink-medium">8.98. 322. Coin Change (Medium)</a></li>
<li><a href="#odd-even-linked-listlink-medium">8.99. 328. Odd Even Linked List (Medium)</a></li>
<li><a href="#reconstruct-itinerarylink-hard">8.100. 332. Reconstruct Itinerary (Hard)</a></li>
<li><a href="#counting-bitslink-easy">8.101. 338. Counting Bits (Easy)</a></li>
<li><a href="#integer-breaklink-medium">8.102. 343. Integer Break (Medium)</a></li>
<li><a href="#top-k-frequent-elementslink-medium">8.103. 347. Top K Frequent Elements (Medium)</a></li>
<li><a href="#wiggle-subsequencelink-medium">8.104. 376. Wiggle Subsequence (Medium)</a></li>
<li><a href="#combination-sum-ivlink-medium">8.105. 377. Combination Sum IV (Medium)</a></li>
<li><a href="#insert-delete-getrandom-o1link-medium">8.106. 380. Insert Delete GetRandom O(1) (Medium)</a></li>
<li><a href="#sum-of-left-leaveslink-easy">8.107. 404. Sum of Left Leaves (Easy)</a></li>
<li><a href="#queue-reconstruction-by-heightlink-medium">8.108. 406. Queue Reconstruction by Height (Medium)</a></li>
<li><a href="#longest-palindromelink-easy">8.109. 409. Longest Palindrome (Easy)</a></li>
<li><a href="#arithmetic-sliceslink-medium">8.110. 413. Arithmetic Slices (Medium)</a></li>
<li><a href="#partition-equal-subset-sumlink-medium">8.111. 416. Partition Equal Subset Sum (Medium)</a></li>
<li><a href="#pacific-atlantic-water-flowlink-medium">8.112. 417. Pacific Atlantic Water Flow (Medium)</a></li>
<li><a href="#all-oone-data-structurelink-hard">8.113. 432. All O`one Data Structure (Hard)</a></li>
<li><a href="#non-overlapping-intervalslink-medium">8.114. 435. Non-overlapping Intervals (Medium)</a></li>
<li><a href="#path-sum-iiilink-medium">8.115. 437. Path Sum III (Medium)</a></li>
<li><a href="#find-all-numbers-disappeared-in-an-arraylink-easy">8.116. 448. Find All Numbers Disappeared in an Array (Easy)</a></li>
<li><a href="#delete-node-in-a-bstlink-medium">8.117. 450. Delete Node in a BST (Medium)</a></li>
<li><a href="#sort-characters-by-frequencylink-medium">8.118. 451. Sort Characters By Frequency (Medium)</a></li>
<li><a href="#minimum-number-of-arrows-to-burst-balloonslink-medium">8.119. 452. Minimum Number of Arrows to Burst Balloons (Medium)</a></li>
<li><a href="#assign-cookieslink-easy">8.120. 455. Assign Cookies (Easy)</a></li>
<li><a href="#hamming-distancelink-easy">8.121. 461. Hamming Distance (Easy)</a></li>
<li><a href="#minimum-moves-to-equal-array-elements-iilink-medium">8.122. 462. Minimum Moves to Equal Array Elements II (Medium)</a></li>
<li><a href="#ones-and-zeroeslink-medium">8.123. 474. Ones and Zeroes (Medium)</a></li>
<li><a href="#number-complementlink-easy">8.124. 476. Number Complement (Easy)</a></li>
<li><a href="#target-sumlink-medium">8.125. 494. Target Sum (Medium)</a></li>
<li><a href="#next-greater-element-iilink-medium">8.126. 503. Next Greater Element II (Medium)</a></li>
<li><a href="#find-bottom-left-tree-valuelink-medium">8.127. 513. Find Bottom Left Tree Value (Medium)</a></li>
<li><a href="#minimum-absolute-difference-in-bstlink-easy">8.128. 530. Minimum Absolute Difference in BST (Easy)</a></li>
<li><a href="#convert-bst-to-greater-treelink-medium">8.129. 538. Convert BST to Greater Tree (Medium)</a></li>
<li><a href="#single-element-in-a-sorted-arraylink-medium">8.130. 540. Single Element in a Sorted Array (Medium)</a></li>
<li><a href="#matrixlink-medium">8.131. 542. 01 Matrix (Medium)</a></li>
<li><a href="#diameter-of-binary-treelink-easy">8.132. 543. Diameter of Binary Tree (Easy)</a></li>
<li><a href="#number-of-provinceslink-medium">8.133. 547. Number of Provinces (Medium)</a></li>
<li><a href="#reshape-the-matrixlink-easy">8.134. 566. Reshape the Matrix (Easy)</a></li>
<li><a href="#subtree-of-another-treelink-easy">8.135. 572. Subtree of Another Tree (Easy)</a></li>
<li><a href="#delete-operation-for-two-stringslink-medium">8.136. 583. Delete Operation for Two Strings (Medium)</a></li>
<li><a href="#longest-harmonious-subsequencelink-easy">8.137. 594. Longest Harmonious Subsequence (Easy)</a></li>
<li><a href="#can-place-flowerslink-easy">8.138. 605. Can Place Flowers (Easy)</a></li>
<li><a href="#merge-two-binary-treeslink-easy">8.139. 617. Merge Two Binary Trees (Easy)</a></li>
<li><a href="#sum-of-square-numberslink-medium">8.140. 633. Sum of Square Numbers (Medium)</a></li>
<li><a href="#average-of-levels-in-binary-treelink-easy">8.141. 637. Average of Levels in Binary Tree (Easy)</a></li>
<li><a href="#maximum-length-of-pair-chainlink-medium">8.142. 646. Maximum Length of Pair Chain (Medium)</a></li>
<li><a href="#palindromic-substringslink-medium">8.143. 647. Palindromic Substrings (Medium)</a></li>
<li><a href="#keys-keyboardlink-medium">8.144. 650. 2 Keys Keyboard (Medium)</a></li>
<li><a href="#two-sum-iv---input-is-a-bstlink-easy">8.145. 653. Two Sum IV - Input is a BST (Easy)</a></li>
<li><a href="#non-decreasing-arraylink-medium">8.146. 665. Non-decreasing Array (Medium)</a></li>
<li><a href="#trim-a-binary-search-treelink-medium">8.147. 669. Trim a Binary Search Tree (Medium)</a></li>
<li><a href="#valid-palindrome-iilink-easy">8.148. 680. Valid Palindrome II (Easy)</a></li>
<li><a href="#redundant-connectionlink-medium">8.149. 684. Redundant Connection (Medium)</a></li>
<li><a href="#binary-number-with-alternating-bitslink-easy">8.150. 693. Binary Number with Alternating Bits (Easy)</a></li>
<li><a href="#max-area-of-islandlink-medium">8.151. 695. Max Area of Island (Medium)</a></li>
<li><a href="#count-binary-substringslink-easy">8.152. 696. Count Binary Substrings (Easy)</a></li>
<li><a href="#degree-of-an-arraylink-easy">8.153. 697. Degree of an Array (Easy)</a></li>
<li><a href="#best-time-to-buy-and-sell-stock-with-transaction-feelink-medium">8.154. 714. Best Time to Buy and Sell Stock with Transaction Fee (Medium)</a></li>
<li><a href="#daily-temperatureslink-medium">8.155. 739. Daily Temperatures (Medium)</a></li>
<li><a href="#partition-labelslink-medium">8.156. 763. Partition Labels (Medium)</a></li>
<li><a href="#max-chunks-to-make-sortedlink-medium">8.157. 769. Max Chunks To Make Sorted (Medium)</a></li>
<li><a href="#is-graph-bipartitelink-medium">8.158. 785. Is Graph Bipartite? (Medium)</a></li>
<li><a href="#advantage-shufflelink-medium">8.159. 870. Advantage Shuffle (Medium)</a></li>
<li><a href="#reachable-nodes-in-subdivided-graphlink-hard">8.160. 882. Reachable Nodes In Subdivided Graph (Hard)</a></li>
<li><a href="#construct-binary-tree-from-preorder-and-postorder-traversallink-medium">8.161. 889. Construct Binary Tree from Preorder and Postorder Traversal (Medium)</a></li>
<li><a href="#increasing-order-search-treelink-easy">8.162. 897. Increasing Order Search Tree (Easy)</a></li>
<li><a href="#beautiful-arraylink-medium">8.163. 932. Beautiful Array (Medium)</a></li>
<li><a href="#shortest-bridgelink-medium">8.164. 934. Shortest Bridge (Medium)</a></li>
<li><a href="#shortest-path-in-binary-matrixlink-medium">8.165. 1091. Shortest Path in Binary Matrix (Medium)</a></li>
<li><a href="#filling-bookcase-shelveslink-medium">8.166. 1105. Filling Bookcase Shelves (Medium)</a></li>
<li><a href="#delete-nodes-and-return-forestlink-medium">8.167. 1110. Delete Nodes And Return Forest (Medium)</a></li>
<li><a href="#longest-common-subsequencelink-medium">8.168. 1143. Longest Common Subsequence (Medium)</a></li>
<li><a href="#minimum-remove-to-make-valid-parentheseslink-medium">8.169. 1249. Minimum Remove to Make Valid Parentheses (Medium)</a></li>
<li><a href="#number-of-good-leaf-nodes-pairslink-medium">8.170. 1530. Number of Good Leaf Nodes Pairs (Medium)</a></li>
<li><a href="#org9dc7889">8.171. 设计刷题环境</a></li>
</ul>
</li>
<li><a href="#org4153af8">9. 版本更新历史</a></li>
<li><a href="#org76d8830">10. 开发中遇见的各种软件问题</a></li>
<li><a href="#org7292a33">11. 嵌入式软件招聘常见要求</a></li>
<li><a href="#orge11e523">12. 嵌入式招聘常见笔试问题</a></li>
<li><a href="#org41f649e">13. 嵌入式招聘常见面试问题</a></li>
</ul>
</div>
</div>
<p>
\mainmatter
</p>

<p>
\chapter*{序章\  技术何为?}
\markboth{Introduction}{序章\  技术何为?}
</p>

<ul class="org-ul">
<li>任务编号：以名为“廖青松”的男婴为身份出生在重庆普通家庭</li>
<li>开始时间：2002-11-04</li>
<li>结束时间：总有一死</li>
<li>完成难度：简单到极难，活着也没BOSS啊?</li>
<li>需要小时：一生，大约三万天</li>
<li>本章要点：我对于技术与人生的看法</li>
</ul>

<p>
世界嘈杂<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>、瘾品横流、随机与即时构成新的枷锁，而真正的自由来自主动的剥离。当目光离开诱惑、离开广告、离开无意义的瞬息刺激，心才开始变得干净。生活越简，能量越纯；越慢，感受越深；越少，越能看见真正的自己。
</p>

<p>
身体是意志的第一块土地。空腹的清明、弱光的安静、低温的醒觉、缓慢进食的耐性，都在一点点重塑我们早已被工业习惯磨钝的感官。行走、奔跑、提举、拉起、俯卧撑、壶铃、农夫行走——这些最朴素的动作让人重新理解力量的意义：力量不是爆发，而是日复一日不受伤、不懈怠、让心跳稳、饮食亦是自律的延伸。
</p>

<p>
避免加工。让精神长的那种沉稳、远离高糖盐油，回到豆果菜、坚果与发酵的本味，让身体习惯真实的能量，而不是被化学甜味与工业脂肪驱使的假饱与假快乐。克制不是苦行，而是温和地恢复本能。
</p>

<p>
至于技术，真正的价值不在追逐流行，而在深入底层、理解根本。用 Emacs<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>，不是为了高效，而是为了与世界拉开距离，与自己靠得更近；不随机、不即时、无广告、无噪声，是一种长期的心性训练。读 LFS、LKD 与 SOC 文档，写驱动、调性能、跑 QEMU、玩内核、读源码、用\LaTeX{}和Org写书，是为了获得一种“我真的懂了”的安静感。而这种懂，不是为了炫耀，不是为了沉迷，而是为了让工作成为谋生技能，让生活成为真正的生活。
</p>

<p>
真正的智慧是：学会技术，然后把技术放下；拥有力量，然后让力量变得温柔。生活是吃饭、睡觉、读书、编程、走路、壶铃；生命是健康、乐观、会意、精进、闲适与稳稳的力量。
</p>

<p>
世界广袤、事物繁多，而心若清澈，幸福忽然变得极小，也极近——不来自外界，只来自自身安静而坚定的内心。
</p>


<div id="org183ae85" class="figure">
<p><img src="figure/free-your-soul-wallpaper.jpg" alt="free-your-soul-wallpaper.jpg" />
</p>
<p><span class="figure-number">Figure 1: </span>free-your-soul</p>
</div>
<div id="outline-container-org55cd022" class="outline-2">
<h2 id="org55cd022"><span class="section-number-2">1.</span> 被技术改变的生活</h2>
<div class="outline-text-2" id="text-1">
<p class="verse">
-10000000005年，一切都变了。宇宙诞生了。<br />
-5600000005年，一切都变了。太阳诞生了。<br />
-4600000005年，一切都变了。地球诞生了。<br />
-200000005年，一切都变了。生物诞生了。<br />
-80000005年，一切都变了。恐龙诞生了。<br />
-30025年，一切都变了。人类诞生了。<br />
-26025年，一切都变了。语言诞生了。<br />
-25025年，一切都变了。家庭诞生了。<br />
-22025年，一切都变了。农业诞生了。<br />
-20025年，一切都变了。文明诞生了。<br />
-10025年，一切都变了。文字诞生了。<br />
-9025年，一切都变了。贸币诞生了。<br />
-8025年，一切都变了。法律诞生了。<br />
-1025年，一切都变了。书写诞生了。<br />
-225年，一切都变了。哲学诞生了。<br />
-100年，一切都变了。集权诞生了。<br />
-25年，一切都变了。数学诞生了。<br />
-5年，一切都变了。宗教诞生了。<br />
1000年，一切都变了。宗教火热。丝绸之路、黑死病、天花、中世纪、疾病、皇帝、国王、奇迹、骑士阶层、武士、城墙、封建帝国、马鞍…<br />
1279年，一切都变了。文艺火热。宋朝灭亡，造出火药，指南针，造纸术，印刷术的中华文明终结。但是技术被武力消灭，但技术开始了…<br />
1600年，一切都变了。帝国火热。欧洲人发现了美洲。帝国主义、殖民主义、印刷术、土豆、巧克力、辣椒、枪械与大炮、地理大发现、数学与工程学…<br />
1700年，一切都变了。烟草火热。哥伦布大交换的阴影笼罩大地。黑奴、民族国家、地理学、历史学、语言学、生理学、资本主义、大英帝国…<br />
1800年，一切都变了。鸦片火热。资本主义的阴影笼罩大地。共产主义、物理学、汽车、文学、工业革命、开发美洲、煤气、火车…<br />
1900年，一切都变了。技术狂热。技术在欧洲大地遍地生根。工业化、城市化、流水线、民主、飞机、电力、公司、灯光…<br />
1915年，一切都变了。一战结束。技术的阴影笼罩大地。农药、化肥、化学、媒体、通讯、武器、内燃机、全球化、电报、相对论…<br />
1945年，一切都变了。二战结束。技术的阴影笼罩大地。女权、核弹、雷达、战斗机、计算机、工业化、旅游业、赌博业、广播、量子物理…<br />
1965年，一切都变了。编程火热。技术停滞或是爆发? 电视、摇滚乐、基因学、编程理论、月球、民用航天、芯片、电子技术、教育扩大…<br />
1975年，一切都变了。贸易火热。中国迎来开放。技术在中国大地遍地生根。留守儿童、大量生产、环境污染、贫富差距、道德沦丧、城乡差距…<br />
1995年，一切都变了。网络火热。技术迎来它们的终极载体。科学知识/各种思想文化加速传播、游戏、营销、贸易、色情、视频/图片/电影/音乐…<br />
2002年，一切都变了。我诞生了。技术/成瘾/财富/变革的高峰在我这代中国人最能体现，从未体验过的事物比比皆是。从小时候看电视到青少年时的玩电脑再到成年后被各种技术主动或被动控制… 这代人注定是分化的一代。<br />
2025年，一切都变了。智能火热。技术停滞或是爆发? 社交媒体、区块链、转基因、移动支付、智能设备…<br />
2100年，一切都变了。死神永生。技术黑暗或是造神? 火星旅行、人工智能、机器人、脑机接口、基因修改…<br />
</p>

<p>
1902年出生，1910年化学，1925年通迅交通，1950年核弹计算机，1970年克隆羊，1992年互联网?
2002年出生，2010年手机，2025年ChatGPT，2050年AGI，2070年具身智能，2092年永生?
平均寿命73岁? 我大概是能苟到90岁? 也许会有一场战争… 灭绝不应该长生的人。
</p>
<ul class="org-ul">
<li>后现代技术要点: (上瘾/传销/非人)
<ol class="org-ol">
<li>靠人传销，如加密货币，房地产拼多多。(利用心理/行为设计/资本主义自由市场)</li>
<li>不要人类，如人工智能，通讯与机器人。(利用物理/自动化的算法与机械/大数据)</li>
<li>让人上瘾，如社交媒体，烟酒赌嫖旅游。(利用生理/产量强度更大/劳动时间减少)</li>
</ol></li>

<li>硬技术要点:  医学人工智能(癌症)-&gt;脑机接口(义肢)-&gt;机器人载体(永生)-&gt;恒星际(星际)</li>
<li>医学大数据-&gt;大模型-&gt;生理大模型-&gt;基因建模?</li>
<li>脑机需要什么? 生物+数据</li>
<li>机器人需要什么? 算法+数据</li>
<li>恒星际? 能源+机器人</li>
<li>问题:
<ul class="org-ul">
<li>伦理性: 如果都能永生，如果有谁不能呢?</li>
<li>可靠性: 基于数据，准确性不高，如果程序出错呢?</li>
<li>社会性: 人类会成为什么样? 幸福与快乐到底是什么?</li>
</ul></li>
</ul>


<ul class="org-ul">
<li>悲观主义者:
<ul class="org-ul">
<li>衣/食/住/行/性…
<ul class="org-ul">
<li>以前: 自制/采集狩猎/自建/只有走路/真情或强暴</li>
<li>现在: 拼多多/拼好饭/烂尾楼/倒闭国产新能源/彩礼八十八万</li>
</ul></li>
<li>意义感和存在感
<ul class="org-ul">
<li>以前: 靠身体劳作生活，自己的劳动成果，直接贡献在自己身上</li>
<li>现在: 靠国家/公司/投资生活，靠机械化身体动作/脑力说唱生活</li>
</ul></li>
<li>人类命运与未来
<ul class="org-ul">
<li>以前: 自己的命运在自己/家族/别人手上</li>
<li>现在: 自己的命运在政府/老师/老板/网友…手上</li>
</ul></li>
</ul></li>

<li>乐观主义者:
<ul class="org-ul">
<li>衣/食/住/行/性…</li>
<li>以前: 难得/难管/土房/5公里内/不可控</li>
<li>现在: 便宜/便宜/商品房/环游世界/易得</li>
</ul></li>
<li>意义感和存在感
<ul class="org-ul">
<li>以前: 迷信宗教与古语</li>
<li>现在: 更多知识与卫生</li>
</ul></li>
<li>人类命运与未来
<ul class="org-ul">
<li>以前: 狮子老虎毒蛇毒虫山路水沟低温</li>
<li>现在: 温暖舒服平静安定可控多彩闲适</li>
</ul></li>

<li>对平常人而言:
<ul class="org-ul">
<li>更少的劳动，更多的消费</li>
<li>更少的暴力，更多的新闻</li>
<li>更少的情感，更多的媒体</li>
<li>更少的迷信，更多的知识</li>
<li>更少的空闲，更多的享乐</li>
<li>更少的体力，更多的智力</li>
<li>更少的杀戮，更多的竞争</li>
<li>更少的疾病，更多的人口</li>
<li>更少的歌舞，更多的噪声</li>
<li>更少的饥饿，更多的肥胖</li>
<li>更少的家族，更多的国家</li>
<li>更少的闲适，更多的焦虑</li>
<li>更少的长久，更多的变动</li>
<li>更少的现实，更多的未来</li>
</ul></li>
</ul>


<p>
2025年，一切都变了。我不再相信技术/社会/科学… 我打算出去种田。
</p>

<p>
2035年，一切都变了。ChatGPT，我该生孩子吗? 下面是我的个人信息:xxx
</p>

<p>
2045年，一切都变了。伟大的ChatGPT系统，今天您的系统算出应在人体培养室中产出多少个孩子?
</p>

<p>
2065年，一切都变了。…101110101111110101010101010000111101010111…
</p>

<p>
101001011110010111111010101010101000011110101011100000000000000…
</p>

<p>
42<sub>时间0000000000000000000000000</sub><sub>宇宙1</sub><sub>太阳56</sub><sub>智能99</sub><sub>人类99</sub><sub>历史99</sub><sub>人99年</sub>…
</p>

<p>
赚钱，存肌肉，学习技术，准备永生? 不知道，但我们得先学习在技术时代怎么生存。毕竟，本书书文即为《技术时代的生活与工作: Tech among Life and Work》，主要写写自己的技术学习，写写技术见闻，写写人类与机器的命运。地球与这些文字一样，都小如宇宙中的沙子，可就算无人观赏，也是一种美丽。我在沙子上写着沙子，不觉渺小而觉其之美，闪闪的一点有多少国王与伟人的故事，一切尽此矣。在无限的宇宙舞台上，熵增即是技术之艺术。当星星暗淡、黑洞蒸发、文明消亡，宇宙留下的，唯有技术。
</p>
</div>
</div>
<div id="outline-container-org51e6459" class="outline-2">
<h2 id="org51e6459"><span class="section-number-2">2.</span> 学技术的哲学</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>开始时间：2025-11-19</li>
<li>结束时间:  2026年前</li>
<li>完成难度：难难难</li>
<li>需要小时：100+</li>
<li>本章要点：linux/c/zig/rust/rtos</li>
</ul>

<blockquote>
<p>
人没有梦想那和咸鱼有什么区别呢? ——周星驰
</p>
</blockquote>
</div>
<div id="outline-container-org47970b2" class="outline-3">
<h3 id="org47970b2"><span class="section-number-3">2.1.</span> 学习什么技术</h3>
<div class="outline-text-3" id="text-2-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> path-to-know-tech</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">procress</th>
<th scope="col" class="org-left">url</th>
<th scope="col" class="org-left">for</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b>fag</b></td>
<td class="org-left">flag/cintro</td>
<td class="org-left">c, pretent iam tsoding</td>
</tr>

<tr>
<td class="org-left">embedded C book</td>
<td class="org-left">read book</td>
<td class="org-left">c, how compiler/os/c works</td>
</tr>

<tr>
<td class="org-left">Yeetcode</td>
<td class="org-left">leetgo/book</td>
<td class="org-left">cpp[rust], algo ds, solve task</td>
</tr>

<tr>
<td class="org-left">paperlike-c/el</td>
<td class="org-left">paperlike-go</td>
<td class="org-left">elisp,paperlike emacs controler</td>
</tr>

<tr>
<td class="org-left">ziglings</td>
<td class="org-left">ziglings</td>
<td class="org-left">zig, basic ziglangs speed run</td>
</tr>

<tr>
<td class="org-left">zag</td>
<td class="org-left">fag</td>
<td class="org-left">zig, I have language erotic</td>
</tr>

<tr>
<td class="org-left">paperlike-zig</td>
<td class="org-left">paperlike-el</td>
<td class="org-left">zig, make cli/tary</td>
</tr>

<tr>
<td class="org-left">nixos r2s</td>
<td class="org-left">github-repos</td>
<td class="org-left">nix, for network addiction</td>
</tr>

<tr>
<td class="org-left">TsurgizOS</td>
<td class="org-left">os.phil-opp</td>
<td class="org-left">zig[rust], make general os for cv</td>
</tr>

<tr>
<td class="org-left">nixos rasberry-pi</td>
<td class="org-left">github-repos</td>
<td class="org-left">nix, for embedded os/screen/driver</td>
</tr>

<tr>
<td class="org-left">clings</td>
<td class="org-left">ziglings</td>
<td class="org-left">c, lings but clang</td>
</tr>

<tr>
<td class="org-left">freertos emulator</td>
<td class="org-left">rtos</td>
<td class="org-left">c, use general rtos</td>
</tr>

<tr>
<td class="org-left">lvgl eink rtos</td>
<td class="org-left">lvgl</td>
<td class="org-left">c, embedded ui/driver/sdl</td>
</tr>

<tr>
<td class="org-left">lvgl lora loc</td>
<td class="org-left">graphic</td>
<td class="org-left">c, embedded openstress/sdl/lvgl</td>
</tr>

<tr>
<td class="org-left">RZOS</td>
<td class="org-left">rtos</td>
<td class="org-left">zig, make general rtos</td>
</tr>

<tr>
<td class="org-left">Celest</td>
<td class="org-left">game</td>
<td class="org-left">zig, embedded game/sdl</td>
</tr>

<tr>
<td class="org-left">Safephone</td>
<td class="org-left">electronic</td>
<td class="org-left">lvgl/eink/openstress/lora/3Dprint</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">stm32/nix/electronic/network</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">nsfw image/text detected</td>
</tr>
</tbody>
</table>

<ol class="org-ol">
<li>All in all, it's for 技术哲学
<ol class="org-ol">
<li>网络/低速/时间/域名/ai过滤/linux内核构建-r2s</li>
<li>屏幕/护眼/低成瘾/驱动设计/eink屏幕算法-paperlike</li>
<li>通信/安全/无依赖/去平台/lora远距离通信-safephone</li>
<li>交通/电工/电子电路/openstress-去五佰<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>那里学修车</li>
</ol></li>
</ol>
</div>
</div>
<div id="outline-container-org1e16f15" class="outline-3">
<h3 id="org1e16f15"><span class="section-number-3">2.2.</span> 怎么学习底层技术</h3>
<div class="outline-text-3" id="text-2-2">
<ol class="org-ol">
<li>第一阶段：打基础（C / Linux / GCC / Emacs）
<ul class="org-ul">
<li>C 语言：学会指针、内存管理、结构体、函数指针；刷一些小项目，比如实现
malloc、shell、http server。</li>
<li>Linux 基础：熟悉命令行、文件系统、进程/线程、信号、管道、套接字。</li>
<li>GCC：学会编译流程 gcc -E/-S/-c/-o，理解预处理、汇编、链接，玩一下
objdump 和 nm。</li>
<li>Emacs：把它当IDE来用，掌握基本编辑、调试、补全、LSP支持。</li>
</ul></li>

<li>第二阶段：系统调试与逆向（GDB / QEMU）
<ul class="org-ul">
<li>GDB：练习断点、单步、查看寄存器/内存、调试多线程/远程调试。</li>
<li>QEMU：
<ul class="org-ul">
<li>用它运行 Linux kernel 或裸机程序。</li>
<li>学会 qemu -S -s + gdb remote 调试，体验调试内核的感觉。</li>
<li>研究 QEMU 的设备模拟（比如 VirtIO、PCI），理解虚拟化和硬件抽象。</li>
</ul></li>
</ul></li>

<li>第三阶段：进阶编程语言与系统（C++ / Zig / RTOS）
<ul class="org-ul">
<li>Zig：Zig 是现代系统编程语言，学习它的构建系统、内存模型，可以和
C/C++ 混合编程。</li>
<li>RTOS：从 FreeRTOS
入手，学任务调度、中断、任务间通信（队列/信号量）。可以用 QEMU 模拟
Cortex-M 板子跑 RTOS。</li>
</ul></li>

<li>第四阶段：融会贯通（大型项目 / 内核 / 编译器）
<ul class="org-ul">
<li>QEMU + GDB：调试内核启动、写内核模块。</li>
<li>编译器开发：研究 GCC 或 Clang 的前端/后端；或者用 Zig
写一个简化编译器。</li>
<li>个人项目：比如写一个简易 RTOS，或者在 QEMU 里跑自己写的内核。</li>
</ul></li>

<li>操作系统构建与升级（Yocto/Android/内核）
在树莓派上交叉编译 Linux 内核，修改驱动或设备树（Device Tree）进行硬件适配。
尝试用 Yocto 或 Buildroot 构建自定义 Linux 镜像，加入自己编写或修改的驱动模块。
安装和编译 LineageOS（Android for Pi）或类似 Android 系统，修改系统服务或 HAL 层。
实践 OTA（Over-The-Air）升级机制，模拟系统升级和回滚操作。
硬件 Bringup（CPU/GPU/Memory/Peripherals）
利用树莓派的 GPIO、SPI、I2C、CAN、PWM 等接口，练习外设 Bringup 和驱动调试。
连接摄像头模块、显示屏（LCD 或 E-Ink）或音频模块，编写驱动和控制程序。
使用 perf/ftrace/gprof 分析 CPU/GPU 性能瓶颈，优化程序调度。</li>
<li>系统稳定性与性能优化
构建多线程/多进程网络服务，使用 socket 编程实现客户端/服务器通信，模拟并发场景。
在树莓派上测试高负载条件下的系统稳定性，分析内核日志、内存占用和 CPU/GPU 使用率。
实践内核参数调优，如调节调度器、内存缓存策略，观察性能变化。</li>
<li>客户功能定制与基线升级
自己设计一个树莓派应用（如小型智能家居控制器或信息显示终端），从硬件 Bringup 到应用功能定制完整流程。
模拟不同版本的系统镜像管理，练习分支合并、基线升级和版本回退。</li>
<li>加分技能训练
<ol class="org-ol">
<li>低功耗优化：通过关闭不必要的外设、调节 CPU/GPU 频率或使用 E-Ink 显示屏练习功耗控制。</li>
<li>虚拟化/容器：在树莓派上安装 QEMU/KVM 或 Docker，运行多系统虚拟环境，模拟嵌入式应用部署。</li>
<li>芯片平台经验：如果有 MTK 或其他 ARM 板卡，可以对比树莓派练习移植和平台适配经验。</li>
</ol></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org6f57236" class="outline-2">
<h2 id="org6f57236"><span class="section-number-2">3.</span> 编辑器哲学</h2>
<div class="outline-text-2" id="text-3">
<p>
This is my blog and p(pdf)log which written in org and \LaTeX{}, and emacs/nixos config, code snippest and even more, all in just one repo.
这是仓库是我的博客也是我用\LaTeX{}写的书，还是我是emacs和nixos配置，代码模板等等等。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(org-babel-do-load-languages
 'org-babel-load-languages '((emacs-lisp . t)(shell . t)))
</pre>
</div>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>我能用这代码块重现我的电脑，怎么样? 帅吧!</label><pre class="src src-sh">if [[ -f "/home/$USER/.emacs.d" ]] then
   git clone --depth 1 https://github.com/jamescherti/minimal-emacs.d ~/.emacs.d
fi
   ln -sf $PWD/nixos/ ~/.config/;
   ln -sf $PWD/snippets ~/.config/;
   ln -sf $PWD/nixos/hmdz.pyim ~/.config/;
   ln -sf $PWD/nixos/post-init.el ~/.emacs.d/;
   if [[ $XAPIAN_CJK_NGRAM != "true" ]] then
      sudo cp /etc/hardware-configuration.nix $PWD/nixos/hardware-configuration.nix
      chmod 777 $PWD/nixos/hardware-configuration.nix
      mkdir -p   $HOME/.config/sops/age
      cp .keys.txt  $HOME/.config/sops/age/keys.txt
      sudo nix-channel --add https://nixos.org/channels/nixos-unstable
      sudo nix-channel --update
      sudo nixos-rebuild switch --flake /home/$USER/.config/nixos#$hostname  --option substituters 'https://mirrors.ustc.edu.cn/nix-channels/store  https://cache.nixos.org' --cores 6 -j 12;
   fi
</pre>
</div>

<p>
这是org的文学编程能力最简单的体现，从c到bash，在一个org文件中能一起运行，神奇吧! 为什么emacs这么强大?大概就是因为它使用的elisp相当“灵”吧，再说为什么emacs这么小众，也大概是它的elisp太“难”了吧。有些人不敢学，怕自己投入又得不到钞票，有些人不能学，他们把自己的心给了别的教派如“vim”“vscode”于是固步自封，自高自大，vim模态天下第一! 我曾同样如此，抱着网上破烂配凑出的neovim，对那些大神的操作流口水但是又没法认同emacs。其实犹豫不定很正常，进入一个陌生的环境，很多怪人怪事，emacs更是如此，你常常不知道那些人口中说的eglot/flycheck/eww是什么?常常写错一些代码。当然这同样也是学习emacs的乐趣，也正是它的陌生带来的新鲜，而且有了chatgpt的帮助，学习起来相当方便。
</p>
</div>
<div id="outline-container-orgb2047f0" class="outline-3">
<h3 id="orgb2047f0"><span class="section-number-3">3.1.</span> 如果人生还有一次，我还选emacs</h3>
<div class="outline-text-3" id="text-3-1">
<p>
我最早听闻Emacs，大概是 2022 年在CSwiki中作者对Emacs的谥美之词“神用编辑器”<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup>。当时我猎奇心甚为严重，又觉得大家都在用的 VSCode 无法体现我的气质，便先折腾三年Vim/Neovim/Helix后在2024开始自学 Emacs，接触 Emacs先是doom框架后是接近原生的purcell。喜欢换来换去，或许这是年青人的通病。
</p>

<p>
现在，我已不再年青，却依然喜欢 Emacs就像我曾喜欢一个女生，但她从来不知道。曾经沧海难为水，或许这是人老了之后的通病，而我觉得更可能是因为1978年诞生的 Emacs 依然年青。
</p>
</div>
</div>
<div id="outline-container-org8293fda" class="outline-3">
<h3 id="org8293fda"><span class="section-number-3">3.2.</span> 我告诉你，年轻人啊，学习老掉牙的emacs，就像是金庸小说里的年轻主人公学习失传的武林秘籍一般(只是小说剧情而矣)。</h3>
<div class="outline-text-3" id="text-3-2">
<ol class="org-ol">
<li>要我说认为我的Emacs配置有什么特点，大概就是这样几点吧。
<ul class="org-ul">
<li>minimal: my config based on the clean and  fast minimal-emacs.</li>
<li>zen: a pure white and black theme written by me called "real-mono-theme".</li>
<li>reproducible: package manager is using <b>NixOS</b>.</li>
<li>simple: just a post-init.el which less than 2000 lines.</li>
<li>keyboard: for my <b>ZMK</b> conifg, only me can use those as flow~</li>
<li>effcient: elegant selecting like queen and fast editting like king.</li>
</ul></li>

<li>要我说 <b>Emacs</b> 就和与小说里秘传的十八般武林功夫一般，有定身/移形换影/透视经脉/必杀技/念经/修炼/经文/拜师/法宝/女伴/侠义… 甚至武功大概不过如此… 拳脚身头可用的功夫，那里有无限可能的电子计算机的空间大啊?
<ul class="org-ul">
<li>动: 插入/切换/输出/笔记/补全/专注/跳转/投修/替换/扩张/行修/选择/整理/重复/变化/比较/潜在</li>
<li>阅: 简用/单页/全页/源码/图书/用文/说文</li>
<li>用: 项目/虚拟/日志/中文/终端</li>
<li>浏: 搜/库/问</li>
<li>库: Linux/Libc/Posix/C ABI/Network/Algo/Protocols</li>

<li>标题说的有定身/移形换影/透视经脉/必杀技/念经/修炼/经文/拜师/法宝/女伴/侠义，我也确实有的定身view-only/移形换影swtich-buffer/透视经脉describ-function/必杀技kill-emacs/念经read gpl3/修炼rtfm/经文info/拜师rms/法宝list-package/女伴WoMan/侠义contributor。emacs-china 管论坛的用户叫“道友”，似乎就己经点明这点，学习难度大，学习结果虚幻无比，需要气定神闲，天地之间少有人闻，更少有人真正能掌握这一门技术，不叫“道友”怎么说得过去?</li>
</ul></li>

<li><b>Write The Fucking Code</b>
<ul class="org-ul">
<li>心写: org/theme/hide-xx/ligature/no-xx/vertico-flat</li>
<li>补写: cape/hippie-expand/snippet</li>
<li>跳写: occur/rg/eglot/imenu/mark/avy/consult/compilation</li>
<li>横竖: flush/delete/dulicate/sort/move-text  ||  iedit/mc/rectangle</li>
<li>比缩: diff/ediff/xxx-diff/xxx-merge</li>
<li>选扩: surround/expand-region/native-mark/mc</li>
<li>选点: embark/vertico/menu-bar/tooltips/tool-bar</li>
<li>重复: macro</li>
<li>切换: dired/find|switch-file/sway/ibuffer/tramp</li>
<li>替换: replce string|regex</li>
<li>变换: shift-number/transpose/case-switch/narrow</li>
<li>内在: save-xxx/xx-mode/envrc/editorconfig/autofmt</li>
</ul></li>
<li><b>Read The Fridendly Manual</b>
<ul class="org-ul">
<li>源码: eglot/helpful</li>
<li>用简: tldr</li>
<li>用文: man/woman</li>
<li>一页: devdocs</li>
<li>全页: eww/nginx</li>
<li>说文: info</li>
<li>图书: nov/pdf-tool</li>
</ul></li>
<li><b>Browse The Enshitty Web</b>
<ul class="org-ul">
<li>搜索: tavily</li>
<li>仓库: consult-gh</li>
<li>询问: gptel</li>
<li>交流: gnus/irc/eww</li>
</ul></li>
<li><b>Use The Minimal Tools</b>
<ul class="org-ul">
<li>工具: magit/git-xx/project/nix/docker/kubernetes</li>
<li>中文: quicksdcv/pyim</li>
<li>日志: syslog|journalctl-mode</li>
<li>终端: vterm/repl/shell</li>
</ul></li>
<li><b>总之，我试着去思考一下什么是写作与编程，阅读与浏览，内心与外物</b>
<ul class="org-ul">
<li>写作: 需要重复阅读，反复遣词造句，思考上下文人物/事件关系，写作有编辑环节，但那是“编辑”做的事。</li>
<li>编程: 需要更多更快的查找方式，更多更快的浏览，思考调用/协议的关系，编程需要大量的编辑(indent/上下移动/复制粘贴)。</li>
<li>阅读: 长文/长时间的专注，资源越少越好，写作应该减少阅读别人的作品。</li>
<li>浏览: 短文/短时间的专注，资源极多… 想不多都不行… 编程应该大量阅读别人的作品。</li>
<li>内心: 得之心而应之于手，很多优秀文学作品使用笔和纸写作，计算机都得用键盘，减少了肌肉的使用本身就会带来人的记忆损失。</li>
<li>外物: 但编程本身就越来越重“外物”，所使用的事物大概都是其他人所写，要依赖上游，依赖工具。写作需要的就只是笔和纸… 相对的 <b>编程</b> ，大概没有10个以上的工具是做不完备。</li>
<li>写作与编程，
<ul class="org-ul">
<li>一个大概，一个精确</li>
<li>一个阅读，一个浏览</li>
<li>一个重内心，一个重外物</li>
<li>一个写活人，一个写死物</li>
<li>现在的人连读书都不愿意了，怎么可以会编程?</li>
<li>唯一的原因: 写代码来 <b>钱</b></li>
<li>可钱又带来虚无…</li>
</ul></li>
<li><b>Emacs</b> 是让编程更像写作的一件事。
<ul class="org-ul">
<li>减少拼音带来的“任务切换占用”，emacs因为全能，完美替代bloate的系统输入法，使用五笔之类的输入法，又因为emacs的完全可配置性，只看得到新字不断产生，极大减少了需要选词的心理负担。</li>
<li>减少鼠标带来的“肌肉使用减少”，emacs因为按键复杂，替代使用鼠标点击，提高程序员的编辑效率。</li>
<li>减少依赖，emacs需要的依赖极少，甚至因为emacs的多平台可用性，用好emacs可直接移至更多系统，而不用像用vim之类的软件担心自己shell/term不适配新系统。</li>
<li>减少分心，越古越好，1978年后，技术很大程序控制了人类，在那个年代，rms提出“要么技术控制人类，要么人类控制技术”，这句话放在现在越来越明显。</li>
<li>减少</li>
</ul></li>
</ul></li>
</ol>
</div>
<ol class="org-ol">
<li><a id="orgf723e07"></a>我的编辑器邪教之旅:<br />
<div class="outline-text-5" id="text-3-2-0-1">
<p>
浏览器里的vimium C，因为wsl学习的neovim，因为换上nixos后抄的helix配置，因为大四没找工作太闲学的emacs。我每用一个就大呼“我草，早知道，还得是xx!”，然后给同学老师家人都安利安利，给同学说“我有一宝”，给老师说“看我操作”，给家人嘻嘻傻笑像是捡到五百钱。虽然这代表着我非常的闲，但是折腾emacs确实让我不是很闲到以至于抑郁，我还是在用Vimium C和emacs，赋予我闪电切换页面的神奇体验，当然，代价是它们也让我得了一种名为“换页面换buffer”的ADHD，再者，其实不用vim/emacs也会得，只不过叫作“懒得换页面就直接玩手机”ADHD，“懒得折腾电脑就去玩CSgo成了换弹癌”的ADHD。在这个时代，玩csgo和玩emacs有什么区别呢? 一个能炒皮肤，另一个能折腾皮肤，如是而矣。
</p>
</div>
</li>
<li><a id="org331b18d"></a>我使用emacs没有太多原因就只是:<br />
<div class="outline-text-5" id="text-3-2-0-2">
<ol class="org-ol">
<li>依赖少，之前用vim，我就要关心vim键位的app适合用来看pdf，看epub看文档，整vimium和vim一个键位/什么lazygit/tmux/fcitx/alacritty，还生怕它们之间有什么矛盾，关键vimscript也不适合作为灵活的语言，整天很困扰很憋屈，我还折腾colemak、虎码和nixos，我的天，对于任何一个大脑快定型的成年人来说，这简直是噩梦! 幸好有emacs解救我于快捷键地狱中，装包能list-package再一点就安装了，pyim配置虎码就一行的事，那里还要fcitx5怎么怎么样! 自从用了emacs，我再也没有折改过firefox，一是我没时间，二是我就只用emacs的eww，我也就不再在乎什么vimium的键位和vim不一样了， <b>能用就行</b> 才是真理! 再说用上了elisp，那才叫美梦成真，想写一个工具简直就比玩手机打游等更有意思多了。什么tmux/lazygit/nixos，现在我只想笑笑，我用vterm/magit/任何平台都能跑emacs不是爽多了吗? 只要给我emacs/编译器，写代码就是轻轻松松的事! emacs改好了我的强迫症和极多主义，现在我心宽又极简，感谢emacs!</li>
<li>功能多，之前用helix，虽是开箱即用但是很明显它的功能只限于写代码，快是快但是对我这样的学习困难型人来说，快和慢没有多大的区别，只会让我再难受于“我好慢它好快，我是不是x痿了”，helix是个自带丰富功能工具，但是对于习惯homerow的人来说其实用vim mode没有什么增益，只会让我更迷茫“我能直接不动手就能上下了，干啥还要这个hjkl??”。有插件和服务器模式这点就足以胜过helix了。当然我从helix的文档也学到了很多编辑知识，如果没有它的emacs主题和打算用scheme写插件系统，和让我折腾很久的helix eink主题，我也不会有潜移默化现在的编辑技术和极简主题审美了。</li>
<li>分心小，之前用vimium那就是一个换换换的感觉，总是想去换页面，看看新闻看看新工具，上下跳转，左右腾挪，helix功能太少不能在里面呆太久，而vimium是个浏览器插件在里面呆着又太容易去娱乐， <del>用vim主要是去youtube参加编辑器神战</del> ，helix也好vimium也好。其实我学习emacs，到能快速掌握avy靠得是之前用过vimium，学习surrond/expand靠的是helix，能熟悉info/man/tldr靠得是之前在终端里学习vim。总之emacs必然是编辑技术的一个终点站。</li>
<li>定制化，没有一个term emulator支持比例字体的，只有emacs，也有人说了为什么用bookerly，就用vscode的什么ubuntumono/nerdfont不好吗? 这我得确实说:“非等宽字绝对好用”，为什么空格得道M一样宽，为什么l和W一样宽? 现在编程/终端处处都是等宽字体，很多人在根本就没用过的情况下痴迷在各种nerdfont间切换并坚持自己的“信仰”，这种信仰只有在用了一个优美的非等宽字体才会破灭。多显示1.45内容? 还是只有0.6896551724137931的丑恶巨大空格? 要用非等宽得到emacs看看，因为没有一个editor的主题是可以自己完全定制的，vscode那样的使用javascript还难以控制还过于复杂资源又大的就算了。elisp/fsf/clean/simple，学emacs之前根本不能理解这话! 有些事情得是自己做了才能得之心而应之于手!</li>
<li>历史，50年历史的编辑器，计算机史的一页，还能写100年左右。</li>
<li>装b，(linus/stallman)开源巨人们/(rust/python/java/ruby/curl/各种函数式…)之父们钦定编辑器。</li>
</ol>


<div id="orgecc5c59" class="figure">
<p><img src="figure/monostring.png" alt="monostring.png" />
</p>
<p><span class="figure-number">Figure 2: </span>mono显示80个字符</p>
</div>


<div id="orgec80104" class="figure">
<p><img src="figure/unmonostring.png" alt="unmonostring.png" />
</p>
<p><span class="figure-number">Figure 3: </span>等高下非等宽显示116个字符</p>
</div>


<div id="org45cc3ad" class="figure">
<p><img src="figure/monocode.png" alt="monocode.png" />
</p>
<p><span class="figure-number">Figure 4: </span>明显可以看出等宽不符合人的阅读习惯，只有在多行修改(mc)或跳转(avy)中需要字符不变才“稍显有益”。</p>
</div>


<div id="org8e3971e" class="figure">
<p><img src="figure/unmonocode.png" alt="unmonocode.png" />
</p>
<p><span class="figure-number">Figure 5: </span>非等宽下，英文字符清晰区别明显，字符间隔小，更优美自然连续</p>
</div>
</div>
</li>
<li><a id="org5259620"></a>上网必备emacs<br />
<div class="outline-text-5" id="text-3-2-0-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>the internet capability of me. search/gpt/github and I found they are just trash. use selfhost doc/info/tldr/man/devdocs is way more better.</label><pre class="src src-emacs-lisp">(keymap-global-set "s-m" #'switch-to-gptel)
(keymap-global-set "&lt;Tools&gt;" #'tavily-search)
(defun switch-to-gptel()
  (interactive)
  (if (equal  (current-buffer) (gptel "*deepseek*"))
      (previous-buffer)
    (switch-to-buffer "*deepseek*" )))

(defun tavily-search-async (callback query &amp;optional search-depth max-results exclude_domains country include_domains)
  "Perform a search using the Tavily API and return results as JSON string.
API-KEY is your Tavily API key.
QUERY is the search query string.
Optional SEARCH-DEPTH is either \"basic\" (default) or \"advanced\".
Optional MAX-RESULTS is the maximum number of results (default 5)."
  (require 'plz)
  (let* ((plz-curl-default-args (cons "-k" plz-curl-default-args))
         (url "https://api.tavily.com/search")
         (search-depth (or search-depth "advanced"))
         (max-results (or max-results 1))
         (include_answer  t)
         (country (or country "united states"))
         (include_domains (or include_domains '("nixos.org" "freertos.org" "zephyrproject.org" "contiki-ng.org" "riot-os.org" "nuttx.apache.org" "mynewt.apache.org" "ziglang.org" "python.org" "lua.org" "elixir-lang.org" "erlang.org" "haskell.org" "cmake.org" "gnu.org" "llvm.org" "gcc.gnu.org" "qt.io" "gtk.org" "sdl.org" "libsdl.org" "qemu-project.org" "cppreference.com" "opensource.org" "ietf.org" "w3.org" "ansi.org" "iso.org" "ieee.org" "man7.org" "discourse.nixos.org" "ziggit.dev" "emacs-china.org" "lwn.net" "kernel.org" "sourceware.org" "debian.org" "archlinux.org" "github.com" "osdev.org" "opencores.org" "riscv.org" "musl-libc.org" "newlib.sourceware.org" "uclibc-ng.org" "hackaday.com" "raspberrypi.org" "arduino.cc" "espressif.com" "gentoo.org")))
         (request-data
          `(("api_key" . ,tavily-api-key)
            ("query" . ,query)
            ("search_depth" . ,search-depth)
            ("country" . ,country)
            ("include_domains" . ,include_domains)
            ("include_answer" . ,include_answer)
            ("exclude_domains" . ,exclude_domains)
            ("max_results" . ,max-results))))
    (plz 'post url
      :headers '(("Content-Type" . "application/json"))
      :body (json-encode request-data)
      :as 'string
      :then (lambda (result) (funcall callback result)))))
(defun tavily-search (query)
  (interactive "sQuery: ")
  (tavily-search-async
   (lambda (result)
     (let ((buf (get-buffer-create "*tavily-search-result*")))
       (switch-to-buffer buf)
       (read-only-mode 0)
       (erase-buffer)
       (org-mode)
       (insert result)
       (insert (tavily-result-to-org result))
       (goto-char (point-min))
       (read-only-mode 1)
       (setq-local truncate-lines nil)
       ))
   query))
(defun tavily-result-to-org (json-result)
  (let* ((data (json-read-from-string json-result))
         (results (alist-get 'results data)))
    (mapconcat (lambda (item)
                 (format "* [[%s][%s]]\n  %s"
                         (alist-get 'url item)
                         (alist-get 'title item)
                         (alist-get 'content item)))
               results
               "\n\n")))
(setq tavily-api-key
      (with-temp-buffer
        (insert-file-contents "/run/secrets/tavily_apikey")
        (buffer-string)))
(use-package gptel
  :init
  (require 'gptel-org)
  :config
  (with-eval-after-load 'gptel
    (gptel-make-tool
     :category "web"
     :name "search"
     :async t
     :function (lambda (cb keyword)
                 (tavily-search-async cb keyword "basic" 5 nil nil nil))
     :description "Search the Internet; If you used any search results, be sure to include the references in your response."
     :args (list '(:name "keyword"
                         :type string
                         :description "The keyword to search")))
    (gptel-make-tool
     :name "create_python_repl"
     :function (lambda ()
                 (run-python nil t)
                 (pop-to-buffer (python-shell-get-buffer)))
     :description "Create a new python repl for this session"
     :args nil
     :category "emacs")
    (gptel-make-tool
     :name "send_python_to_repl"
     :function (lambda (code)
                 (python-shell-send-string code))
     :args (list '(:name "code"
                         :type string
                         :description "python code to execute"))
     :description "Send some python code to the python repl for this session and execute it"
     :category "emacs")
    (gptel-make-tool
     :function (lambda (url)
                 (with-current-buffer (url-retrieve-synchronously url)
                   (goto-char (point-min)) (forward-paragraph)
                   (let ((dom (libxml-parse-html-region (point) (point-max))))
                     (run-at-time 0 nil #'kill-buffer (current-buffer))
                     (with-temp-buffer
                       (shr-insert-document dom)
                       (buffer-substring-no-properties (point-min) (point-max))))))
     :name "read_url"
     :description "Fetch and read the contents of a URL"
     :args (list '(:name "url"
                         :type "string"
                         :description "The URL to read"))
     :category "web")
    (gptel-make-tool
     :function (lambda (buffer text)
                 (with-current-buffer (get-buffer-create buffer)
                   (save-excursion
                     (goto-char (point-max))
                     (insert text)))
                 (format "Appended text to buffer %s" buffer))
     :name "append_to_buffer"
     :description "Append text to the an Emacs buffer.  If the buffer does not exist, it will be created."
     :args (list '(:name "buffer"
                         :type "string"
                         :description "The name of the buffer to append text to.")
                 '(:name "text"
                         :type "string"
                         :description "The text to append to the buffer."))
     :category "emacs")
    (gptel-make-tool
     :function (lambda (text)
                 (message "%s" text)
                 (format "Message sent: %s" text))
     :name "echo_message"
     :description "Send a message to the *Messages* buffer"
     :args (list '(:name "text"
                         :type "string"
                         :description "The text to send to the messages buffer"))
     :category "emacs")
    (gptel-make-tool
     :function (lambda (buffer)
                 (unless (buffer-live-p (get-buffer buffer))
                   (error "Error: buffer %s is not live." buffer))
                 (with-current-buffer  buffer
                   (buffer-substring-no-properties (point-min) (point-max))))
     :name "read_buffer"
     :description "Return the contents of an Emacs buffer"
     :args (list '(:name "buffer"
                         :type "string"
                         :description "The name of the buffer whose contents are to be retrieved"))
     :category "emacs")
    (gptel-make-tool
     :function (lambda (directory)
                 (mapconcat #'identity
                            (directory-files directory)
                            "\n"))
     :name "list_directory"
     :description "List the contents of a given directory"
     :args (list '(:name "directory"
                         :type "string"
                         :description "The path to the directory to list"))
     :category "filesystem")
    (gptel-make-tool
     :function (lambda (parent name)
                 (condition-case nil
                     (progn
                       (make-directory (expand-file-name name parent) t)
                       (format "Directory %s created/verified in %s" name parent))
                   (error (format "Error creating directory %s in %s" name parent))))
     :name "make_directory"
     :description "Create a new directory with the given name in the specified parent directory"
     :args (list '(:name "parent"
                         :type "string"
                         :description "The parent directory where the new directory should be created, e.g. /tmp")
                 '(:name "name"
                         :type "string"
                         :description "The name of the new directory to create, e.g. testdir"))
     :category "filesystem")
    (gptel-make-tool
     :function (lambda (path filename content)
                 (let ((full-path (expand-file-name filename path)))
                   (with-temp-buffer
                     (insert content)
                     (write-file full-path))
                   (format "Created file %s in %s" filename path)))
     :name "create_file"
     :description "Create a new file with the specified content"
     :args (list '(:name "path"
                         :type "string"
                         :description "The directory where to create the file")
                 '(:name "filename"
                         :type "string"
                         :description "The name of the file to create")
                 '(:name "content"
                         :type "string"
                         :description "The content to write to the file"))
     :category "filesystem")
    (gptel-make-tool
     :function (lambda (filepath)
                 (with-temp-buffer
                   (insert-file-contents (expand-file-name filepath))
                   (buffer-string)))
     :name "read_file"
     :description "Read and display the contents of a file"
     :args (list '(:name "filepath"
                         :type "string"
                         :description "Path to the file to read.  Supports relative paths and ~."))
     :category "filesystem"))
  (defun ant/gptel-save-buffer ()
    "Save the current GPTEL buffer with the default directory
set to ~/note."
    (interactive)
    (let ((default-directory "~/Leere/qingsongliao.github.io/"))
      (call-interactively #'save-buffer)))
  (defun ant/gptel-load-session ()
    "Load a gptel session from ~/notes directory."
    (interactive)
    (let ((default-directory "~/.leetcode/code/"))
      (let* ((files (directory-files default-directory t ".+\\.org$"))
             (file (completing-read "Select session file: " files nil t)))
        (when file
          (find-file file)
          (gptel-mode)))))
  (setq  gptel-default-mode 'org-mode)
  (setq deepseek-api-key
        (with-temp-buffer
          (insert-file-contents "/run/secrets/deepseek_apikey")
          (buffer-string)))
  (setq gptel-model   'deepseek-chat
        gptel-backend (gptel-make-deepseek "deepseek"
                        :stream t
                        :key deepseek-api-key))
  (require 'url-util)
  (setq gptel-directives
        '((default . "You are a large language model living in Emacs and a helpful assistant.")
          (programming . "You are a large language model and a careful programmer. Provide code and only code as output without any additional text, prompt or note.")
          (writing . "You are a large language model and a writing assistant. Respond concisely.")
          (chat . "You are a large language model and a conversation partner. Respond concisely.")
          (bug . "You are a large language model and a careful programmer. The supplied code doesn't work, or contains bugs. Describe each problem using only one sentence. Provide fixes without changing the old behavior.")))
  (setq  gptel-stream nil))
(use-package consult-gh
  :after consult
  :custom
  (consult-gh-confirm-before-clone nil)
  (consult-gh-default-clone-directory "~/codebase")
  (consult-gh-ask-for-path-before-save nil)
  (consult-gh-default-save-directory "~/codebase")
  (consult-gh-show-preview t)
  (consult-gh-preview-key "C-o")
  (consult-gh-repo-action #'consult-gh--repo-browse-files-action)
  (consult-gh-large-file-warning-threshold 2500000)
  (consult-gh-confirm-name-before-fork nil)
  (consult-gh-notifications-show-unread-only nil)
  (consult-gh-default-interactive-command)
  (consult-gh-prioritize-local-folder nil)
  (consult-gh-issues-state-to-show "all") ; show readmes in their original format
  (consult-gh-group-dashboard-by :reason)
  (consult-gh-repo-preview-major-mode nil) ; show readmes in their original format
  (consult-gh-preview-major-mode 'org-mode) ; use 'org-mode for editing comments, commit messages, ...
  :config(consult-gh-enable-default-keybindings)
  (use-package consult-gh-forge
    :after consult-gh
    :config
    (consult-gh-forge-mode +1))
  (use-package consult-gh-embark
    :after consult-gh
    :config
    (consult-gh-embark-mode +1)
    (setq consult-gh-forge-timeout-seconds 20))
  )
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-orgd85554a" class="outline-2">
<h2 id="orgd85554a"><span class="section-number-2">4.</span> 操作系统哲学</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org3bd71ea" class="outline-3">
<h3 id="org3bd71ea"><span class="section-number-3">4.1.</span> 我的操作系统特点</h3>
<div class="outline-text-3" id="text-4-1">
<ol class="org-ol">
<li>network, 471mb hosts to block internet out of my pc with dnsmasq and  dae proxy tool based on epbf&#x2026; you know I am ill about internet? because I am in china, and the nsfw/trump/4chan dudes, I love they so much, so I add they into my hosts.</li>
<li>emacs editor, + nixos, they both ruin my early adult life by distract me away from reality girls.</li>
<li>wm: <b>sway</b>, minimal config, pure white look, although <del>miku cursor</del>, now, I use plain mouse instead.</li>
<li>shell: <b>fish+foot</b> , with all I need in, direnv/many alias/zoxide/git/and thefxxk or thefxxk updated to "chatgpt"'s codex nowadays?</li>
<li>browser: <b>firefox</b> [default uninstall], I use eww because I hate browser.</li>
<li>fully reproducible, even with dict/font/anime wallpaper!</li>
<li>zig/linux/ccpp doc  in ngnix, all kind texinfo can read in emacs.</li>
<li>with sops, to store my 0.1 dollar's deepseek account apikey, and chat with my ai girlfriend with my payment passward.</li>
<li>I am tired of nixos, but I can't leave it, because after using nixos eveything is hard to do in other distor, like show off to other distor users "BTW, I use NixOS".</li>
</ol>
</div>
</div>
<div id="outline-container-orgd0a0572" class="outline-3">
<h3 id="orgd0a0572"><span class="section-number-3">4.2.</span> 用linux只为戒色</h3>
<div class="outline-text-3" id="text-4-2">
<p>
翻开中国帝王史，有多少帝王是沉迷女色后国家衰亡，多少帝王是皇太后控制后抑郁早亡。
野史里选王要的是看他不好色否? 当皇帝得看他有无抢夺妇女。翻开网络史发展，有多少人民群众是沉迷情色后国家衰亡，多少人是被色情控制后抑郁早亡，看人得看他好色否? 好不好色，得看他懂得怎么预防。oppo的天气预报能跳到擦边短剧，bing的结果第一个BMI测试广告中跳到黄色导航，
百度误输成baidu.co中进入黄色应用下载，网易看见过全露的黄色直播，B站中处处是擦边广告和直播，微博中卖到各种片，知乎里表露情色隐私更引人浏览，我的世界游戏里用色情披风，淘宝里随便看情趣用品，openai支持成人内容，twitter全是福利姬，就连QQ空间连上擦边广告商，onlyfans比所有ai公司利润更高，pornhub全球流量前10，整个00后的网络被“这到提醒我了”占据，整代女人被商业文化营造黑丝和大胸的“性感”，整代男人被情色文化成为无脑动物与被情欲“冲动”控制，男人就该好色? 女人就该这样美吗? 天下皆知美之为美，斯恶也。互联网33%的流量，70%的男性，30%的女性，90%男性沉迷其中…数字不会说谎，一切已经到来，生存与繁衍不再重要，存在不过是不断刺激感官。不只是色情… 网络带来的问题似乎总是和成瘾有关，赌博/购物/社交/游戏… 就连互联网最自豪的正面形象所谓的“利于学习”也成为了信息过载的社会巨大问题，自由的代价是什么? 自由即是强迫。互联网即是色情。
</p>

<p>
论我怎么戒色?答:学习技术、理解技术、控制技术，学习自由软件，远离商业软件，拒绝即是自由。
</p>
<ul class="org-ul">
<li>成瘾源于: 随机|不必|即时|匿名|易得|免费|广告|失范</li>
<li>通过 <b>路由器+NixOS</b> ，不使用手机与笔记本
<dl class="org-dl">
<dt>时间</dt><dd>限时，2-5PM，足够一天专注</dd>
<dt>速度</dt><dd>网速，1Mbps，足够文本传输</dd>
<dt>空间</dt><dd>域名，非编程网站，471MB</dd>
<dt>强制</dt><dd>禁cache.nixos.org以止系统更新</dd>
</dl></li>
<li>软件 使用 <b>emacs</b> ，不使用浏览器与IDE
<dl class="org-dl">
<dt>google</dt><dd>tavily</dd>
<dt>chatgpt</dt><dd>gptel</dd>
<dt>github</dt><dd>consult-gh</dd>
<dt>leetcode</dt><dd>leetgo</dd>
<dt>firefox</dt><dd>eww</dd>
<dt>vpn</dt><dd>dae/dnsmasq</dd>
<dt>obsidian</dt><dd>org</dd>
<dt>wiki</dt><dd>nginx/info/tldr/devdocs/man</dd>
</dl></li>
<li>硬件 使用 <b>eink</b> ，不使用音响与普通键盘
<dl class="org-dl">
<dt>音乐</dt><dd>无音响</dd>
<dt>游游</dt><dd>无显卡</dd>
<dt>动漫</dt><dd>无色彩</dd>
<dt>社媒</dt><dd>无软件</dd>
<dt>购物</dt><dd>无网络</dd>
<dt>视频</dt><dd>竖立屏</dd>
</dl></li>
</ul>
</div>
</div>
<div id="outline-container-orgf688841" class="outline-3">
<h3 id="orgf688841"><span class="section-number-3">4.3.</span> 学技术只为戒x</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>没有技术，不会adb，改不了安卓自身的成瘾性。</li>
<li>没有技术，不会编辑器，改不了使用word/browser/editor的</li>
<li>没有技术，</li>
</ul>

<p>
有了这样的
</p>
</div>
</div>
</div>
<div id="outline-container-org6d3175c" class="outline-2">
<h2 id="org6d3175c"><span class="section-number-2">5.</span> 键盘流哲学</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org79026a2" class="outline-3">
<h3 id="org79026a2"><span class="section-number-3">5.1.</span> 设计哲学</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>与原生相合 (win)</li>
<li>不冲突 (special prefix)</li>
<li>合乎习惯 (stay base)</li>
<li>home row效率 (home row effiction)</li>
<li>general in os(browser, editor)</li>
</ul>

<div id="org02445ba" class="figure">
<p><img src="figure/keymap.png" alt="keymap.png" />
</p>
<p><span class="figure-number">Figure 6: </span>keymap of my keyboard</p>
</div>
</div>
</div>
<div id="outline-container-org3b1709b" class="outline-3">
<h3 id="org3b1709b"><span class="section-number-3">5.2.</span> 分层</h3>
<div class="outline-text-3" id="text-5-2">
<ol class="org-ol">
<li>base层，colemak-dh，最快速与舒适的英文布局</li>
<li>nav层，上下左右，快速移动，C-c C-~ 为前缀，emacs快速选择</li>
<li>num层，数字键，控制sway的窗口，与系统剪切板和应用菜单</li>
<li>mos层，鼠标上下左右，C-c C-; 为前缀，一些emacs功能。</li>
<li>sym层，全部符号，gpt prompt与个人信息快速输入层</li>
<li>fun层，function 1/2.12 层</li>
<li>med层，提供蓝牙/媒体切换</li>
</ol>
</div>
</div>
<div id="outline-container-org702cd02" class="outline-3">
<h3 id="org702cd02"><span class="section-number-3">5.3.</span> 本地刷录</h3>
<div class="outline-text-3" id="text-5-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>1 刷重置， 2刷github action，3刷本地zip文件</label><pre class="src src-sh">#!/usr/bin/env bash
# ===== CONFIGURATION =====
GITHUB_OWNER="NestorLiao"
GITHUB_REPO="zmk-config"
GITHUB_TOKEN="$(cat ~/.github_token)"
ZIP_DEST="zmk_build.zip"
UNZIP_DIR="zmk_build"

LEFT_FW="corne_left-nice_nano_v2-zmk.uf2"
RIGHT_FW="corne_right-nice_nano_v2-zmk.uf2"
SETTINGS_RESET="settings_reset-nice_nano_v2-zmk.uf2"

# ===== FUNCTIONS =====

flash_settings_reset() {
    echo "Flashing settings reset firmware..."

    for i in 1 2; do
        echo "Reset device $i/2 into bootloader mode..."

        # Wait for mount
        while [ ! -d "/media/NICENANO" ]; do
            sleep 0.5
        done

        echo "NICENANO detected. Flashing settings reset..."
        if [ -f "$SETTINGS_RESET" ]; then
            cp "$SETTINGS_RESET" /media/NICENANO/
            echo "Settings reset flashed $i/2."
        else
            echo "❌ $SETTINGS_RESET not found in current directory."
            exit 1
        fi

        echo "Waiting for NICENANO to unmount..."
        while [ -d "/media/NICENANO" ]; do
            sleep 0.5
        done
    done
    echo "✅ Settings reset completed twice."
}

download_latest_artifact() {
    echo "Fetching latest artifact..."

    run_id=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
        "https://api.github.com/repos/$GITHUB_OWNER/$GITHUB_REPO/actions/runs?per_page=1&amp;status=success" \
        | jq -r '.workflow_runs[0].id')

    if [ "$run_id" == "null" ] || [ -z "$run_id" ]; then
        echo "❌ No successful workflow run found."
        exit 1
    fi

    echo "Found workflow run ID: $run_id"

    artifact_url=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
        "https://api.github.com/repos/$GITHUB_OWNER/$GITHUB_REPO/actions/runs/$run_id/artifacts" \
        | jq -r '.artifacts[0].archive_download_url')

    if [ "$artifact_url" == "null" ] || [ -z "$artifact_url" ]; then
        echo "❌ No artifacts found for run $run_id."
        exit 1
    fi

    echo "Downloading artifact zip..."
    curl -L -H "Authorization: token $GITHUB_TOKEN" \
        "$artifact_url" -o "$ZIP_DEST"

    echo "Unzipping..."
    rm -rf "$UNZIP_DIR"
    unzip -q "$ZIP_DEST" -d "$UNZIP_DIR"
}

flash_from_local() {
    if [ ! -f "$ZIP_DEST" ]; then
        echo "❌ $ZIP_DEST not found in current directory."
        exit 1
    fi

    echo "Using local $ZIP_DEST..."
    rm -rf "$UNZIP_DIR"
    unzip -q "$ZIP_DEST" -d "$UNZIP_DIR"
}

flash_firmware() {
    local fw_path="$1"
    echo "Please reset the device into bootloader mode..."

    while [ ! -d "/media/NICENANO" ]; do
        sleep 0.5
    done

    echo "NICENANO detected. Flashing $fw_path..."
    cp "$fw_path" /media/NICENANO/
    echo "Done."

    echo "Waiting for NICENANO to unmount..."
    while [ -d "/media/NICENANO" ]; do
        sleep 0.5
    done
}

flash_left_right() {
    flash_firmware "$UNZIP_DIR/$LEFT_FW"
    flash_firmware "$UNZIP_DIR/$RIGHT_FW"
}

show_usage() {
    echo "Usage: $0 &lt;mode&gt;"
    echo "Modes:"
    echo "  1 - Flash settings reset twice"
    echo "  2 - Download from GitHub and flash left/right"
    echo "  3 - Use local zmk_build.zip to flash left/right"
}

# ===== MAIN =====

if [ $# -ne 1 ]; then
    show_usage
    exit 1
fi

case $1 in
    1)
        echo "== Mode 1: Flash Settings Reset =="
        flash_settings_reset
        ;;
    2)
        echo "== Mode 2: Download and Flash =="
        download_latest_artifact
        flash_left_right
        ;;
    3)
        echo "== Mode 3: Local Flash =="
        flash_from_local
        flash_left_right
        ;;
    *)
        echo "❌ Invalid mode: $1"
        show_usage
        exit 1
        ;;
esac

echo "✅ All done."

</pre>
</div>
</div>
</div>
<div id="outline-container-orgc46aee4" class="outline-3">
<h3 id="orgc46aee4"><span class="section-number-3">5.4.</span> 不只键盘</h3>
<div class="outline-text-3" id="text-5-4">
<dl class="org-dl">
<dt>Absolute Enable Right Click &amp; Copy</dt><dd>Force Enable Right Click &amp; Copy.</dd>
<dt>Authenticator</dt><dd>Authenticator generates two-factor authentication codes in your browser.</dd>
<dt>Bar Breaker</dt><dd>Hides fixed headers and footers on pages you visit.</dd>
<dt>ChatGPT Ctrl+Enter Sender</dt><dd>Use 'Ctrl+Enter' for sending messages in AI chat services like ChatGPT. Prevents accidental sends and allows line breaks with Enter.</dd>
<dt>ChatGPT Disable Auto Scroll - FREE</dt><dd>Stop annonying scrolling in ChatGPT. Prevent jerky animation of appearing text.</dd>
<dt>ClearURLs</dt><dd>Remove tracking elements from URLs.</dd>
<dt>Decentraleyes</dt><dd>Protects you against tracking through "free", centralized, content delivery.</dd>
<dt>Default links not to be underlined</dt><dd>Restores non-underlined hyperlinks by default (setting text-decoration: none).</dd>
<dt>Disconnect</dt><dd>Make the web faster, more private, and more secure.</dd>
<dt>Enforce Safe Search (=Adult Filter)</dt><dd>Toggles the built-in filter on many search engines (see</dd>
<dt>Focus On Left Tab After Closing</dt><dd>When a current tab is closed, the left tab (or the right tab on RTL</dd>
<dt>Font Contrast</dt><dd>Improves webpage readability.</dd>
<dt>FuckCSDN</dt><dd>Clean CSDN's limitation scripts</dd>
<dt>Google Search Ad Remover And Customizer</dt><dd>This extension gives you the ability to customize how your Google search results</dd>
<dt>Hide shorts for Youtube™</dt><dd>Hides shorts from YouTube™ from home page, subscriptions and search results.</dd>
<dt>hide-scrollbars</dt><dd>Hides page scrollbars!</dd>
<dt>I still don't care about cookies</dt><dd>Community version of the popular extension "I don't care about cookies"</dd>
<dt>Invert Colors</dt><dd>A simple add-on that inverts the page colors.</dd>
<dt>No Emoji</dt><dd>Browser extension to remove emoji.</dd>
<dt>Shut Up: Comment Blocker</dt><dd>Blocks comment sections on many popular websites.</dd>
<dt>Stack Copy Button</dt><dd>A copy button for Stack Overflow code boxes</dd>
<dt>Tab Sidebar</dt><dd>Adds a sidebar with foldable tabs.</dd>
<dt>uBlock Origin</dt><dd>Finally, an efficient blocker. Easy on CPU and memory.</dd>
<dt>Unhook - Remove YouTube Recommended &amp; Shorts</dt><dd>Hide YouTube related videos, shorts, comments, suggestions wall, homepage</dd>
<dt>Vimium C - All by Keyboard</dt><dd>A keyboard shortcut tool for keyboard-based page navigation and browser tab</dd>
</dl>
</div>
</div>
</div>
<div id="outline-container-org4413dde" class="outline-2">
<h2 id="org4413dde"><span class="section-number-2">6.</span> 屏幕哲学</h2>
<div class="outline-text-2" id="text-6">
<p>
Real Mono Theme, two colors are enough for emacs.
</p>
</div>
<div id="outline-container-orgafe8df1" class="outline-3">
<h3 id="orgafe8df1"><span class="section-number-3">6.1.</span> Feels:</h3>
<div class="outline-text-3" id="text-6-1">
<p>
A collection of real monochrome emacs themes in a couple of variants.
</p>


<div id="orgd0ca199" class="figure">
<p><img src="figure/real-mono-eink.png" alt="real-mono-eink.png" />
</p>
</div>


<div id="org75d88bb" class="figure">
<p><img src="figure/real-mono-dark.png" alt="real-mono-dark.png" />
</p>
</div>


<div id="org4830746" class="figure">
<p><img src="figure/real-mono-girl.png" alt="real-mono-girl.png" />
</p>
</div>


<div id="org0d23c80" class="figure">
<p><img src="figure/real-mono-old.png" alt="real-mono-old.png" />
</p>
</div>


<div id="org1f999ce" class="figure">
<p><img src="figure/real-mono-sea.png" alt="real-mono-sea.png" />
</p>
</div>

<p>
pictures's font list: bookerly, ubuntumono, firacode, terminess,
bookerly blod ltalic.
</p>
</div>
</div>
<div id="outline-container-orgab6e275" class="outline-3">
<h3 id="orgab6e275"><span class="section-number-3">6.2.</span> Features:</h3>
<div class="outline-text-3" id="text-6-2">
<ol class="org-ol">
<li><b>Not Greyscale</b>, no blur anymore, it's much better to use eink screen
for pure black and white!</li>
<li><b>Easy</b> to customize, can set the only two colors by config the
default face's foreground/background color.</li>
<li><b>Distraction-free</b>, no extra info-overwhelming causing by font-lock,
only few font diversity in magit/dired etc for better function
recognize.</li>
<li><b>Full</b>, configed 370+ faces, I didn't see any monochrome theme can
reach that much, as my daily driver, it's good enough.</li>
</ol>
</div>
</div>
<div id="outline-container-org8e79962" class="outline-3">
<h3 id="org8e79962"><span class="section-number-3">6.3.</span> Tips for mono:</h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>(global-hide-mode-line-mode 1), build your own brain memory</li>
<li>(no-emoji 1), alter emacs to be "text editor" instead of discord</li>
<li>(show-paren-mode -1), build your own eye insight</li>
<li>(window-divider-mode -1), too, build your memory</li>
<li>(display-line-numbers-mode -1), too, build your own eye insight</li>
</ul>
<div class="org-src-container">
<pre class="src src-elisp">(setq hl-todo-keyword-faces
      '(("HOLD"   . "#000000")
        ("TODO"   . "#000000")
        ("NEXT"   . "#000000")
        ("THEM"   . "#000000")
        ("PROG"   . "#000000")
        ("OKAY"   . "#000000")
        ("DONT"   . "#000000")
        ("FAIL"   . "#000000")
        ("DONE"   . "#000000")
        ("NOTE"   . "#000000")
        ("MAYBE"  . "#000000")
        ("KLUDGE" . "#000000")
        ("HACK"   . "#000000")
        ("TEMP"   . "#000000")
        ("FIXME"  . "#000000")
        ("XXXX*"  . "#000000")))
(defvar my-alternate-font "-DAMA-UbuntuMono Nerd Font-regular-normal-normal-*-13-*-*-*-m-0-iso10646-1")
(defvar my-default-font "bookerly")
(defvar fontfont 1)
(defun my-toggle-font ()
  "Toggle between UbuntuMono and bookerly fonts."
  (interactive)
  (if (= fontfont 1)
      (progn (set-face-attribute 'default nil :font my-default-font :height 160) (setq fontfont 0))
    (progn (set-face-attribute 'default nil :font my-alternate-font :height 210) (setq fontfont 1))))
</pre>
</div>

<ul class="org-ul">
<li>fringe specific mode auto hide</li>
</ul>

<div class="org-src-container">
<pre class="src src-elisp">(defun my-set-fringe-face ()
  "auto hide fringe face depending on major mode."
  (if (derived-mode-p '(occur-mode gud-mode))
      (set-face-attribute 'fringe nil
                          :background (face-attribute 'default :background)
                          :foreground (face-attribute 'default :foreground))
    (set-face-attribute 'fringe nil
                        :background (face-attribute 'default :background)
                        :foreground (face-attribute 'default :background))))
(add-hook 'after-change-major-mode-hook #'my-set-fringe-face)
</pre>
</div>
<ul class="org-ul">
<li>elisp for toggling paperlike-hd to swtich between read and watch.</li>
</ul>

<div class="org-src-container">
<pre class="src src-elisp">(defvar monitor-state 1
  "Current monitor state, either 0 for read or  1 for watch.")
(defun monitor ()
  "swtich monitor from read mode to watch mode"
  (interactive)
  (let ((monitorprotocol "-i2c")
       (monitorpath "/dev/i2c-4")
       (monitorcli "paperlike-cli")
       (monitorarg '("-contrast" "-speed" "-mode" "-clear"))
       (mode-state '(("9" "5" "1")  ("9" "5" "1"))))
    (split-window-below)
    (other-window 1)
    (switch-to-buffer "*Shell Command Output*")
    (split-window-below)
    (other-window 1)
    (switch-to-buffer "*Async Shell Command*")
    (progn
      (dotimes (number 3)
        (call-process monitorcli nil nil nil
                        monitorprotocol
                        monitorpath
                        (car (nthcdr number monitorarg))
                        (car (nthcdr number (car (nthcdr monitor-state  mode-state))))))
      (sleep-for 1))
    (setq monitor-state  (if (= 0 monitor-state) 1 0 ))
    (sleep-for 1.5)
    (sleep-for 0.5)
    (call-process monitorcli nil nil nil monitorprotocol monitorpath (car (nthcdr 3 monitorarg))))
    (sleep-for 0.5)
    (donothing))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf29a285" class="outline-2">
<h2 id="orgf29a285"><span class="section-number-2">7.</span> fog.h</h2>
<div class="outline-text-2" id="text-7">
<p>
Copied from tsoding's flag module: <a href="https://github.com/tsoding/flag.h">https://github.com/tsoding/flag.h</a>
Also tsoding's nob as build system:  <a href="https://github.com/tsoding/nob.h">https://github.com/tsoding/nob.h</a>
</p>
</div>
<div id="outline-container-orgc0778e1" class="outline-3">
<h3 id="orgc0778e1"><span class="section-number-3">7.1.</span> Quick Start</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Check <a href="../CPP/fog/example.c">example.c</a>
</p>

<div class="org-src-container">
<pre class="src src-sh">cc -o example example.c
./example -help
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc6dd579" class="outline-3">
<h3 id="orgc6dd579"><span class="section-number-3">7.2.</span> "Just rewrite shit in C, Just rewrite shit in C " &#x2014; tsoding</h3>
<div class="outline-text-3" id="text-7-2">
<p>
the editor/os/term of mine all just written in c.
</p>

<p class="verse">
you can replace the 1995's hype langs with:<br />
rust -&gt; fin-c.h<br />
go -&gt; threads.h<br />
python -&gt; dll<br />
zig -&gt; nob.h<br />
c++ -&gt; C with class<br />
web -&gt; C compile to webassembly<br />
do leetcode -&gt; C with stl<br />
do github -&gt; check tsoding<br />
do emacs -&gt; C + elisp<br />
do linux -&gt; C with fake class<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org0451751" class="outline-2">
<h2 id="org0451751"><span class="section-number-2">8.</span> 不用AI完成Leetcode刷题</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>开始时间： <del>2025-11-20</del>  2025年12月</li>
<li>结束时间： <del>2025-12月前</del> 2026年前</li>
<li>完成难度：difficult，对于懒癌而言:“impossible”</li>
<li>需要小时：100000000000000+</li>
<li>本章要点：关在家里，把力扣算法题热题都刷完一遍…</li>
</ul>

<p>
不用AI完成Leetcode刷题是一件很爽的事，虽然产生的经济效应为零，虽然永远写代码写不过AI，但是… 人类还需要人类? 不知资本家怎么想，但有搜索引擎了，就不用背书了吗，有炒菜机和机车就不用做菜和走路了吗? 得之心而应于手，理解一件事情本身有它的价值，虽然我更想去种田/木工/画画/乐器/写作，但… 我得先有工作啊~
</p>
<div class="org-src-container">
<pre class="src src-elisp">(global-set-key (kbd "M-*") (lambda () (interactive) (my/leetcode-open (string-to-number(current-word)))))
;; 谁tm知道到底我是折腾emacs节约时间还是浪费时间，不过有这个玩意，玩emacs总感觉还是挺值了。
</pre>
</div>

<p>
<b>根据力扣刷题指南上所提到的题目，收集了175题，一题40分钟，大约需要116小时完成</b>
</p>
<ul class="org-ul">
<li>最易懂的贪心算法1
例子: 455 135 435
真题: 605 452 763 122 406 665</li>
<li>玩转双指针2
例子: 167 88 76 142
真题: 633 680 340</li>
<li>居合斩！二分查找3
例子: 69 34 162 81
真题: 154 540 4</li>
<li>千奇百怪的排序算法4
例子: 215 347
真题: 451 75</li>
<li>一切皆可搜索5
例子: 695 547 417 46 77 79 51 1091 934 126
真题: 130 257 47 40 37 310</li>
<li>深入浅出动态规划6
例子: 70 198 413 64 542 221 279 91 139 1105 377 300 1143 416 474 322 72 650 121 188 309
真题: 213 53 343 583 646 10 376 494 714</li>
<li>化繁为简的分治法7
例子: 241
真题: 932 312 168 67 238 462 169 470 202</li>
<li>神奇的位运算9
例子: 461 190 136 318 338
真题: 268 693 476 260</li>
<li>妙用数据结构10
例子: 448 48 240 769 232 155 20 739 23 218 239 1 128 149 332 303 304
真题: 566 225 503 217 697 594 15 287 313 870 307</li>
<li>令人头大的字符串11
例子: 242 205 647 696 1249 227 28
真题: 409 3 772 5 83 328 19 148</li>
<li>指针三剑客之二：树13
例子: 104 110 543 437 101 1110 637 105 144 99 669 208
真题: 226 617 572 404 513 538 235 530 1530 889 106 94 145 236 109 897 653 450</li>
<li>指针三剑客之三：图14
例子: 785 210
真题: 1059 1135 882</li>
<li>更加复杂的数据结构15
例子: 684 146 380
真题: 1135 432 716</li>
</ul>
</div>
<div id="outline-container-orga494768" class="outline-3">
<h3 id="orga494768"><span class="section-number-3">8.1.</span> 吃饭/做题/睡觉，论计算机技术革命及其后果</h3>
<div class="outline-text-3" id="text-8-1">
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-two-sumlink-easy" class="outline-3">
<h3 id="two-sumlink-easy"><span class="section-number-3">8.2.</span> <a href="https://leetcode.com/problems/two-sum/">1. Two Sum</a> (Easy)</h3>
<div class="outline-text-3" id="text-two-sumlink-easy">
<p>
Given an array of integers <code>nums</code> and an integer <code>target</code>, return indices of the two numbers such that they add up to <code>target</code>.
</p>

<p>
You may assume that each input would have <b>exactly one solution</b>, and you may not use the same element twice.
</p>

<p>
You can return the answer in any order.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org9c3405c">
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgea55484">
Input: nums = [3,2,4], target = 6
Output: [1,2]
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orga9e460c">
Input: nums = [3,3], target = 6
Output: [0,1]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>2 &lt;</code> nums.length &lt;= 10⁴=</li>
<li><code>-10⁹ &lt;</code> nums[i] &lt;= 10⁹=</li>
<li><code>-10⁹ &lt;</code> target &lt;= 10⁹=</li>
<li><b>Only one valid answer exists.</b></li>
</ul>

<p>
<b>Follow-up:</b> Can you come up with an algorithm that is less than <code>O(n²)</code> time complexity?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/two-sum/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;int&gt; res;
        unordered_map&lt;int, int&gt; ht;
        for (int i = 0; i &lt; nums.size(); i++) {
            int other = target - nums[i];
            if (ht.count(other)) {
                /* Only one solution for purpose of this problem */
                res.append(ht[other]);
                res.append(i);
                return res;
            }
            ht[nums[i]] = i;
        }
        return res;
    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);
    int target;
    LeetCodeIO::scan(cin, target);

    Solution *obj = new Solution();
    auto res = obj-&gt;twoSum(nums, target);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-longest-substring-without-repeating-characterslink-medium" class="outline-3">
<h3 id="longest-substring-without-repeating-characterslink-medium"><span class="section-number-3">8.3.</span> <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">3. Longest Substring Without Repeating Characters</a> (Medium)</h3>
<div class="outline-text-3" id="text-longest-substring-without-repeating-characterslink-medium">
<p>
Given a string <code>s</code>, find the length of the <b>longest</b> <b>substring</b> without duplicate characters.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orga8af572">
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3. Note that "bca" and "cab" are also correct
answers.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org956e377">
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orge78c147">
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>0 &lt;</code> s.length &lt;= 5 * 10⁴=</li>
<li><code>s</code> consists of English letters, digits, symbols and spaces.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/longest-substring-without-repeating-characters/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector&lt;int&gt; count(256);
        long unsigned  int len = 0;
        long unsigned int i, j;

        for (i = 0, j = 0; i &lt; s.length(); i++) {
            count[s[i]]++;
            while (count[s[i]] &gt; 1) {
                len = i - j &gt; len ? i - j : len;
                count[s[j++]] -= 1;
            }
        }

        return i - j &gt; len ? i - j : len;
    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string s;
    LeetCodeIO::scan(cin, s);

    Solution *obj = new Solution();
    auto res = obj-&gt;lengthOfLongestSubstring(s);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-median-of-two-sorted-arrayslink-hard" class="outline-3">
<h3 id="median-of-two-sorted-arrayslink-hard"><span class="section-number-3">8.4.</span> <a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">4. Median of Two Sorted Arrays</a> (Hard)</h3>
<div class="outline-text-3" id="text-median-of-two-sorted-arrayslink-hard">
<p>
Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return <b>the median</b> of the two sorted arrays.
</p>

<p>
The overall run time complexity should be <code>O(log (m+n))</code>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org965d3f7">
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org56d0e7a">
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>nums1.length =</code> m=</li>
<li><code>nums2.length =</code> n=</li>
<li><code>0 &lt;</code> m &lt;= 1000=</li>
<li><code>0 &lt;</code> n &lt;= 1000=</li>
<li><code>1 &lt;</code> m + n &lt;= 2000=</li>
<li><code>-10⁶ &lt;</code> nums1[i], nums2[i] &lt;= 10⁶=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/median-of-two-sorted-arrays/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums1;
    LeetCodeIO::scan(cin, nums1);
    vector&lt;int&gt; nums2;
    LeetCodeIO::scan(cin, nums2);

    Solution *obj = new Solution();
    auto res = obj-&gt;findMedianSortedArrays(nums1, nums2);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-longest-palindromic-substringlink-medium" class="outline-3">
<h3 id="longest-palindromic-substringlink-medium"><span class="section-number-3">8.5.</span> <a href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring</a> (Medium)</h3>
<div class="outline-text-3" id="text-longest-palindromic-substringlink-medium">
<p>
Given a string <code>s</code>, return the longestpalindromicsubstring in <code>s</code>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org4bc87d3">
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org94d4d66">
Input: s = "cbbd"
Output: "bb"
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> s.length &lt;= 1000=</li>
<li><code>s</code> consist of only digits and English letters.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/longest-palindromic-substring/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    string longestPalindrome(string s) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string s;
    LeetCodeIO::scan(cin, s);

    Solution *obj = new Solution();
    auto res = obj-&gt;longestPalindrome(s);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-regular-expression-matchinglink-hard" class="outline-3">
<h3 id="regular-expression-matchinglink-hard"><span class="section-number-3">8.6.</span> <a href="https://leetcode.com/problems/regular-expression-matching/">10. Regular Expression Matching</a> (Hard)</h3>
<div class="outline-text-3" id="text-regular-expression-matchinglink-hard">
<p>
Given an input string <code>s</code> and a pattern <code>p</code>, implement regular expression matching with support for <code>'.'</code> and <code>'*'</code> where:
</p>

<ul class="org-ul">
<li><code>'.'</code> Matches any single character.</li>
<li><code>'*'</code> Matches zero or more of the preceding element.</li>
</ul>

<p>
The matching should cover the <b>entire</b> input string (not partial).
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orga895d0c">
Input: s = "aa", p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgf2789bd">
Input: s = "aa", p = "a*"
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once,
it becomes "aa".
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org71a5498">
Input: s = "ab", p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> s.length &lt;= 20=</li>
<li><code>1 &lt;</code> p.length &lt;= 20=</li>
<li><code>s</code> contains only lowercase English letters.</li>
<li><code>p</code> contains only lowercase English letters, <code>'.'</code>, and <code>'*'</code>.</li>
<li>It is guaranteed for each appearance of the character <code>'*'</code>, there will be a previous valid character to match.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/regular-expression-matching/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool isMatch(string s, string p) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string s;
    LeetCodeIO::scan(cin, s);
    string p;
    LeetCodeIO::scan(cin, p);

    Solution *obj = new Solution();
    auto res = obj-&gt;isMatch(s, p);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-sumlink-medium" class="outline-3">
<h3 id="sumlink-medium"><span class="section-number-3">8.7.</span> <a href="https://leetcode.com/problems/3sum/">15. 3Sum</a> (Medium)</h3>
<div class="outline-text-3" id="text-sumlink-medium">
<p>
Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i !</code> j=, <code>i !</code> k=, and <code>j !</code> k=, and <code>nums[i] + nums[j] + nums[k] =</code> 0=.
</p>

<p>
Notice that the solution set must not contain duplicate triplets.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org5128b2c">
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation:
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org1eae5c0">
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orgcc4c793">
Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>3 &lt;</code> nums.length &lt;= 3000=</li>
<li><code>-10⁵ &lt;</code> nums[i] &lt;= 10⁵=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/3sum/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;threeSum(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-remove-nth-node-from-end-of-listlink-medium" class="outline-3">
<h3 id="remove-nth-node-from-end-of-listlink-medium"><span class="section-number-3">8.8.</span> <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List</a> (Medium)</h3>
<div class="outline-text-3" id="text-remove-nth-node-from-end-of-listlink-medium">
<p>
Given the <code>head</code> of a linked list, remove the <code>nᵗʰ</code> node from the end of the list and return its head.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org4c6a0f1" class="figure">
<p><img src="../Leetcode/src/0019.remove-nth-node-from-end-of-list/remove_ex1.jpg" alt="remove_ex1.jpg" />
</p>
</div>

<pre class="example" id="org464120d">
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orge018671">
Input: head = [1], n = 1
Output: []
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org607adf2">
Input: head = [1,2], n = 1
Output: [1]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the list is <code>sz</code>.</li>
<li><code>1 &lt;</code> sz &lt;= 30=</li>
<li><code>0 &lt;</code> Node.val &lt;= 100=</li>
<li><code>1 &lt;</code> n &lt;= sz=</li>
</ul>

<p>
<b>Follow up:</b> Could you do this in one pass?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/remove-nth-node-from-end-of-list/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    ListNode* head;
    LeetCodeIO::scan(cin, head);
    int n;
    LeetCodeIO::scan(cin, n);

    Solution *obj = new Solution();
    auto res = obj-&gt;removeNthFromEnd(head, n);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-valid-parentheseslink-easy" class="outline-3">
<h3 id="valid-parentheseslink-easy"><span class="section-number-3">8.9.</span> <a href="https://leetcode.com/problems/valid-parentheses/">20. Valid Parentheses</a> (Easy)</h3>
<div class="outline-text-3" id="text-valid-parentheseslink-easy">
<p>
Given a string <code>s</code> containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid.
</p>

<p>
An input string is valid if:
</p>

<ol class="org-ol">
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
<li>Every close bracket has a corresponding open bracket of the same type.</li>
</ol>

<p>
<b>Example 1:</b>
</p>

<p>
<b>Input:</b> s = "()"
</p>

<p>
<b>Output:</b> true
</p>

<p>
<b>Example 2:</b>
</p>

<p>
<b>Input:</b> s = "()[]{}"
</p>

<p>
<b>Output:</b> true
</p>

<p>
<b>Example 3:</b>
</p>

<p>
<b>Input:</b> s = "(]"
</p>

<p>
<b>Output:</b> false
</p>

<p>
<b>Example 4:</b>
</p>

<p>
<b>Input:</b> s = "([])"
</p>

<p>
<b>Output:</b> true
</p>

<p>
<b>Example 5:</b>
</p>

<p>
<b>Input:</b> s = "([)]"
</p>

<p>
<b>Output:</b> false
</p>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> s.length &lt;= 10⁴=</li>
<li><code>s</code> consists of parentheses only <code>'()[]{}'</code>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/valid-parentheses/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool isValid(string s) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string s;
    LeetCodeIO::scan(cin, s);

    Solution *obj = new Solution();
    auto res = obj-&gt;isValid(s);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-merge-k-sorted-listslink-hard" class="outline-3">
<h3 id="merge-k-sorted-listslink-hard"><span class="section-number-3">8.10.</span> <a href="https://leetcode.com/problems/merge-k-sorted-lists/">23. Merge k Sorted Lists</a> (Hard)</h3>
<div class="outline-text-3" id="text-merge-k-sorted-listslink-hard">
<p>
You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.
</p>

<p>
Merge all the linked-lists into one sorted linked-list and return it.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgd3430fe">
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted linked list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgb29a0a8">
Input: lists = []
Output: []
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orgafc62ca">
Input: lists = [[]]
Output: []
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>k =</code> lists.length=</li>
<li><code>0 &lt;</code> k &lt;= 10⁴=</li>
<li><code>0 &lt;</code> lists[i].length &lt;= 500=</li>
<li><code>-10⁴ &lt;</code> lists[i][j] &lt;= 10⁴=</li>
<li><code>lists[i]</code> is sorted in <b>ascending order</b>.</li>
<li>The sum of <code>lists[i].length</code> will not exceed <code>10⁴</code>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/merge-k-sorted-lists/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;ListNode*&gt; lists;
    LeetCodeIO::scan(cin, lists);

    Solution *obj = new Solution();
    auto res = obj-&gt;mergeKLists(lists);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-find-the-index-of-the-first-occurrence-in-a-stringlink-easy" class="outline-3">
<h3 id="find-the-index-of-the-first-occurrence-in-a-stringlink-easy"><span class="section-number-3">8.11.</span> <a href="https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. Find the Index of the First Occurrence in a String</a> (Easy)</h3>
<div class="outline-text-3" id="text-find-the-index-of-the-first-occurrence-in-a-stringlink-easy">
<p>
Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orga0136f3">
Input: haystack = "sadbutsad", needle = "sad"
Output: 0
Explanation: "sad" occurs at index 0 and 6.
The first occurrence is at index 0, so we return 0.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org248db28">
Input: haystack = "leetcode", needle = "leeto"
Output: -1
Explanation: "leeto" did not occur in "leetcode", so we return -1.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> haystack.length, needle.length &lt;= 10⁴=</li>
<li><code>haystack</code> and <code>needle</code> consist of only lowercase English characters.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int strStr(string haystack, string needle) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string haystack;
    LeetCodeIO::scan(cin, haystack);
    string needle;
    LeetCodeIO::scan(cin, needle);

    Solution *obj = new Solution();
    auto res = obj-&gt;strStr(haystack, needle);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-find-first-and-last-position-of-element-in-sorted-arraylink-medium" class="outline-3">
<h3 id="find-first-and-last-position-of-element-in-sorted-arraylink-medium"><span class="section-number-3">8.12.</span> <a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. Find First and Last Position of Element in Sorted Array</a> (Medium)</h3>
<div class="outline-text-3" id="text-find-first-and-last-position-of-element-in-sorted-arraylink-medium">
<p>
Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.
</p>

<p>
If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.
</p>

<p>
You must write an algorithm with <code>O(log n)</code> runtime complexity.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgb8956ba">
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org87da5e1">
Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org3745943">
Input: nums = [], target = 0
Output: [-1,-1]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>0 &lt;</code> nums.length &lt;= 10⁵=</li>
<li><code>-10⁹ &lt;</code> nums[i] &lt;= 10⁹=</li>
<li><code>nums</code> is a non-decreasing array.</li>
<li><code>-10⁹ &lt;</code> target &lt;= 10⁹=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);
    int target;
    LeetCodeIO::scan(cin, target);

    Solution *obj = new Solution();
    auto res = obj-&gt;searchRange(nums, target);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-sudoku-solverlink-hard" class="outline-3">
<h3 id="sudoku-solverlink-hard"><span class="section-number-3">8.13.</span> <a href="https://leetcode.com/problems/sudoku-solver/">37. Sudoku Solver</a> (Hard)</h3>
<div class="outline-text-3" id="text-sudoku-solverlink-hard">
<p>
Write a program to solve a Sudoku puzzle by filling the empty cells.
</p>

<p>
A sudoku solution must satisfy <b>all of the following rules</b>:
</p>

<ol class="org-ol">
<li>Each of the digits <code>1-9</code> must occur exactly once in each row.</li>
<li>Each of the digits <code>1-9</code> must occur exactly once in each column.</li>
<li>Each of the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid.</li>
</ol>

<p>
The <code>'.'</code> character indicates empty cells.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org262bb38" class="figure">
<p><img src="../Leetcode/src/0037.sudoku-solver/250px-Sudoku-by-%20L2G-20050714.svg.png" alt="250px-Sudoku-by-%20L2G-20050714.svg.png" />
</p>
</div>

<pre class="example" id="org518993d">
Input: board =
[["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
Output:
[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
Explanation: The input board is shown above and the only valid solution is shown below:
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>board.length =</code> 9=</li>
<li><code>board[i].length =</code> 9=</li>
<li><code>board[i][j]</code> is a digit or <code>'.'</code>.</li>
<li>It is <b>guaranteed</b> that the input board has only one solution.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/sudoku-solver/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;char&gt;&gt; board;
    LeetCodeIO::scan(cin, board);

    Solution *obj = new Solution();
    auto res = obj-&gt;solveSudoku(board);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-combination-sum-iilink-medium" class="outline-3">
<h3 id="combination-sum-iilink-medium"><span class="section-number-3">8.14.</span> <a href="https://leetcode.com/problems/combination-sum-ii/">40. Combination Sum II</a> (Medium)</h3>
<div class="outline-text-3" id="text-combination-sum-iilink-medium">
<p>
Given a collection of candidate numbers ( <code>candidates</code>) and a target number ( <code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sum to <code>target</code>.
</p>

<p>
Each number in <code>candidates</code> may only be used <b>once</b> in the combination.
</p>

<p>
<b>Note:</b> The solution set must not contain duplicate combinations.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org51f8260">
Input: candidates = [10,1,2,7,6,1,5], target = 8
Output:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgd50077c">
Input: candidates = [2,5,2,1,2], target = 5
Output:
[
[1,2,2],
[5]
]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> candidates.length &lt;= 100=</li>
<li><code>1 &lt;</code> candidates[i] &lt;= 50=</li>
<li><code>1 &lt;</code> target &lt;= 30=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/combination-sum-ii/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; candidates;
    LeetCodeIO::scan(cin, candidates);
    int target;
    LeetCodeIO::scan(cin, target);

    Solution *obj = new Solution();
    auto res = obj-&gt;combinationSum2(candidates, target);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-permutationslink-medium" class="outline-3">
<h3 id="permutationslink-medium"><span class="section-number-3">8.15.</span> <a href="https://leetcode.com/problems/permutations/">46. Permutations</a> (Medium)</h3>
<div class="outline-text-3" id="text-permutationslink-medium">
<p>
Given an array <code>nums</code> of distinct integers, return all the possible permutations. You can return the answer in <b>any order</b>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org0e775a7">
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org7080d72">
Input: nums = [0,1]
Output: [[0,1],[1,0]]
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orgef1d496">
Input: nums = [1]
Output: [[1]]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 6=</li>
<li><code>-10 &lt;</code> nums[i] &lt;= 10=</li>
<li>All the integers of <code>nums</code> are <b>unique</b>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/permutations/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;permute(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-permutations-iilink-medium" class="outline-3">
<h3 id="permutations-iilink-medium"><span class="section-number-3">8.16.</span> <a href="https://leetcode.com/problems/permutations-ii/">47. Permutations II</a> (Medium)</h3>
<div class="outline-text-3" id="text-permutations-iilink-medium">
<p>
Given a collection of numbers, <code>nums</code>, that might contain duplicates, return all possible unique permutations <b>in any order</b>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org512c8bb">
Input: nums = [1,1,2]
Output:
[[1,1,2],
 [1,2,1],
 [2,1,1]]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgd5912d2">
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 8=</li>
<li><code>-10 &lt;</code> nums[i] &lt;= 10=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/permutations-ii/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;permuteUnique(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-rotate-imagelink-medium" class="outline-3">
<h3 id="rotate-imagelink-medium"><span class="section-number-3">8.17.</span> <a href="https://leetcode.com/problems/rotate-image/">48. Rotate Image</a> (Medium)</h3>
<div class="outline-text-3" id="text-rotate-imagelink-medium">
<p>
You are given an <code>n x n</code> 2D <code>matrix</code> representing an image, rotate the image by <b>90</b> degrees (clockwise).
</p>

<p>
You have to rotate the image <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><b>in-place</b></a>, which means you have to modify the input 2D matrix directly. <b>DO NOT</b> allocate another 2D matrix and do the rotation.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orgc1b469d" class="figure">
<p><img src="../Leetcode/src/0048.rotate-image/mat1.jpg" alt="mat1.jpg" />
</p>
</div>

<pre class="example" id="org1fb0290">
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="orgfdc7c91" class="figure">
<p><img src="../Leetcode/src/0048.rotate-image/mat2.jpg" alt="mat2.jpg" />
</p>
</div>

<pre class="example" id="org152a6e8">
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>n =</code> matrix.length <code>= matrix[i].length</code></li>
<li><code>1 &lt;</code> n &lt;= 20=</li>
<li><code>-1000 &lt;</code> matrix[i][j] &lt;= 1000=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/rotate-image/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; matrix;
    LeetCodeIO::scan(cin, matrix);

    Solution *obj = new Solution();
    auto res = obj-&gt;rotate(matrix);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-n-queenslink-hard" class="outline-3">
<h3 id="n-queenslink-hard"><span class="section-number-3">8.18.</span> <a href="https://leetcode.com/problems/n-queens/">51. N-Queens</a> (Hard)</h3>
<div class="outline-text-3" id="text-n-queenslink-hard">
<p>
The <b>n-queens</b> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other.
</p>

<p>
Given an integer <code>n</code>, return all distinct solutions to the <b>n-queens puzzle</b>. You may return the answer in <b>any order</b>.
</p>

<p>
Each solution contains a distinct board configuration of the n-queens' placement, where <code>'Q'</code> and <code>'.'</code> both indicate a queen and an empty space, respectively.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org67790ed" class="figure">
<p><img src="../Leetcode/src/0051.n-queens/queens.jpg" alt="queens.jpg" />
</p>
</div>

<pre class="example" id="org7fdf803">
Input: n = 4
Output: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org2d5afe2">
Input: n = 1
Output: [["Q"]]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> n &lt;= 9=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/n-queens/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int n;
    LeetCodeIO::scan(cin, n);

    Solution *obj = new Solution();
    auto res = obj-&gt;solveNQueens(n);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-maximum-subarraylink-medium" class="outline-3">
<h3 id="maximum-subarraylink-medium"><span class="section-number-3">8.19.</span> <a href="https://leetcode.com/problems/maximum-subarray/">53. Maximum Subarray</a> (Medium)</h3>
<div class="outline-text-3" id="text-maximum-subarraylink-medium">
<p>
Given an integer array <code>nums</code>, find the subarray with the largest sum, and return its sum.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org34d9e39">
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: The subarray [4,-1,2,1] has the largest sum 6.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org0e67d31">
Input: nums = [1]
Output: 1
Explanation: The subarray [1] has the largest sum 1.
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org8805be5">
Input: nums = [5,4,-1,7,8]
Output: 23
Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 10⁵=</li>
<li><code>-10⁴ &lt;</code> nums[i] &lt;= 10⁴=</li>
</ul>

<p>
<b>Follow up:</b> If you have figured out the <code>O(n)</code> solution, try coding another solution using the <b>divide and conquer</b> approach, which is more subtle.
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/maximum-subarray/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;maxSubArray(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-minimum-path-sumlink-medium" class="outline-3">
<h3 id="minimum-path-sumlink-medium"><span class="section-number-3">8.20.</span> <a href="https://leetcode.com/problems/minimum-path-sum/">64. Minimum Path Sum</a> (Medium)</h3>
<div class="outline-text-3" id="text-minimum-path-sumlink-medium">
<p>
Given a <code>m x n</code> <code>grid</code> filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.
</p>

<p>
<b>Note:</b> You can only move either down or right at any point in time.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orgd8aef0f" class="figure">
<p><img src="../Leetcode/src/0064.minimum-path-sum/minpath.jpg" alt="minpath.jpg" />
</p>
</div>

<pre class="example" id="orgfbeffed">
Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgf4e5f27">
Input: grid = [[1,2,3],[4,5,6]]
Output: 12
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>m =</code> grid.length=</li>
<li><code>n =</code> grid[i].length=</li>
<li><code>1 &lt;</code> m, n &lt;= 200=</li>
<li><code>0 &lt;</code> grid[i][j] &lt;= 200=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/minimum-path-sum/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; grid;
    LeetCodeIO::scan(cin, grid);

    Solution *obj = new Solution();
    auto res = obj-&gt;minPathSum(grid);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-add-binarylink-easy" class="outline-3">
<h3 id="add-binarylink-easy"><span class="section-number-3">8.21.</span> <a href="https://leetcode.com/problems/add-binary/">67. Add Binary</a> (Easy)</h3>
<div class="outline-text-3" id="text-add-binarylink-easy">
<p>
Given two binary strings <code>a</code> and <code>b</code>, return their sum as a binary string.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org1a6c7c9">
Input: a = "11", b = "1"
Output: "100"
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgb6cfdbd">
Input: a = "1010", b = "1011"
Output: "10101"
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> a.length, b.length &lt;= 10⁴=</li>
<li><code>a</code> and <code>b</code> consist only of <code>'0'</code> or <code>'1'</code> characters.</li>
<li>Each string does not contain leading zeros except for the zero itself.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/add-binary/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    string addBinary(string a, string b) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string a;
    LeetCodeIO::scan(cin, a);
    string b;
    LeetCodeIO::scan(cin, b);

    Solution *obj = new Solution();
    auto res = obj-&gt;addBinary(a, b);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-sqrtxlink-easy" class="outline-3">
<h3 id="sqrtxlink-easy"><span class="section-number-3">8.22.</span> <a href="https://leetcode.com/problems/sqrtx/">69. Sqrt(x)</a> (Easy)</h3>
<div class="outline-text-3" id="text-sqrtxlink-easy">
<p>
Given a non-negative integer <code>x</code>, return the square root of <code>x</code> rounded down to the nearest integer. The returned integer should be <b>non-negative</b> as well.
</p>

<p>
You <b>must not use</b> any built-in exponent function or operator.
</p>

<ul class="org-ul">
<li>For example, do not use <code>pow(x, 0.5)</code> in c++ or <code>x ** 0.5</code> in python.</li>
</ul>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org99264e1">
Input: x = 4
Output: 2
Explanation: The square root of 4 is 2, so we return 2.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org689c0a4">
Input: x = 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer,
2 is returned.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>0 &lt;</code> x &lt;= 2³¹ - 1=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/sqrtx/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int mySqrt(int x) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int x;
    LeetCodeIO::scan(cin, x);

    Solution *obj = new Solution();
    auto res = obj-&gt;mySqrt(x);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-climbing-stairslink-easy" class="outline-3">
<h3 id="climbing-stairslink-easy"><span class="section-number-3">8.23.</span> <a href="https://leetcode.com/problems/climbing-stairs/">70. Climbing Stairs</a> (Easy)</h3>
<div class="outline-text-3" id="text-climbing-stairslink-easy">
<p>
You are climbing a staircase. It takes <code>n</code> steps to reach the top.
</p>

<p>
Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org90be685">
Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org70547bf">
Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> n &lt;= 45=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/climbing-stairs/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int climbStairs(int n) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int n;
    LeetCodeIO::scan(cin, n);

    Solution *obj = new Solution();
    auto res = obj-&gt;climbStairs(n);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-edit-distancelink-medium" class="outline-3">
<h3 id="edit-distancelink-medium"><span class="section-number-3">8.24.</span> <a href="https://leetcode.com/problems/edit-distance/">72. Edit Distance</a> (Medium)</h3>
<div class="outline-text-3" id="text-edit-distancelink-medium">
<p>
Given two strings <code>word1</code> and <code>word2</code>, return the minimum number of operations required to convert <code>word1</code> to <code>word2</code>.
</p>

<p>
You have the following three operations permitted on a word:
</p>

<ul class="org-ul">
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ul>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org2b9e316">
Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation:
horse -&gt; rorse (replace 'h' with 'r')
rorse -&gt; rose (remove 'r')
rose -&gt; ros (remove 'e')
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orge6f0e9b">
Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation:
intention -&gt; inention (remove 't')
inention -&gt; enention (replace 'i' with 'e')
enention -&gt; exention (replace 'n' with 'x')
exention -&gt; exection (replace 'n' with 'c')
exection -&gt; execution (insert 'u')
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>0 &lt;</code> word1.length, word2.length &lt;= 500=</li>
<li><code>word1</code> and <code>word2</code> consist of lowercase English letters.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/edit-distance/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int minDistance(string word1, string word2) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string word1;
    LeetCodeIO::scan(cin, word1);
    string word2;
    LeetCodeIO::scan(cin, word2);

    Solution *obj = new Solution();
    auto res = obj-&gt;minDistance(word1, word2);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-sort-colorslink-medium" class="outline-3">
<h3 id="sort-colorslink-medium"><span class="section-number-3">8.25.</span> <a href="https://leetcode.com/problems/sort-colors/">75. Sort Colors</a> (Medium)</h3>
<div class="outline-text-3" id="text-sort-colorslink-medium">
<p>
Given an array <code>nums</code> with <code>n</code> objects colored red, white, or blue, sort them <b><a href="https://en.wikipedia.org/wiki/In-place_algorithm">in- place</a></b> so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
</p>

<p>
We will use the integers <code>0</code>, <code>1</code>, and <code>2</code> to represent the color red, white, and blue, respectively.
</p>

<p>
You must solve this problem without using the library's sort function.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org6d4642e">
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orge3486fb">
Input: nums = [2,0,1]
Output: [0,1,2]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>n =</code> nums.length=</li>
<li><code>1 &lt;</code> n &lt;= 300=</li>
<li><code>nums[i]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li>
</ul>

<p>
<b>Follow up:</b> Could you come up with a one-pass algorithm using only constant extra space?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/sort-colors/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    void sortColors(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;sortColors(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-minimum-window-substringlink-hard" class="outline-3">
<h3 id="minimum-window-substringlink-hard"><span class="section-number-3">8.26.</span> <a href="https://leetcode.com/problems/minimum-window-substring/">76. Minimum Window Substring</a> (Hard)</h3>
<div class="outline-text-3" id="text-minimum-window-substringlink-hard">
<p>
Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return the <b>minimum windowsubstring</b> of <code>s</code> such that every character in <code>t</code> ( <b>including duplicates</b>) is included in the window. If there is no such substring, return the empty string <code>""</code>.
</p>

<p>
The testcases will be generated such that the answer is <b>unique</b>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org219b351">
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgb5a6fdf">
Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orgf81cbcb">
Input: s = "a", t = "aa"
Output: ""
Explanation: Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>m =</code> s.length=</li>
<li><code>n =</code> t.length=</li>
<li><code>1 &lt;</code> m, n &lt;= 10⁵=</li>
<li><code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.</li>
</ul>

<p>
<b>Follow up:</b> Could you find an algorithm that runs in <code>O(m + n)</code> time?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/minimum-window-substring/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    string minWindow(string s, string t) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string s;
    LeetCodeIO::scan(cin, s);
    string t;
    LeetCodeIO::scan(cin, t);

    Solution *obj = new Solution();
    auto res = obj-&gt;minWindow(s, t);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-combinationslink-medium" class="outline-3">
<h3 id="combinationslink-medium"><span class="section-number-3">8.27.</span> <a href="https://leetcode.com/problems/combinations/">77. Combinations</a> (Medium)</h3>
<div class="outline-text-3" id="text-combinationslink-medium">
<p>
Given two integers <code>n</code> and <code>k</code>, return all possible combinations of <code>k=numbers chosen from the range =[1, n]</code>.
</p>

<p>
You may return the answer in <b>any order</b>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org14476ed">
Input: n = 4, k = 2
Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
Explanation: There are 4 choose 2 = 6 total combinations.
Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same
combination.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org7e21b33">
Input: n = 1, k = 1
Output: [[1]]
Explanation: There is 1 choose 1 = 1 total combination.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> n &lt;= 20=</li>
<li><code>1 &lt;</code> k &lt;= n=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/combinations/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int n;
    LeetCodeIO::scan(cin, n);
    int k;
    LeetCodeIO::scan(cin, k);

    Solution *obj = new Solution();
    auto res = obj-&gt;combine(n, k);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-word-searchlink-medium" class="outline-3">
<h3 id="word-searchlink-medium"><span class="section-number-3">8.28.</span> <a href="https://leetcode.com/problems/word-search/">79. Word Search</a> (Medium)</h3>
<div class="outline-text-3" id="text-word-searchlink-medium">
<p>
Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return =true=if =word=exists in the grid.
</p>

<p>
The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orgda5f4bf" class="figure">
<p><img src="../Leetcode/src/0079.word-search/word2.jpg" alt="word2.jpg" />
</p>
</div>

<pre class="example" id="org7c29428">
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
Output: true
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org744614c" class="figure">
<p><img src="../Leetcode/src/0079.word-search/word-1.jpg" alt="word-1.jpg" />
</p>
</div>

<pre class="example" id="org9375f22">
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
Output: true
</pre>

<p>
<b>Example 3:</b>
</p>


<div id="org191cc28" class="figure">
<p><img src="../Leetcode/src/0079.word-search/word3.jpg" alt="word3.jpg" />
</p>
</div>

<pre class="example" id="orgb1b9c94">
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
Output: false
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>m =</code> board.length=</li>
<li><code>n = board[i].length</code></li>
<li><code>1 &lt;</code> m, n &lt;= 6=</li>
<li><code>1 &lt;</code> word.length &lt;= 15=</li>
<li><code>board</code> and <code>word</code> consists of only lowercase and uppercase English letters.</li>
</ul>

<p>
<b>Follow up:</b> Could you use search pruning to make your solution faster with a larger <code>board</code>?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/word-search/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;char&gt;&gt; board;
    LeetCodeIO::scan(cin, board);
    string word;
    LeetCodeIO::scan(cin, word);

    Solution *obj = new Solution();
    auto res = obj-&gt;exist(board, word);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-search-in-rotated-sorted-array-iilink-medium" class="outline-3">
<h3 id="search-in-rotated-sorted-array-iilink-medium"><span class="section-number-3">8.29.</span> <a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/">81. Search in Rotated Sorted Array II</a> (Medium)</h3>
<div class="outline-text-3" id="text-search-in-rotated-sorted-array-iilink-medium">
<p>
There is an integer array <code>nums</code> sorted in non-decreasing order (not necessarily with <b>distinct</b> values).
</p>

<p>
Before being passed to your function, <code>nums</code> is <b>rotated</b> at an unknown pivot index <code>k</code> ( <code>0 &lt;</code> k &lt; nums.length=) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> ( <b>0-indexed</b>). For example, <code>[0,1,2,4,4,4,5,6,6,7]</code> might be rotated at pivot index <code>5</code> and become <code>[4,5,6,6,7,0,1,2,4,4]</code>.
</p>

<p>
Given the array <code>nums</code> <b>after</b> the rotation and an integer <code>target</code>, return <code>true</code> if <code>target</code> is in <code>nums</code>, or <code>false</code> if it is not in <code>nums</code>.
</p>

<p>
You must decrease the overall operation steps as much as possible.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orga1cac02">
Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org03e6f92">
Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 5000=</li>
<li><code>-10⁴ &lt;</code> nums[i] &lt;= 10⁴=</li>
<li><code>nums</code> is guaranteed to be rotated at some pivot.</li>
<li><code>-10⁴ &lt;</code> target &lt;= 10⁴=</li>
</ul>

<p>
<b>Follow up:</b> This problem is similar to <a href="file:///problems/search-in-rotated-%20sorted-array/description/">Search in Rotated Sorted Array</a>, but <code>nums</code> may contain <b>duplicates</b>. Would this affect the runtime complexity? How and why?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/search-in-rotated-sorted-array-ii/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool search(vector&lt;int&gt;&amp; nums, int target) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);
    int target;
    LeetCodeIO::scan(cin, target);

    Solution *obj = new Solution();
    auto res = obj-&gt;search(nums, target);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-remove-duplicates-from-sorted-listlink-easy" class="outline-3">
<h3 id="remove-duplicates-from-sorted-listlink-easy"><span class="section-number-3">8.30.</span> <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">83. Remove Duplicates from Sorted List</a> (Easy)</h3>
<div class="outline-text-3" id="text-remove-duplicates-from-sorted-listlink-easy">
<p>
Given the <code>head</code> of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list <b>sorted</b> as well.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orgdc22be8" class="figure">
<p><img src="../Leetcode/src/0083.remove-duplicates-from-sorted-list/list1.jpg" alt="list1.jpg" />
</p>
</div>

<pre class="example" id="org000ded7">
Input: head = [1,1,2]
Output: [1,2]
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org95ea747" class="figure">
<p><img src="../Leetcode/src/0083.remove-duplicates-from-sorted-list/list2.jpg" alt="list2.jpg" />
</p>
</div>

<pre class="example" id="orge0ff3e5">
Input: head = [1,1,2,3,3]
Output: [1,2,3]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the list is in the range <code>[0, 300]</code>.</li>
<li><code>-100 &lt;</code> Node.val &lt;= 100=</li>
<li>The list is guaranteed to be <b>sorted</b> in ascending order.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/remove-duplicates-from-sorted-list/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    ListNode* head;
    LeetCodeIO::scan(cin, head);

    Solution *obj = new Solution();
    auto res = obj-&gt;deleteDuplicates(head);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-merge-sorted-arraylink-easy" class="outline-3">
<h3 id="merge-sorted-arraylink-easy"><span class="section-number-3">8.31.</span> <a href="https://leetcode.com/problems/merge-sorted-array/">88. Merge Sorted Array</a> (Easy)</h3>
<div class="outline-text-3" id="text-merge-sorted-arraylink-easy">
<p>
You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in <b>non-decreasing order</b>, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.
</p>

<p>
<b>Merge</b> <code>nums1</code> and <code>nums2</code> into a single array sorted in <b>non-decreasing order</b>.
</p>

<p>
The final sorted array should not be returned by the function, but instead be stored inside the array <code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org7b24e8a">
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org1d91959">
Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Explanation: The arrays we are merging are [1] and [].
The result of the merge is [1].
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orgea55bf2">
Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
Explanation: The arrays we are merging are [] and [1].
The result of the merge is [1].
Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge
result can fit in nums1.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>nums1.length =</code> m + n=</li>
<li><code>nums2.length =</code> n=</li>
<li><code>0 &lt;</code> m, n &lt;= 200=</li>
<li><code>1 &lt;</code> m + n &lt;= 200=</li>
<li><code>-10⁹ &lt;</code> nums1[i], nums2[j] &lt;= 10⁹=</li>
</ul>

<p>
<b>Follow up:</b> Can you come up with an algorithm that runs in <code>O(m + n)</code> time?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/merge-sorted-array/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums1;
    LeetCodeIO::scan(cin, nums1);
    int m;
    LeetCodeIO::scan(cin, m);
    vector&lt;int&gt; nums2;
    LeetCodeIO::scan(cin, nums2);
    int n;
    LeetCodeIO::scan(cin, n);

    Solution *obj = new Solution();
    auto res = obj-&gt;merge(nums1, m, nums2, n);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-decode-wayslink-medium" class="outline-3">
<h3 id="decode-wayslink-medium"><span class="section-number-3">8.32.</span> <a href="https://leetcode.com/problems/decode-ways/">91. Decode Ways</a> (Medium)</h3>
<div class="outline-text-3" id="text-decode-wayslink-medium">
<p>
You have intercepted a secret message encoded as a string of numbers. The message is <b>decoded</b> via the following mapping:
</p>

<p>
<code>"1" -&gt; 'A' "2" -&gt; 'B' ... "25" -&gt; 'Y' "26" -&gt; 'Z'</code>
</p>

<p>
However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes ( <code>"2"</code> and <code>"5"</code> vs <code>"25"</code>).
</p>

<p>
For example, <code>"11106"</code> can be decoded into:
</p>

<ul class="org-ul">
<li><code>"AAJF"</code> with the grouping <code>(1, 1, 10, 6)</code></li>
<li><code>"KJF"</code> with the grouping <code>(11, 10, 6)</code></li>
<li>The grouping <code>(1, 11, 06)</code> is invalid because <code>"06"</code> is not a valid code (only <code>"6"</code> is valid).</li>
</ul>

<p>
Note: there may be strings that are impossible to decode.
</p>

<p>
Given a string s containing only digits, return the <b>number of ways</b> to <b>decode</b> it. If the entire string cannot be decoded in any valid way, return <code>0</code>.
</p>

<p>
The test cases are generated so that the answer fits in a <b>32-bit</b> integer.
</p>

<p>
<b>Example 1:</b>
</p>

<p>
<b>Input:</b> s = "12"
</p>

<p>
<b>Output:</b> 2
</p>

<p>
<b>Explanation:</b>
</p>

<p>
"12" could be decoded as "AB" (1 2) or "L" (12).
</p>

<p>
<b>Example 2:</b>
</p>

<p>
<b>Input:</b> s = "226"
</p>

<p>
<b>Output:</b> 3
</p>

<p>
<b>Explanation:</b>
</p>

<p>
"226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
</p>

<p>
<b>Example 3:</b>
</p>

<p>
<b>Input:</b> s = "06"
</p>

<p>
<b>Output:</b> 0
</p>

<p>
<b>Explanation:</b>
</p>

<p>
"06" cannot be mapped to "F" because of the leading zero ("6" is different from "06"). In this case, the string is not a valid encoding, so return 0.
</p>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> s.length &lt;= 100=</li>
<li><code>s</code> contains only digits and may contain leading zero(s).</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/decode-ways/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int numDecodings(string s) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string s;
    LeetCodeIO::scan(cin, s);

    Solution *obj = new Solution();
    auto res = obj-&gt;numDecodings(s);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-binary-tree-inorder-traversallink-easy" class="outline-3">
<h3 id="binary-tree-inorder-traversallink-easy"><span class="section-number-3">8.33.</span> <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">94. Binary Tree Inorder Traversal</a> (Easy)</h3>
<div class="outline-text-3" id="text-binary-tree-inorder-traversallink-easy">
<p>
Given the <code>root</code> of a binary tree, return the inorder traversal of its nodes' values.
</p>

<p>
<b>Example 1:</b>
</p>

<p>
<b>Input:</b> root = [1,null,2,3]
</p>

<p>
<b>Output:</b>[1,3,2]
</p>

<p>
<b>Explanation:</b>
</p>


<div id="orga7058d6" class="figure">
<p><img src="../Leetcode/src/0094.binary-tree-inorder-traversal/screenshot-2024-08-29-202743.png" alt="screenshot-2024-08-29-202743.png" />
</p>
</div>

<p>
<b>Example 2:</b>
</p>

<p>
<b>Input:</b> root = [1,2,3,4,5,null,8,null,null,6,7,9]
</p>

<p>
<b>Output:</b>[4,2,6,5,7,1,3,9,8]
</p>

<p>
<b>Explanation:</b>
</p>


<div id="org4ae4182" class="figure">
<p><img src="../Leetcode/src/0094.binary-tree-inorder-traversal/tree_2.png" alt="tree_2.png" />
</p>
</div>

<p>
<b>Example 3:</b>
</p>

<p>
<b>Input:</b> root = []
</p>

<p>
<b>Output:</b>[]
</p>

<p>
<b>Example 4:</b>
</p>

<p>
<b>Input:</b> root = [1]
</p>

<p>
<b>Output:</b>[1]
</p>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
<li><code>-100 &lt;</code> Node.val &lt;= 100=</li>
</ul>

<p>
<b>Follow up:</b> Recursive solution is trivial, could you do it iteratively?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/binary-tree-inorder-traversal/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);

    Solution *obj = new Solution();
    auto res = obj-&gt;inorderTraversal(root);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-recover-binary-search-treelink-medium" class="outline-3">
<h3 id="recover-binary-search-treelink-medium"><span class="section-number-3">8.34.</span> <a href="https://leetcode.com/problems/recover-binary-search-tree/">99. Recover Binary Search Tree</a> (Medium)</h3>
<div class="outline-text-3" id="text-recover-binary-search-treelink-medium">
<p>
You are given the <code>root</code> of a binary search tree (BST), where the values of <b>exactly</b> two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org94a7820" class="figure">
<p><img src="../Leetcode/src/0099.recover-binary-search-tree/recover1.jpg" alt="recover1.jpg" />
</p>
</div>

<pre class="example" id="org106f589">
Input: root = [1,3,null,null,2]
Output: [3,1,null,null,2]
Explanation: 3 cannot be a left child of 1 because 3 &gt; 1. Swapping 1 and 3 makes the BST valid.
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="orgde743d1" class="figure">
<p><img src="../Leetcode/src/0099.recover-binary-search-tree/recover2.jpg" alt="recover2.jpg" />
</p>
</div>

<pre class="example" id="org2f70de3">
Input: root = [3,1,4,null,null,2]
Output: [2,1,4,null,null,3]
Explanation: 2 cannot be in the right subtree of 3 because 2 &lt; 3. Swapping 2 and 3 makes the BST
valid.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[2, 1000]</code>.</li>
<li><code>-2³¹ &lt;</code> Node.val &lt;= 2³¹ - 1=</li>
</ul>

<p>
<b>Follow up:</b> A solution using <code>O(n)</code> space is pretty straight-forward. Could you devise a constant <code>O(1)</code> space solution?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/recover-binary-search-tree/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    void recoverTree(TreeNode* root) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);

    Solution *obj = new Solution();
    auto res = obj-&gt;recoverTree(root);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-symmetric-treelink-easy" class="outline-3">
<h3 id="symmetric-treelink-easy"><span class="section-number-3">8.35.</span> <a href="https://leetcode.com/problems/symmetric-tree/">101. Symmetric Tree</a> (Easy)</h3>
<div class="outline-text-3" id="text-symmetric-treelink-easy">
<p>
Given the <code>root</code> of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orgb61cb0e" class="figure">
<p><img src="../Leetcode/src/0101.symmetric-tree/symtree1.jpg" alt="symtree1.jpg" />
</p>
</div>

<pre class="example" id="org469cf8f">
Input: root = [1,2,2,3,4,4,3]
Output: true
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org73d5b55" class="figure">
<p><img src="../Leetcode/src/0101.symmetric-tree/symtree2.jpg" alt="symtree2.jpg" />
</p>
</div>

<pre class="example" id="orgd209641">
Input: root = [1,2,2,null,3,null,3]
Output: false
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
<li><code>-100 &lt;</code> Node.val &lt;= 100=</li>
</ul>

<p>
<b>Follow up:</b> Could you solve it both recursively and iteratively?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/symmetric-tree/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool isSymmetric(TreeNode* root) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);

    Solution *obj = new Solution();
    auto res = obj-&gt;isSymmetric(root);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-maximum-depth-of-binary-treelink-easy" class="outline-3">
<h3 id="maximum-depth-of-binary-treelink-easy"><span class="section-number-3">8.36.</span> <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a> (Easy)</h3>
<div class="outline-text-3" id="text-maximum-depth-of-binary-treelink-easy">
<p>
Given the <code>root</code> of a binary tree, return its maximum depth.
</p>

<p>
A binary tree's <b>maximum depth</b> is the number of nodes along the longest path from the root node down to the farthest leaf node.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org899711c" class="figure">
<p><img src="../Leetcode/src/0104.maximum-depth-of-binary-tree/tmp-tree.jpg" alt="tmp-tree.jpg" />
</p>
</div>

<pre class="example" id="orgf2693a9">
Input: root = [3,9,20,null,null,15,7]
Output: 3
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org4dcb58e">
Input: root = [1,null,2]
Output: 2
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[0, 10⁴]</code>.</li>
<li><code>-100 &lt;</code> Node.val &lt;= 100=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/maximum-depth-of-binary-tree/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int maxDepth(TreeNode* root) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);

    Solution *obj = new Solution();
    auto res = obj-&gt;maxDepth(root);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-construct-binary-tree-from-preorder-and-inorder-traversallink-medium" class="outline-3">
<h3 id="construct-binary-tree-from-preorder-and-inorder-traversallink-medium"><span class="section-number-3">8.37.</span> <a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. Construct Binary Tree from Preorder and Inorder Traversal</a> (Medium)</h3>
<div class="outline-text-3" id="text-construct-binary-tree-from-preorder-and-inorder-traversallink-medium">
<p>
Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return the binary tree.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org3133a83" class="figure">
<p><img src="../Leetcode/src/0105.construct-binary-tree-from-preorder-and-inorder-traversal/tree.jpg" alt="tree.jpg" />
</p>
</div>

<pre class="example" id="org24a7fcc">
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgc739f58">
Input: preorder = [-1], inorder = [-1]
Output: [-1]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> preorder.length &lt;= 3000=</li>
<li><code>inorder.length =</code> preorder.length=</li>
<li><code>-3000 &lt;</code> preorder[i], inorder[i] &lt;= 3000=</li>
<li><code>preorder</code> and <code>inorder</code> consist of <b>unique</b> values.</li>
<li>Each value of <code>inorder</code> also appears in <code>preorder</code>.</li>
<li><code>preorder</code> is <b>guaranteed</b> to be the preorder traversal of the tree.</li>
<li><code>inorder</code> is <b>guaranteed</b> to be the inorder traversal of the tree.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; preorder;
    LeetCodeIO::scan(cin, preorder);
    vector&lt;int&gt; inorder;
    LeetCodeIO::scan(cin, inorder);

    Solution *obj = new Solution();
    auto res = obj-&gt;buildTree(preorder, inorder);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-construct-binary-tree-from-inorder-and-postorder-traversallink-medium" class="outline-3">
<h3 id="construct-binary-tree-from-inorder-and-postorder-traversallink-medium"><span class="section-number-3">8.38.</span> <a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. Construct Binary Tree from Inorder and Postorder Traversal</a> (Medium)</h3>
<div class="outline-text-3" id="text-construct-binary-tree-from-inorder-and-postorder-traversallink-medium">
<p>
Given two integer arrays <code>inorder</code> and <code>postorder</code> where <code>inorder</code> is the inorder traversal of a binary tree and <code>postorder</code> is the postorder traversal of the same tree, construct and return the binary tree.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org6d48856" class="figure">
<p><img src="../Leetcode/src/0106.construct-binary-tree-from-inorder-and-postorder-traversal/tree.jpg" alt="tree.jpg" />
</p>
</div>

<pre class="example" id="org0e82230">
Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
Output: [3,9,20,null,null,15,7]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgc389510">
Input: inorder = [-1], postorder = [-1]
Output: [-1]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> inorder.length &lt;= 3000=</li>
<li><code>postorder.length =</code> inorder.length=</li>
<li><code>-3000 &lt;</code> inorder[i], postorder[i] &lt;= 3000=</li>
<li><code>inorder</code> and <code>postorder</code> consist of <b>unique</b> values.</li>
<li>Each value of <code>postorder</code> also appears in <code>inorder</code>.</li>
<li><code>inorder</code> is <b>guaranteed</b> to be the inorder traversal of the tree.</li>
<li><code>postorder</code> is <b>guaranteed</b> to be the postorder traversal of the tree.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; inorder;
    LeetCodeIO::scan(cin, inorder);
    vector&lt;int&gt; postorder;
    LeetCodeIO::scan(cin, postorder);

    Solution *obj = new Solution();
    auto res = obj-&gt;buildTree(inorder, postorder);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-convert-sorted-list-to-binary-search-treelink-medium" class="outline-3">
<h3 id="convert-sorted-list-to-binary-search-treelink-medium"><span class="section-number-3">8.39.</span> <a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">109. Convert Sorted List to Binary Search Tree</a> (Medium)</h3>
<div class="outline-text-3" id="text-convert-sorted-list-to-binary-search-treelink-medium">
<p>
Given the <code>head</code> of a singly linked list where elements are sorted in <b>ascending order</b>, convert it to a *height-balanced*binary search tree.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org575ddb5" class="figure">
<p><img src="../Leetcode/src/0109.convert-sorted-list-to-binary-search-tree/linked.jpg" alt="linked.jpg" />
</p>
</div>

<pre class="example" id="org2c7834a">
Input: head = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced
BST.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgcb78b5d">
Input: head = []
Output: []
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in <code>head</code> is in the range <code>[0, 2 * 10⁴]</code>.</li>
<li><code>-10⁵ &lt;</code> Node.val &lt;= 10⁵=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    ListNode* head;
    LeetCodeIO::scan(cin, head);

    Solution *obj = new Solution();
    auto res = obj-&gt;sortedListToBST(head);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-balanced-binary-treelink-easy" class="outline-3">
<h3 id="balanced-binary-treelink-easy"><span class="section-number-3">8.40.</span> <a href="https://leetcode.com/problems/balanced-binary-tree/">110. Balanced Binary Tree</a> (Easy)</h3>
<div class="outline-text-3" id="text-balanced-binary-treelink-easy">
<p>
Given a binary tree, determine if it is <b>height-balanced</b>.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org6872e1f" class="figure">
<p><img src="../Leetcode/src/0110.balanced-binary-tree/balance_1.jpg" alt="balance_1.jpg" />
</p>
</div>

<pre class="example" id="org1eb536c">
Input: root = [3,9,20,null,null,15,7]
Output: true
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org98e1650" class="figure">
<p><img src="../Leetcode/src/0110.balanced-binary-tree/balance_2.jpg" alt="balance_2.jpg" />
</p>
</div>

<pre class="example" id="orgcae9ba1">
Input: root = [1,2,2,3,3,null,null,4,4]
Output: false
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org6c88da9">
Input: root = []
Output: true
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>
<li><code>-10⁴ &lt;</code> Node.val &lt;= 10⁴=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/balanced-binary-tree/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool isBalanced(TreeNode* root) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);

    Solution *obj = new Solution();
    auto res = obj-&gt;isBalanced(root);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-best-time-to-buy-and-sell-stocklink-easy" class="outline-3">
<h3 id="best-time-to-buy-and-sell-stocklink-easy"><span class="section-number-3">8.41.</span> <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">121. Best Time to Buy and Sell Stock</a> (Easy)</h3>
<div class="outline-text-3" id="text-best-time-to-buy-and-sell-stocklink-easy">
<p>
You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>iᵗʰ</code> day.
</p>

<p>
You want to maximize your profit by choosing a <b>single day</b> to buy one stock and choosing a <b>different day in the future</b> to sell that stock.
</p>

<p>
Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return <code>0</code>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org5692f74">
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org58841b8">
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> prices.length &lt;= 10⁵=</li>
<li><code>0 &lt;</code> prices[i] &lt;= 10⁴=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; prices;
    LeetCodeIO::scan(cin, prices);

    Solution *obj = new Solution();
    auto res = obj-&gt;maxProfit(prices);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-best-time-to-buy-and-sell-stock-iilink-medium" class="outline-3">
<h3 id="best-time-to-buy-and-sell-stock-iilink-medium"><span class="section-number-3">8.42.</span> <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II</a> (Medium)</h3>
<div class="outline-text-3" id="text-best-time-to-buy-and-sell-stock-iilink-medium">
<p>
You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>iᵗʰ</code> day.
</p>

<p>
On each day, you may decide to buy and/or sell the stock. You can only hold <b>at most one</b> share of the stock at any time. However, you can sell and buy the stock multiple times on the <b>same day</b>, ensuring you never hold more than one share of the stock.
</p>

<p>
Find and return the <b>maximum</b> profit you can achieve.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org8a9b9b3">
Input: prices = [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Total profit is 4 + 3 = 7.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgc9e066e">
Input: prices = [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
Total profit is 4.
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org4345ebd">
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the
maximum profit of 0.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> prices.length &lt;= 3 * 10⁴=</li>
<li><code>0 &lt;</code> prices[i] &lt;= 10⁴=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; prices;
    LeetCodeIO::scan(cin, prices);

    Solution *obj = new Solution();
    auto res = obj-&gt;maxProfit(prices);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-word-ladder-iilink-hard" class="outline-3">
<h3 id="word-ladder-iilink-hard"><span class="section-number-3">8.43.</span> <a href="https://leetcode.com/problems/word-ladder-ii/">126. Word Ladder II</a> (Hard)</h3>
<div class="outline-text-3" id="text-word-ladder-iilink-hard">
<p>
A <b>transformation sequence</b> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s₁ -&gt; s₂ -&gt; ... -&gt; sₖ</code> such that:
</p>

<ul class="org-ul">
<li>Every adjacent pair of words differs by a single letter.</li>
<li>Every <code>sᵢ</code> for <code>1 &lt;</code> i &lt;= k= is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>
<li><code>sₖ =</code> endWord=</li>
</ul>

<p>
Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return all the <b>shortest transformation sequences</b> from <code>beginWord=to =endWord</code>, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words <code>[beginWord, s₁, s₂, ..., sₖ]</code>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org6fa6527">
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
Output: [["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]
Explanation: There are 2 shortest transformation sequences:
"hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog"
"hit" -&gt; "hot" -&gt; "lot" -&gt; "log" -&gt; "cog"
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org33162f7">
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
Output: []
Explanation: The endWord "cog" is not in wordList, therefore there is no valid transformation
sequence.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> beginWord.length &lt;= 5=</li>
<li><code>endWord.length =</code> beginWord.length=</li>
<li><code>1 &lt;</code> wordList.length &lt;= 500=</li>
<li><code>wordList[i].length =</code> beginWord.length=</li>
<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>
<li><code>beginWord !</code> endWord=</li>
<li>All the words in <code>wordList</code> are <b>unique</b>.</li>
<li>The <b>sum</b> of all shortest transformation sequences does not exceed <code>10⁵</code>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/word-ladder-ii/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string beginWord;
    LeetCodeIO::scan(cin, beginWord);
    string endWord;
    LeetCodeIO::scan(cin, endWord);
    vector&lt;string&gt; wordList;
    LeetCodeIO::scan(cin, wordList);

    Solution *obj = new Solution();
    auto res = obj-&gt;findLadders(beginWord, endWord, wordList);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-longest-consecutive-sequencelink-medium" class="outline-3">
<h3 id="longest-consecutive-sequencelink-medium"><span class="section-number-3">8.44.</span> <a href="https://leetcode.com/problems/longest-consecutive-sequence/">128. Longest Consecutive Sequence</a> (Medium)</h3>
<div class="outline-text-3" id="text-longest-consecutive-sequencelink-medium">
<p>
Given an unsorted array of integers <code>nums</code>, return the length of the longest consecutive elements sequence.
</p>

<p>
You must write an algorithm that runs in <code>O(n)</code> time.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgdfb3a55">
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org18a03d6">
Input: nums = [0,3,7,2,5,8,4,6,0,1]
Output: 9
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orgdcd7354">
Input: nums = [1,0,1,2]
Output: 3
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>0 &lt;</code> nums.length &lt;= 10⁵=</li>
<li><code>-10⁹ &lt;</code> nums[i] &lt;= 10⁹=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/longest-consecutive-sequence/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int longestConsecutive(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;longestConsecutive(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-surrounded-regionslink-medium" class="outline-3">
<h3 id="surrounded-regionslink-medium"><span class="section-number-3">8.45.</span> <a href="https://leetcode.com/problems/surrounded-regions/">130. Surrounded Regions</a> (Medium)</h3>
<div class="outline-text-3" id="text-surrounded-regionslink-medium">
<p>
You are given an <code>m x n</code> matrix <code>board</code> containing <b>letters</b> <code>'X'</code> and <code>'O'</code>, <b>capture regions</b> that are <b>surrounded</b>:
</p>

<ul class="org-ul">
<li><b>Connect</b>: A cell is connected to adjacent cells horizontally or vertically.</li>
<li><b>Region</b>: To form a region <b>connect every</b> <code>'O'</code> cell.</li>
<li><b>Surround</b>: The region is surrounded with <code>'X'</code> cells if you can <b>connect the region</b> with <code>'X'</code> cells and none of the region cells are on the edge of the <code>board</code>.</li>
</ul>

<p>
To capture a <b>surrounded region</b>, replace all <code>'O'</code> s with <code>'X'</code> s <b>in-place</b> within the original board. You do not need to return anything.
</p>

<p>
<b>Example 1:</b>
</p>

<p>
<b>Input:</b> board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
</p>

<p>
<b>Output:</b>[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
</p>

<p>
<b>Explanation:</b>
</p>


<div id="orge3ddcb9" class="figure">
<p><img src="../Leetcode/src/0130.surrounded-regions/xogrid.jpg" alt="xogrid.jpg" />
</p>
</div>

<p>
In the above diagram, the bottom region is not captured because it is on the edge of the board and cannot be surrounded.
</p>

<p>
<b>Example 2:</b>
</p>

<p>
<b>Input:</b> board = 
</p>

<p>
<b>Output:</b>
</p>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>m =</code> board.length=</li>
<li><code>n =</code> board[i].length=</li>
<li><code>1 &lt;</code> m, n &lt;= 200=</li>
<li><code>board[i][j]</code> is <code>'X'</code> or <code>'O'</code>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/surrounded-regions/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;char&gt;&gt; board;
    LeetCodeIO::scan(cin, board);

    Solution *obj = new Solution();
    auto res = obj-&gt;solve(board);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-candylink-hard" class="outline-3">
<h3 id="candylink-hard"><span class="section-number-3">8.46.</span> <a href="https://leetcode.com/problems/candy/">135. Candy</a> (Hard)</h3>
<div class="outline-text-3" id="text-candylink-hard">
<p>
There are <code>n</code> children standing in a line. Each child is assigned a rating value given in the integer array <code>ratings</code>.
</p>

<p>
You are giving candies to these children subjected to the following requirements:
</p>

<ul class="org-ul">
<li>Each child must have at least one candy.</li>
<li>Children with a higher rating get more candies than their neighbors.</li>
</ul>

<p>
Return the minimum number of candies you need to have to distribute the candies to the children.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgc8e50cd">
Input: ratings = [1,0,2]
Output: 5
Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies
respectively.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org7c278eb">
Input: ratings = [1,2,2]
Output: 4
Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies
respectively.
The third child gets 1 candy because it satisfies the above two conditions.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>n =</code> ratings.length=</li>
<li><code>1 &lt;</code> n &lt;= 2 * 10⁴=</li>
<li><code>0 &lt;</code> ratings[i] &lt;= 2 * 10⁴=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/candy/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int candy(vector&lt;int&gt;&amp; ratings) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; ratings;
    LeetCodeIO::scan(cin, ratings);

    Solution *obj = new Solution();
    auto res = obj-&gt;candy(ratings);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-single-numberlink-easy" class="outline-3">
<h3 id="single-numberlink-easy"><span class="section-number-3">8.47.</span> <a href="https://leetcode.com/problems/single-number/">136. Single Number</a> (Easy)</h3>
<div class="outline-text-3" id="text-single-numberlink-easy">
<p>
Given a <b>non-empty</b> array of integers <code>nums</code>, every element appears twice except for one. Find that single one.
</p>

<p>
You must implement a solution with a linear runtime complexity and use only constant extra space.
</p>

<p>
<b>Example 1:</b>
</p>

<p>
<b>Input:</b> nums = [2,2,1]
</p>

<p>
<b>Output:</b> 1
</p>

<p>
<b>Example 2:</b>
</p>

<p>
<b>Input:</b> nums = [4,1,2,1,2]
</p>

<p>
<b>Output:</b> 4
</p>

<p>
<b>Example 3:</b>
</p>

<p>
<b>Input:</b> nums = [1]
</p>

<p>
<b>Output:</b> 1
</p>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 3 * 10⁴=</li>
<li><code>-3 * 10⁴ &lt;</code> nums[i] &lt;= 3 * 10⁴=</li>
<li>Each element in the array appears twice except for one element which appears only once.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/single-number/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;singleNumber(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-word-breaklink-medium" class="outline-3">
<h3 id="word-breaklink-medium"><span class="section-number-3">8.48.</span> <a href="https://leetcode.com/problems/word-break/">139. Word Break</a> (Medium)</h3>
<div class="outline-text-3" id="text-word-breaklink-medium">
<p>
Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.
</p>

<p>
<b>Note</b> that the same word in the dictionary may be reused multiple times in the segmentation.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org623edc1">
Input: s = "leetcode", wordDict = ["leet","code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orge255d68">
Input: s = "applepenapple", wordDict = ["apple","pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
Note that you are allowed to reuse a dictionary word.
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orge0c8e71">
Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: false
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> s.length &lt;= 300=</li>
<li><code>1 &lt;</code> wordDict.length &lt;= 1000=</li>
<li><code>1 &lt;</code> wordDict[i].length &lt;= 20=</li>
<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>
<li>All the strings of <code>wordDict</code> are <b>unique</b>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/word-break/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string s;
    LeetCodeIO::scan(cin, s);
    vector&lt;string&gt; wordDict;
    LeetCodeIO::scan(cin, wordDict);

    Solution *obj = new Solution();
    auto res = obj-&gt;wordBreak(s, wordDict);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-linked-list-cycle-iilink-medium" class="outline-3">
<h3 id="linked-list-cycle-iilink-medium"><span class="section-number-3">8.49.</span> <a href="https://leetcode.com/problems/linked-list-cycle-ii/">142. Linked List Cycle II</a> (Medium)</h3>
<div class="outline-text-3" id="text-linked-list-cycle-iilink-medium">
<p>
Given the <code>head</code> of a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.
</p>

<p>
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail's <code>next</code> pointer is connected to ( <b>0-indexed</b>). It is <code>-1</code> if there is no cycle. <b>Note that</b> <code>pos</code> <b>is not passed as a parameter</b>.
</p>

<p>
<b>Do not modify</b> the linked list.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orged4d42a" class="figure">
<p><img src="../Leetcode/src/0142.linked-list-cycle-ii/circularlinkedlist.png" alt="circularlinkedlist.png" />
</p>
</div>

<pre class="example" id="org08081f6">
Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the second node.
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org93a29b7" class="figure">
<p><img src="../Leetcode/src/0142.linked-list-cycle-ii/circularlinkedlist_test2.png" alt="circularlinkedlist_test2.png" />
</p>
</div>

<pre class="example" id="org0f45429">
Input: head = [1,2], pos = 0
Output: tail connects to node index 0
Explanation: There is a cycle in the linked list, where tail connects to the first node.
</pre>

<p>
<b>Example 3:</b>
</p>


<div id="org9101e6b" class="figure">
<p><img src="../Leetcode/src/0142.linked-list-cycle-ii/circularlinkedlist_test3.png" alt="circularlinkedlist_test3.png" />
</p>
</div>

<pre class="example" id="org00adccb">
Input: head = [1], pos = -1
Output: no cycle
Explanation: There is no cycle in the linked list.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of the nodes in the list is in the range <code>[0, 10⁴]</code>.</li>
<li><code>-10⁵ &lt;</code> Node.val &lt;= 10⁵=</li>
<li><code>pos</code> is <code>-1</code> or a <b>valid index</b> in the linked-list.</li>
</ul>

<p>
<b>Follow up:</b> Can you solve it using <code>O(1)</code> (i.e. constant) memory?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/linked-list-cycle-ii/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    ListNode *detectCycle(ListNode *head) {

    }
};

// @lc code=end

// Warning: this is a manual question, the generated test code may be incorrect.
int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    ListNode* head;
    LeetCodeIO::scan(cin, head);
    int pos;
    LeetCodeIO::scan(cin, pos);

    Solution *obj = new Solution();
    auto res = obj-&gt;detectCycle(head, pos);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-binary-tree-preorder-traversallink-easy" class="outline-3">
<h3 id="binary-tree-preorder-traversallink-easy"><span class="section-number-3">8.50.</span> <a href="https://leetcode.com/problems/binary-tree-preorder-traversal/">144. Binary Tree Preorder Traversal</a> (Easy)</h3>
<div class="outline-text-3" id="text-binary-tree-preorder-traversallink-easy">
<p>
Given the <code>root</code> of a binary tree, return the preorder traversal of its nodes' values.
</p>

<p>
<b>Example 1:</b>
</p>

<p>
<b>Input:</b> root = [1,null,2,3]
</p>

<p>
<b>Output:</b>[1,2,3]
</p>

<p>
<b>Explanation:</b>
</p>


<div id="orga290b2b" class="figure">
<p><img src="../Leetcode/src/0144.binary-tree-preorder-traversal/screenshot-2024-08-29-202743.png" alt="screenshot-2024-08-29-202743.png" />
</p>
</div>

<p>
<b>Example 2:</b>
</p>

<p>
<b>Input:</b> root = [1,2,3,4,5,null,8,null,null,6,7,9]
</p>

<p>
<b>Output:</b>[1,2,4,5,6,7,3,8,9]
</p>

<p>
<b>Explanation:</b>
</p>


<div id="orgb847438" class="figure">
<p><img src="../Leetcode/src/0144.binary-tree-preorder-traversal/tree_2.png" alt="tree_2.png" />
</p>
</div>

<p>
<b>Example 3:</b>
</p>

<p>
<b>Input:</b> root = []
</p>

<p>
<b>Output:</b>[]
</p>

<p>
<b>Example 4:</b>
</p>

<p>
<b>Input:</b> root = [1]
</p>

<p>
<b>Output:</b>[1]
</p>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
<li><code>-100 &lt;</code> Node.val &lt;= 100=</li>
</ul>

<p>
<b>Follow up:</b> Recursive solution is trivial, could you do it iteratively?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/binary-tree-preorder-traversal/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);

    Solution *obj = new Solution();
    auto res = obj-&gt;preorderTraversal(root);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-binary-tree-postorder-traversallink-easy" class="outline-3">
<h3 id="binary-tree-postorder-traversallink-easy"><span class="section-number-3">8.51.</span> <a href="https://leetcode.com/problems/binary-tree-postorder-traversal/">145. Binary Tree Postorder Traversal</a> (Easy)</h3>
<div class="outline-text-3" id="text-binary-tree-postorder-traversallink-easy">
<p>
Given the <code>root</code> of a binary tree, return the postorder traversal of its nodes' values.
</p>

<p>
<b>Example 1:</b>
</p>

<p>
<b>Input:</b> root = [1,null,2,3]
</p>

<p>
<b>Output:</b>[3,2,1]
</p>

<p>
<b>Explanation:</b>
</p>


<div id="org914c2ea" class="figure">
<p><img src="../Leetcode/src/0145.binary-tree-postorder-traversal/screenshot-2024-08-29-202743.png" alt="screenshot-2024-08-29-202743.png" />
</p>
</div>

<p>
<b>Example 2:</b>
</p>

<p>
<b>Input:</b> root = [1,2,3,4,5,null,8,null,null,6,7,9]
</p>

<p>
<b>Output:</b>[4,6,7,5,2,9,8,3,1]
</p>

<p>
<b>Explanation:</b>
</p>


<div id="orgce48ec1" class="figure">
<p><img src="../Leetcode/src/0145.binary-tree-postorder-traversal/tree_2.png" alt="tree_2.png" />
</p>
</div>

<p>
<b>Example 3:</b>
</p>

<p>
<b>Input:</b> root = []
</p>

<p>
<b>Output:</b>[]
</p>

<p>
<b>Example 4:</b>
</p>

<p>
<b>Input:</b> root = [1]
</p>

<p>
<b>Output:</b>[1]
</p>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of the nodes in the tree is in the range <code>[0, 100]</code>.</li>
<li><code>-100 &lt;</code> Node.val &lt;= 100=</li>
</ul>

<p>
<b>Follow up:</b> Recursive solution is trivial, could you do it iteratively?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/binary-tree-postorder-traversal/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);

    Solution *obj = new Solution();
    auto res = obj-&gt;postorderTraversal(root);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-lru-cachelink-medium" class="outline-3">
<h3 id="lru-cachelink-medium"><span class="section-number-3">8.52.</span> <a href="https://leetcode.com/problems/lru-cache/">146. LRU Cache</a> (Medium)</h3>
<div class="outline-text-3" id="text-lru-cachelink-medium">
<p>
Design a data structure that follows the constraints of a <b><a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU">Least Recently Used (LRU) cache</a></b>.
</p>

<p>
Implement the <code>LRUCache</code> class:
</p>

<ul class="org-ul">
<li><code>LRUCache(int capacity)</code> Initialize the LRU cache with <b>positive</b> size <code>capacity</code>.</li>
<li><code>int get(int key)</code> Return the value of the <code>key</code> if the key exists, otherwise return <code>-1</code>.</li>
<li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if the <code>key</code> exists. Otherwise, add the <code>key-value</code> pair to the cache. If the number of keys exceeds the <code>capacity</code> from this operation, <b>evict</b> the least recently used key.</li>
</ul>

<p>
The functions <code>get</code> and <code>put</code> must each run in <code>O(1)</code> average time complexity.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgdfd5384">
Input
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, null, -1, 3, 4]

Explanation
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> capacity &lt;= 3000=</li>
<li><code>0 &lt;</code> key &lt;= 10⁴=</li>
<li><code>0 &lt;</code> value &lt;= 10⁵=</li>
<li>At most <code>2 * 10⁵</code> calls will be made to <code>get</code> and <code>put</code>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/lru-cache/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class LRUCache {
public:
    LRUCache(int capacity) {

    }

    int get(int key) {

    }

    void put(int key, int value) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;string&gt; method_names;
    LeetCodeIO::scan(cin, method_names);

    LRUCache *obj;
    const unordered_map&lt;string, function&lt;void()&gt;&gt; methods = {
        { "LRUCache", [&amp;]() {
            int capacity; LeetCodeIO::scan(cin, capacity); cin.ignore();
            obj = new LRUCache(capacity);
            out_stream &lt;&lt; "null,";
        } },
        { "get", [&amp;]() {
            int key; LeetCodeIO::scan(cin, key); cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;get(key)); out_stream &lt;&lt; ',';
        } },
        { "put", [&amp;]() {
            int key; LeetCodeIO::scan(cin, key); cin.ignore();
            int value; LeetCodeIO::scan(cin, value); cin.ignore();
            obj-&gt;put(key, value);
            out_stream &lt;&lt; "null,";
        } },
    };
    cin &gt;&gt; ws;
    out_stream &lt;&lt; '[';
    for (auto &amp;&amp;method_name : method_names) {
        cin.ignore(2);
        methods.at(method_name)();
    }
    cin.ignore();
    out_stream.seekp(-1, ios_base::end); out_stream &lt;&lt; ']';
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-sort-listlink-medium" class="outline-3">
<h3 id="sort-listlink-medium"><span class="section-number-3">8.53.</span> <a href="https://leetcode.com/problems/sort-list/">148. Sort List</a> (Medium)</h3>
<div class="outline-text-3" id="text-sort-listlink-medium">
<p>
Given the <code>head</code> of a linked list, return the list after sorting it in <b>ascending order</b>.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org78124f4" class="figure">
<p><img src="../Leetcode/src/0148.sort-list/sort_list_1.jpg" alt="sort_list_1.jpg" />
</p>
</div>

<pre class="example" id="orga0d2d0a">
Input: head = [4,2,1,3]
Output: [1,2,3,4]
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org5bafaff" class="figure">
<p><img src="../Leetcode/src/0148.sort-list/sort_list_2.jpg" alt="sort_list_2.jpg" />
</p>
</div>

<pre class="example" id="orgb08754b">
Input: head = [-1,5,3,4,0]
Output: [-1,0,3,4,5]
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orgde987ee">
Input: head = []
Output: []
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the list is in the range <code>[0, 5 * 10⁴]</code>.</li>
<li><code>-10⁵ &lt;</code> Node.val &lt;= 10⁵=</li>
</ul>

<p>
<b>Follow up:</b> Can you sort the linked list in <code>O(n logn)</code> time and <code>O(1)</code> memory (i.e. constant space)?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/sort-list/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    ListNode* sortList(ListNode* head) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    ListNode* head;
    LeetCodeIO::scan(cin, head);

    Solution *obj = new Solution();
    auto res = obj-&gt;sortList(head);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-max-points-on-a-linelink-hard" class="outline-3">
<h3 id="max-points-on-a-linelink-hard"><span class="section-number-3">8.54.</span> <a href="https://leetcode.com/problems/max-points-on-a-line/">149. Max Points on a Line</a> (Hard)</h3>
<div class="outline-text-3" id="text-max-points-on-a-linelink-hard">
<p>
Given an array of <code>points</code> where <code>points[i] = [xᵢ, yᵢ]</code> represents a point on the <b>X-Y</b> plane, return the maximum number of points that lie on the same straight line.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orga769f8c" class="figure">
<p><img src="../Leetcode/src/0149.max-points-on-a-line/plane1.jpg" alt="plane1.jpg" />
</p>
</div>

<pre class="example" id="org8086243">
Input: points = [[1,1],[2,2],[3,3]]
Output: 3
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org8dc826c" class="figure">
<p><img src="../Leetcode/src/0149.max-points-on-a-line/plane2.jpg" alt="plane2.jpg" />
</p>
</div>

<pre class="example" id="org9de2980">
Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
Output: 4
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> points.length &lt;= 300=</li>
<li><code>points[i].length =</code> 2=</li>
<li><code>-10⁴ &lt;</code> xᵢ, yᵢ &lt;= 10⁴=</li>
<li>All the <code>points</code> are <b>unique</b>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/max-points-on-a-line/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; points;
    LeetCodeIO::scan(cin, points);

    Solution *obj = new Solution();
    auto res = obj-&gt;maxPoints(points);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-find-minimum-in-rotated-sorted-array-iilink-hard" class="outline-3">
<h3 id="find-minimum-in-rotated-sorted-array-iilink-hard"><span class="section-number-3">8.55.</span> <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. Find Minimum in Rotated Sorted Array II</a> (Hard)</h3>
<div class="outline-text-3" id="text-find-minimum-in-rotated-sorted-array-iilink-hard">
<p>
Suppose an array of length <code>n</code> sorted in ascending order is <b>rotated</b> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,4,4,5,6,7]</code> might become:
</p>

<ul class="org-ul">
<li><code>[4,5,6,7,0,1,4]</code> if it was rotated <code>4</code> times.</li>
<li><code>[0,1,4,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>
</ul>

<p>
Notice that <b>rotating</b> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n- 1], a[0], a[1], a[2], ..., a[n-2]]</code>.
</p>

<p>
Given the sorted rotated array <code>nums</code> that may contain <b>duplicates</b>, return the minimum element of this array.
</p>

<p>
You must decrease the overall operation steps as much as possible.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgcca2f30">
Input: nums = [1,3,5]
Output: 1
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgbbd078d">
Input: nums = [2,2,2,0,1]
Output: 0
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>n =</code> nums.length=</li>
<li><code>1 &lt;</code> n &lt;= 5000=</li>
<li><code>-5000 &lt;</code> nums[i] &lt;= 5000=</li>
<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.</li>
</ul>

<p>
<b>Follow up:</b> This problem is similar to <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/">Find Minimum in Rotated Sorted Array</a>, but <code>nums</code> may contain <b>duplicates</b>. Would this affect the runtime complexity? How and why?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int findMin(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;findMin(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-min-stacklink-medium" class="outline-3">
<h3 id="min-stacklink-medium"><span class="section-number-3">8.56.</span> <a href="https://leetcode.com/problems/min-stack/">155. Min Stack</a> (Medium)</h3>
<div class="outline-text-3" id="text-min-stacklink-medium">
<p>
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
</p>

<p>
Implement the <code>MinStack</code> class:
</p>

<ul class="org-ul">
<li><code>MinStack()</code> initializes the stack object.</li>
<li><code>void push(int val)</code> pushes the element <code>val</code> onto the stack.</li>
<li><code>void pop()</code> removes the element on the top of the stack.</li>
<li><code>int top()</code> gets the top element of the stack.</li>
<li><code>int getMin()</code> retrieves the minimum element in the stack.</li>
</ul>

<p>
You must implement a solution with <code>O(1)</code> time complexity for each function.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgfb3cf38">
Input
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

Output
[null,null,null,null,-3,null,0,-2]

Explanation
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>-2³¹ &lt;</code> val &lt;= 2³¹ - 1=</li>
<li>Methods <code>pop</code>, <code>top</code> and <code>getMin</code> operations will always be called on <b>non-empty</b> stacks.</li>
<li>At most <code>3 * 10⁴</code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/min-stack/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class MinStack {
public:
    MinStack() {

    }

    void push(int val) {

    }

    void pop() {

    }

    int top() {

    }

    int getMin() {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;string&gt; method_names;
    LeetCodeIO::scan(cin, method_names);

    MinStack *obj;
    const unordered_map&lt;string, function&lt;void()&gt;&gt; methods = {
        { "MinStack", [&amp;]() {
            cin.ignore();
            obj = new MinStack();
            out_stream &lt;&lt; "null,";
        } },
        { "push", [&amp;]() {
            int val; LeetCodeIO::scan(cin, val); cin.ignore();
            obj-&gt;push(val);
            out_stream &lt;&lt; "null,";
        } },
        { "pop", [&amp;]() {
            cin.ignore();
            obj-&gt;pop();
            out_stream &lt;&lt; "null,";
        } },
        { "top", [&amp;]() {
            cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;top()); out_stream &lt;&lt; ',';
        } },
        { "getMin", [&amp;]() {
            cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;getMin()); out_stream &lt;&lt; ',';
        } },
    };
    cin &gt;&gt; ws;
    out_stream &lt;&lt; '[';
    for (auto &amp;&amp;method_name : method_names) {
        cin.ignore(2);
        methods.at(method_name)();
    }
    cin.ignore();
    out_stream.seekp(-1, ios_base::end); out_stream &lt;&lt; ']';
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-find-peak-elementlink-medium" class="outline-3">
<h3 id="find-peak-elementlink-medium"><span class="section-number-3">8.57.</span> <a href="https://leetcode.com/problems/find-peak-element/">162. Find Peak Element</a> (Medium)</h3>
<div class="outline-text-3" id="text-find-peak-elementlink-medium">
<p>
A peak element is an element that is strictly greater than its neighbors.
</p>

<p>
Given a <b>0-indexed</b> integer array <code>nums</code>, find a peak element, and return its index. If the array contains multiple peaks, return the index to <b>any of the peaks</b>.
</p>

<p>
You may imagine that <code>nums[-1] = nums[n] = -∞</code>. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.
</p>

<p>
You must write an algorithm that runs in <code>O(log n)</code> time.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orga223b1f">
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgb587e50">
Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index
number 5 where the peak element is 6.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 1000=</li>
<li><code>-2³¹ &lt;</code> nums[i] &lt;= 2³¹ - 1=</li>
<li><code>nums[i] !</code> nums[i + 1]= for all valid <code>i</code>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/find-peak-element/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int findPeakElement(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;findPeakElement(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-two-sum-ii---input-array-is-sortedlink-medium" class="outline-3">
<h3 id="two-sum-ii---input-array-is-sortedlink-medium"><span class="section-number-3">8.58.</span> <a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">167. Two Sum II - Input Array Is Sorted</a> (Medium)</h3>
<div class="outline-text-3" id="text-two-sum-ii---input-array-is-sortedlink-medium">
<p>
Given a <b>1-indexed</b> array of integers <code>numbers</code> that is already <b>sorted in non-decreasing order</b>, find two numbers such that they add up to a specific <code>target</code> number. Let these two numbers be <code>numbers[index₁]</code> and <code>numbers[index₂]</code> where <code>1 &lt;</code> index₁ &lt; index₂ &lt;= numbers.length=.
</p>

<p>
Return the indices of the two numbers, <code>index₁</code> and <code>index₂</code>, <b>added by one</b> as an integer array <code>[index₁, index₂]</code> of length 2.
</p>

<p>
The tests are generated such that there is <b>exactly one solution</b>. You <b>may not</b> use the same element twice.
</p>

<p>
Your solution must use only constant extra space.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgd332182">
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore, index₁ = 1, index₂ = 2. We return [1, 2].
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org093616a">
Input: numbers = [2,3,4], target = 6
Output: [1,3]
Explanation: The sum of 2 and 4 is 6. Therefore index₁ = 1, index₂ = 3. We return [1, 3].
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org040a502">
Input: numbers = [-1,0], target = -1
Output: [1,2]
Explanation: The sum of -1 and 0 is -1. Therefore index₁ = 1, index₂ = 2. We return [1, 2].
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>2 &lt;</code> numbers.length &lt;= 3 * 10⁴=</li>
<li><code>-1000 &lt;</code> numbers[i] &lt;= 1000=</li>
<li><code>numbers</code> is sorted in <b>non-decreasing order</b>.</li>
<li><code>-1000 &lt;</code> target &lt;= 1000=</li>
<li>The tests are generated such that there is <b>exactly one solution</b>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; numbers;
    LeetCodeIO::scan(cin, numbers);
    int target;
    LeetCodeIO::scan(cin, target);

    Solution *obj = new Solution();
    auto res = obj-&gt;twoSum(numbers, target);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-excel-sheet-column-titlelink-easy" class="outline-3">
<h3 id="excel-sheet-column-titlelink-easy"><span class="section-number-3">8.59.</span> <a href="https://leetcode.com/problems/excel-sheet-column-title/">168. Excel Sheet Column Title</a> (Easy)</h3>
<div class="outline-text-3" id="text-excel-sheet-column-titlelink-easy">
<p>
Given an integer <code>columnNumber</code>, return its corresponding column title as it appears in an Excel sheet.
</p>

<p>
For example:
</p>

<pre class="example" id="org2728529">
A -&gt; 1
B -&gt; 2
C -&gt; 3
...
Z -&gt; 26
AA -&gt; 27
AB -&gt; 28
...
</pre>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org79650bb">
Input: columnNumber = 1
Output: "A"
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org8c9f2d7">
Input: columnNumber = 28
Output: "AB"
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org18e319b">
Input: columnNumber = 701
Output: "ZY"
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> columnNumber &lt;= 2³¹ - 1=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/excel-sheet-column-title/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    string convertToTitle(int columnNumber) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int columnNumber;
    LeetCodeIO::scan(cin, columnNumber);

    Solution *obj = new Solution();
    auto res = obj-&gt;convertToTitle(columnNumber);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-majority-elementlink-easy" class="outline-3">
<h3 id="majority-elementlink-easy"><span class="section-number-3">8.60.</span> <a href="https://leetcode.com/problems/majority-element/">169. Majority Element</a> (Easy)</h3>
<div class="outline-text-3" id="text-majority-elementlink-easy">
<p>
Given an array <code>nums</code> of size <code>n</code>, return the majority element.
</p>

<p>
The majority element is the element that appears more than <code>⌊n / 2⌋</code> times. You may assume that the majority element always exists in the array.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgceddc02">
Input: nums = [3,2,3]
Output: 3
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orged9a202">
Input: nums = [2,2,1,1,1,2,2]
Output: 2
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>n =</code> nums.length=</li>
<li><code>1 &lt;</code> n &lt;= 5 * 10⁴=</li>
<li><code>-10⁹ &lt;</code> nums[i] &lt;= 10⁹=</li>
<li>The input is generated such that a majority element will exist in the array.</li>
</ul>

<p>
<b>Follow-up:</b> Could you solve the problem in linear time and in <code>O(1)</code> space?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/majority-element/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;majorityElement(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-best-time-to-buy-and-sell-stock-ivlink-hard" class="outline-3">
<h3 id="best-time-to-buy-and-sell-stock-ivlink-hard"><span class="section-number-3">8.61.</span> <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">188. Best Time to Buy and Sell Stock IV</a> (Hard)</h3>
<div class="outline-text-3" id="text-best-time-to-buy-and-sell-stock-ivlink-hard">
<p>
You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>iᵗʰ</code> day, and an integer <code>k</code>.
</p>

<p>
Find the maximum profit you can achieve. You may complete at most <code>k</code> transactions: i.e. you may buy at most <code>k</code> times and sell at most <code>k</code> times.
</p>

<p>
<b>Note:</b> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org27e0121">
Input: k = 2, prices = [2,4,1]
Output: 2
Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org44347d7">
Input: k = 2, prices = [3,2,6,5,0,3]
Output: 7
Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on
day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> k &lt;= 100=</li>
<li><code>1 &lt;</code> prices.length &lt;= 1000=</li>
<li><code>0 &lt;</code> prices[i] &lt;= 1000=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int maxProfit(int k, vector&lt;int&gt;&amp; prices) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int k;
    LeetCodeIO::scan(cin, k);
    vector&lt;int&gt; prices;
    LeetCodeIO::scan(cin, prices);

    Solution *obj = new Solution();
    auto res = obj-&gt;maxProfit(k, prices);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-reverse-bitslink-easy" class="outline-3">
<h3 id="reverse-bitslink-easy"><span class="section-number-3">8.62.</span> <a href="https://leetcode.com/problems/reverse-bits/">190. Reverse Bits</a> (Easy)</h3>
<div class="outline-text-3" id="text-reverse-bitslink-easy">
<p>
Reverse bits of a given 32 bits signed integer.
</p>

<p>
<b>Example 1:</b>
</p>

<p>
<b>Input:</b> n = 43261596
</p>

<p>
<b>Output:</b> 964176192
</p>

<p>
<b>Explanation:</b>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Integer</th>
<th scope="col" class="org-right">Binary</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">43261596</td>
<td class="org-right">00000010100101000001111010011100</td>
</tr>

<tr>
<td class="org-right">964176192</td>
<td class="org-right">00111001011110000010100101000000</td>
</tr>
</tbody>
</table>

<p>
<b>Example 2:</b>
</p>

<p>
<b>Input:</b> n = 2147483644
</p>

<p>
<b>Output:</b> 1073741822
</p>

<p>
<b>Explanation:</b>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Integer</th>
<th scope="col" class="org-right">Binary</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">2147483644</td>
<td class="org-right">01111111111111111111111111111100</td>
</tr>

<tr>
<td class="org-right">1073741822</td>
<td class="org-right">00111111111111111111111111111110</td>
</tr>
</tbody>
</table>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>0 &lt;</code> n &lt;= 2³¹ - 2=</li>
<li><code>n</code> is even.</li>
</ul>

<p>
<b>Follow up:</b> If this function is called many times, how would you optimize it?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/reverse-bits/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int reverseBits(int n) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int n;
    LeetCodeIO::scan(cin, n);

    Solution *obj = new Solution();
    auto res = obj-&gt;reverseBits(n);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-house-robberlink-medium" class="outline-3">
<h3 id="house-robberlink-medium"><span class="section-number-3">8.63.</span> <a href="https://leetcode.com/problems/house-robber/">198. House Robber</a> (Medium)</h3>
<div class="outline-text-3" id="text-house-robberlink-medium">
<p>
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.
</p>

<p>
Given an integer array <code>nums</code> representing the amount of money of each house, return the maximum amount of money you can rob tonight <b>without alerting the police</b>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgb2d1945">
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgc913eba">
Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 100=</li>
<li><code>0 &lt;</code> nums[i] &lt;= 400=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/house-robber/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;rob(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-happy-numberlink-easy" class="outline-3">
<h3 id="happy-numberlink-easy"><span class="section-number-3">8.64.</span> <a href="https://leetcode.com/problems/happy-number/">202. Happy Number</a> (Easy)</h3>
<div class="outline-text-3" id="text-happy-numberlink-easy">
<p>
Write an algorithm to determine if a number <code>n</code> is happy.
</p>

<p>
A <b>happy number</b> is a number defined by the following process:
</p>

<ul class="org-ul">
<li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li>
<li>Repeat the process until the number equals 1 (where it will stay), or it <b>loops endlessly in a cycle</b> which does not include 1.</li>
<li>Those numbers for which this process <b>ends in 1</b> are happy.</li>
</ul>

<p>
Return =true=if =n=is a happy number, and =false=if not.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org0b7e1f0">
Input: n = 19
Output: true
Explanation:
1² + 9² = 82
8² + 2² = 68
6² + 8² = 100
1² + 0² + 0² = 1
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgd7f77ab">
Input: n = 2
Output: false
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> n &lt;= 2³¹ - 1=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/happy-number/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool isHappy(int n) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int n;
    LeetCodeIO::scan(cin, n);

    Solution *obj = new Solution();
    auto res = obj-&gt;isHappy(n);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-isomorphic-stringslink-easy" class="outline-3">
<h3 id="isomorphic-stringslink-easy"><span class="section-number-3">8.65.</span> <a href="https://leetcode.com/problems/isomorphic-strings/">205. Isomorphic Strings</a> (Easy)</h3>
<div class="outline-text-3" id="text-isomorphic-stringslink-easy">
<p>
Given two strings <code>s</code> and <code>t</code>, determine if they are isomorphic.
</p>

<p>
Two strings <code>s</code> and <code>t</code> are isomorphic if the characters in <code>s</code> can be replaced to get <code>t</code>.
</p>

<p>
All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.
</p>

<p>
<b>Example 1:</b>
</p>

<p>
<b>Input:</b> s = "egg", t = "add"
</p>

<p>
<b>Output:</b> true
</p>

<p>
<b>Explanation:</b>
</p>

<p>
The strings <code>s</code> and <code>t</code> can be made identical by:
</p>

<ul class="org-ul">
<li>Mapping <code>'e'</code> to <code>'a'</code>.</li>
<li>Mapping <code>'g'</code> to <code>'d'</code>.</li>
</ul>

<p>
<b>Example 2:</b>
</p>

<p>
<b>Input:</b> s = "foo", t = "bar"
</p>

<p>
<b>Output:</b> false
</p>

<p>
<b>Explanation:</b>
</p>

<p>
The strings <code>s</code> and <code>t</code> can not be made identical as <code>'o'</code> needs to be mapped to both <code>'a'</code> and <code>'r'</code>.
</p>

<p>
<b>Example 3:</b>
</p>

<p>
<b>Input:</b> s = "paper", t = "title"
</p>

<p>
<b>Output:</b> true
</p>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> s.length &lt;= 5 * 10⁴=</li>
<li><code>t.length =</code> s.length=</li>
<li><code>s</code> and <code>t</code> consist of any valid ascii character.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/isomorphic-strings/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool isIsomorphic(string s, string t) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string s;
    LeetCodeIO::scan(cin, s);
    string t;
    LeetCodeIO::scan(cin, t);

    Solution *obj = new Solution();
    auto res = obj-&gt;isIsomorphic(s, t);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-implement-trie-prefix-treelink-medium" class="outline-3">
<h3 id="implement-trie-prefix-treelink-medium"><span class="section-number-3">8.66.</span> <a href="https://leetcode.com/problems/implement-trie-prefix-tree/">208. Implement Trie (Prefix Tree)</a> (Medium)</h3>
<div class="outline-text-3" id="text-implement-trie-prefix-treelink-medium">
<p>
A <a href="https://en.wikipedia.org/wiki/Trie"><b>trie</b></a> (pronounced as "try") or <b>prefix tree</b> is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.
</p>

<p>
Implement the Trie class:
</p>

<ul class="org-ul">
<li><code>Trie()</code> Initializes the trie object.</li>
<li><code>void insert(String word)</code> Inserts the string <code>word</code> into the trie.</li>
<li><code>boolean search(String word)</code> Returns <code>true</code> if the string <code>word</code> is in the trie (i.e., was inserted before), and <code>false</code> otherwise.</li>
<li><code>boolean startsWith(String prefix)</code> Returns <code>true</code> if there is a previously inserted string <code>word</code> that has the prefix <code>prefix</code>, and <code>false</code> otherwise.</li>
</ul>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgd31c7c3">
Input
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
Output
[null, null, true, false, true, null, true]

Explanation
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // return True
trie.search("app");     // return False
trie.startsWith("app"); // return True
trie.insert("app");
trie.search("app");     // return True
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> word.length, prefix.length &lt;= 2000=</li>
<li><code>word</code> and <code>prefix</code> consist only of lowercase English letters.</li>
<li>At most <code>3 * 10⁴</code> calls <b>in total</b> will be made to <code>insert</code>, <code>search</code>, and <code>startsWith</code>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/implement-trie-prefix-tree/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Trie {
public:
    Trie() {

    }

    void insert(string word) {

    }

    bool search(string word) {

    }

    bool startsWith(string prefix) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;string&gt; method_names;
    LeetCodeIO::scan(cin, method_names);

    Trie *obj;
    const unordered_map&lt;string, function&lt;void()&gt;&gt; methods = {
        { "Trie", [&amp;]() {
            cin.ignore();
            obj = new Trie();
            out_stream &lt;&lt; "null,";
        } },
        { "insert", [&amp;]() {
            string word; LeetCodeIO::scan(cin, word); cin.ignore();
            obj-&gt;insert(word);
            out_stream &lt;&lt; "null,";
        } },
        { "search", [&amp;]() {
            string word; LeetCodeIO::scan(cin, word); cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;search(word)); out_stream &lt;&lt; ',';
        } },
        { "startsWith", [&amp;]() {
            string prefix; LeetCodeIO::scan(cin, prefix); cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;startsWith(prefix)); out_stream &lt;&lt; ',';
        } },
    };
    cin &gt;&gt; ws;
    out_stream &lt;&lt; '[';
    for (auto &amp;&amp;method_name : method_names) {
        cin.ignore(2);
        methods.at(method_name)();
    }
    cin.ignore();
    out_stream.seekp(-1, ios_base::end); out_stream &lt;&lt; ']';
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-course-schedule-iilink-medium" class="outline-3">
<h3 id="course-schedule-iilink-medium"><span class="section-number-3">8.67.</span> <a href="https://leetcode.com/problems/course-schedule-ii/">210. Course Schedule II</a> (Medium)</h3>
<div class="outline-text-3" id="text-course-schedule-iilink-medium">
<p>
There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [aᵢ, bᵢ]</code> indicates that you <b>must</b> take course <code>bᵢ</code> first if you want to take course <code>aᵢ</code>.
</p>

<ul class="org-ul">
<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>
</ul>

<p>
Return the ordering of courses you should take to finish all courses. If there are many valid answers, return <b>any</b> of them. If it is impossible to finish all courses, return <b>an empty array</b>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org3ee653f">
Input: numCourses = 2, prerequisites = [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished
course 0. So the correct course order is [0,1].
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org097c844">
Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both
courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orga029dae">
Input: numCourses = 1, prerequisites = []
Output: [0]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> numCourses &lt;= 2000=</li>
<li><code>0 &lt;</code> prerequisites.length &lt;= numCourses * (numCourses - 1)=</li>
<li><code>prerequisites[i].length =</code> 2=</li>
<li><code>0 &lt;</code> aᵢ, bᵢ &lt; numCourses=</li>
<li><code>aᵢ !</code> bᵢ=</li>
<li>All the pairs <code>[aᵢ, bᵢ]</code> are <b>distinct</b>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/course-schedule-ii/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int numCourses;
    LeetCodeIO::scan(cin, numCourses);
    vector&lt;vector&lt;int&gt;&gt; prerequisites;
    LeetCodeIO::scan(cin, prerequisites);

    Solution *obj = new Solution();
    auto res = obj-&gt;findOrder(numCourses, prerequisites);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-house-robber-iilink-medium" class="outline-3">
<h3 id="house-robber-iilink-medium"><span class="section-number-3">8.68.</span> <a href="https://leetcode.com/problems/house-robber-ii/">213. House Robber II</a> (Medium)</h3>
<div class="outline-text-3" id="text-house-robber-iilink-medium">
<p>
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <b>arranged in a circle.</b> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.
</p>

<p>
Given an integer array <code>nums</code> representing the amount of money of each house, return the maximum amount of money you can rob tonight <b>without alerting the police</b>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org620e3e3">
Input: nums = [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are
adjacent houses.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org96fcb59">
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org247d6d7">
Input: nums = [1,2,3]
Output: 3
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 100=</li>
<li><code>0 &lt;</code> nums[i] &lt;= 1000=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/house-robber-ii/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;rob(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-kth-largest-element-in-an-arraylink-medium" class="outline-3">
<h3 id="kth-largest-element-in-an-arraylink-medium"><span class="section-number-3">8.69.</span> <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">215. Kth Largest Element in an Array</a> (Medium)</h3>
<div class="outline-text-3" id="text-kth-largest-element-in-an-arraylink-medium">
<p>
Given an integer array <code>nums</code> and an integer <code>k</code>, return the =kᵗʰ=largest element in the array.
</p>

<p>
Note that it is the <code>kᵗʰ</code> largest element in the sorted order, not the <code>kᵗʰ</code> distinct element.
</p>

<p>
Can you solve it without sorting?
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org6a40418">
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org453ca3a">
Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> k &lt;= nums.length &lt;= 10⁵=</li>
<li><code>-10⁴ &lt;</code> nums[i] &lt;= 10⁴=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/kth-largest-element-in-an-array/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);
    int k;
    LeetCodeIO::scan(cin, k);

    Solution *obj = new Solution();
    auto res = obj-&gt;findKthLargest(nums, k);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-contains-duplicatelink-easy" class="outline-3">
<h3 id="contains-duplicatelink-easy"><span class="section-number-3">8.70.</span> <a href="https://leetcode.com/problems/contains-duplicate/">217. Contains Duplicate</a> (Easy)</h3>
<div class="outline-text-3" id="text-contains-duplicatelink-easy">
<p>
Given an integer array <code>nums</code>, return <code>true</code> if any value appears <b>at least twice</b> in the array, and return <code>false</code> if every element is distinct.
</p>

<p>
<b>Example 1:</b>
</p>

<p>
<b>Input:</b> nums = [1,2,3,1]
</p>

<p>
<b>Output:</b> true
</p>

<p>
<b>Explanation:</b>
</p>

<p>
The element 1 occurs at the indices 0 and 3.
</p>

<p>
<b>Example 2:</b>
</p>

<p>
<b>Input:</b> nums = [1,2,3,4]
</p>

<p>
<b>Output:</b> false
</p>

<p>
<b>Explanation:</b>
</p>

<p>
All elements are distinct.
</p>

<p>
<b>Example 3:</b>
</p>

<p>
<b>Input:</b> nums = [1,1,1,3,3,4,3,2,4,2]
</p>

<p>
<b>Output:</b> true
</p>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 10⁵=</li>
<li><code>-10⁹ &lt;</code> nums[i] &lt;= 10⁹=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/contains-duplicate/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool containsDuplicate(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;containsDuplicate(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-the-skyline-problemlink-hard" class="outline-3">
<h3 id="the-skyline-problemlink-hard"><span class="section-number-3">8.71.</span> <a href="https://leetcode.com/problems/the-skyline-problem/">218. The Skyline Problem</a> (Hard)</h3>
<div class="outline-text-3" id="text-the-skyline-problemlink-hard">
<p>
A city's <b>skyline</b> is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the <b>skyline</b> formed by these buildings collectively.
</p>

<p>
The geometric information of each building is given in the array <code>buildings</code> where <code>buildings[i] = [leftᵢ, rightᵢ, heightᵢ]</code>:
</p>

<ul class="org-ul">
<li><code>leftᵢ</code> is the x coordinate of the left edge of the <code>iᵗʰ</code> building.</li>
<li><code>rightᵢ</code> is the x coordinate of the right edge of the <code>iᵗʰ</code> building.</li>
<li><code>heightᵢ</code> is the height of the <code>iᵗʰ</code> building.</li>
</ul>

<p>
You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height <code>0</code>.
</p>

<p>
The <b>skyline</b> should be represented as a list of "key points" <b>sorted by their x-coordinate</b> in the form <code>[[x₁,y₁],[x₂,y₂],...]</code>. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate <code>0</code> and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.
</p>

<p>
<b>Note:</b> There must be no consecutive horizontal lines of equal height in the output skyline. For instance, <code>[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]</code> is not acceptable; the three lines of height 5 should be merged into one in the final output as such: <code>[...,[2 3],[4 5],[12 7],...]</code>
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org1766de1" class="figure">
<p><img src="../Leetcode/src/0218.the-skyline-problem/merged.jpg" alt="merged.jpg" />
</p>
</div>

<pre class="example" id="org14567bd">
Input: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]
Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
Explanation:
Figure A shows the buildings of the input.
Figure B shows the skyline formed by those buildings. The red points in figure B represent the key
points in the output list.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgc4de725">
Input: buildings = [[0,2,3],[2,5,3]]
Output: [[0,3],[5,0]]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> buildings.length &lt;= 10⁴=</li>
<li><code>0 &lt;</code> leftᵢ &lt; rightᵢ &lt;= 2³¹ - 1=</li>
<li><code>1 &lt;</code> heightᵢ &lt;= 2³¹ - 1=</li>
<li><code>buildings</code> is sorted by <code>leftᵢ</code> in non-decreasing order.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/the-skyline-problem/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; buildings;
    LeetCodeIO::scan(cin, buildings);

    Solution *obj = new Solution();
    auto res = obj-&gt;getSkyline(buildings);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-maximal-squarelink-medium" class="outline-3">
<h3 id="maximal-squarelink-medium"><span class="section-number-3">8.72.</span> <a href="https://leetcode.com/problems/maximal-square/">221. Maximal Square</a> (Medium)</h3>
<div class="outline-text-3" id="text-maximal-squarelink-medium">
<p>
Given an <code>m x n</code> binary <code>matrix</code> filled with <code>0</code>'s and <code>1</code>'s, find the largest square containing only <code>1</code>'s and return its area.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orgec1b5d6" class="figure">
<p><img src="../Leetcode/src/0221.maximal-square/max1grid.jpg" alt="max1grid.jpg" />
</p>
</div>

<pre class="example" id="org2d49aec">
Input: matrix =
[["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
Output: 4
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="orgb1951a5" class="figure">
<p><img src="../Leetcode/src/0221.maximal-square/max2grid.jpg" alt="max2grid.jpg" />
</p>
</div>

<pre class="example" id="org8e385c5">
Input: matrix = [["0","1"],["1","0"]]
Output: 1
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orgf6293b9">
Input: matrix = [["0"]]
Output: 0
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>m =</code> matrix.length=</li>
<li><code>n =</code> matrix[i].length=</li>
<li><code>1 &lt;</code> m, n &lt;= 300=</li>
<li><code>matrix[i][j]</code> is <code>'0'</code> or <code>'1'</code>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/maximal-square/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;char&gt;&gt; matrix;
    LeetCodeIO::scan(cin, matrix);

    Solution *obj = new Solution();
    auto res = obj-&gt;maximalSquare(matrix);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-implement-stack-using-queueslink-easy" class="outline-3">
<h3 id="implement-stack-using-queueslink-easy"><span class="section-number-3">8.73.</span> <a href="https://leetcode.com/problems/implement-stack-using-queues/">225. Implement Stack using Queues</a> (Easy)</h3>
<div class="outline-text-3" id="text-implement-stack-using-queueslink-easy">
<p>
Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack ( <code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).
</p>

<p>
Implement the <code>MyStack</code> class:
</p>

<ul class="org-ul">
<li><code>void push(int x)</code> Pushes element x to the top of the stack.</li>
<li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li>
<li><code>int top()</code> Returns the element on the top of the stack.</li>
<li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code> otherwise.</li>
</ul>

<p>
<b>Notes:</b>
</p>

<ul class="org-ul">
<li>You must use <b>only</b> standard operations of a queue, which means that only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code> and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.</li>
</ul>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org05c97ba">
Input
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
Output
[null, null, null, 2, 2, false]

Explanation
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // return 2
myStack.pop(); // return 2
myStack.empty(); // return False
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> x &lt;= 9=</li>
<li>At most <code>100</code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>empty</code>.</li>
<li>All the calls to <code>pop</code> and <code>top</code> are valid.</li>
</ul>

<p>
<b>Follow-up:</b> Can you implement the stack using only one queue?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/implement-stack-using-queues/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class MyStack {
public:
    MyStack() {

    }

    void push(int x) {

    }

    int pop() {

    }

    int top() {

    }

    bool empty() {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;string&gt; method_names;
    LeetCodeIO::scan(cin, method_names);

    MyStack *obj;
    const unordered_map&lt;string, function&lt;void()&gt;&gt; methods = {
        { "MyStack", [&amp;]() {
            cin.ignore();
            obj = new MyStack();
            out_stream &lt;&lt; "null,";
        } },
        { "push", [&amp;]() {
            int x; LeetCodeIO::scan(cin, x); cin.ignore();
            obj-&gt;push(x);
            out_stream &lt;&lt; "null,";
        } },
        { "pop", [&amp;]() {
            cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;pop()); out_stream &lt;&lt; ',';
        } },
        { "top", [&amp;]() {
            cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;top()); out_stream &lt;&lt; ',';
        } },
        { "empty", [&amp;]() {
            cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;empty()); out_stream &lt;&lt; ',';
        } },
    };
    cin &gt;&gt; ws;
    out_stream &lt;&lt; '[';
    for (auto &amp;&amp;method_name : method_names) {
        cin.ignore(2);
        methods.at(method_name)();
    }
    cin.ignore();
    out_stream.seekp(-1, ios_base::end); out_stream &lt;&lt; ']';
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-invert-binary-treelink-easy" class="outline-3">
<h3 id="invert-binary-treelink-easy"><span class="section-number-3">8.74.</span> <a href="https://leetcode.com/problems/invert-binary-tree/">226. Invert Binary Tree</a> (Easy)</h3>
<div class="outline-text-3" id="text-invert-binary-treelink-easy">
<p>
Given the <code>root</code> of a binary tree, invert the tree, and return its root.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orgf7c34e3" class="figure">
<p><img src="../Leetcode/src/0226.invert-binary-tree/invert1-tree.jpg" alt="invert1-tree.jpg" />
</p>
</div>

<pre class="example" id="org0da6159">
Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org67f8bc1" class="figure">
<p><img src="../Leetcode/src/0226.invert-binary-tree/invert2-tree.jpg" alt="invert2-tree.jpg" />
</p>
</div>

<pre class="example" id="org46ecfab">
Input: root = [2,1,3]
Output: [2,3,1]
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org5263f24">
Input: root = []
Output: []
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
<li><code>-100 &lt;</code> Node.val &lt;= 100=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/invert-binary-tree/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);

    Solution *obj = new Solution();
    auto res = obj-&gt;invertTree(root);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-basic-calculator-iilink-medium" class="outline-3">
<h3 id="basic-calculator-iilink-medium"><span class="section-number-3">8.75.</span> <a href="https://leetcode.com/problems/basic-calculator-ii/">227. Basic Calculator II</a> (Medium)</h3>
<div class="outline-text-3" id="text-basic-calculator-iilink-medium">
<p>
Given a string <code>s</code> which represents an expression, evaluate this expression and return its value.
</p>

<p>
The integer division should truncate toward zero.
</p>

<p>
You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-2³¹, 2³¹ - 1]</code>.
</p>

<p>
<b>Note:</b> You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgb9edee4">
Input: s = "3+2*2"
Output: 7
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org7b75edc">
Input: s = " 3/2 "
Output: 1
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org561ade9">
Input: s = " 3+5 / 2 "
Output: 5
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> s.length &lt;= 3 * 10⁵=</li>
<li><code>s</code> consists of integers and operators <code>('+', '-', '*', '/')</code> separated by some number of spaces.</li>
<li><code>s</code> represents <b>a valid expression</b>.</li>
<li>All the integers in the expression are non-negative integers in the range <code>[0, 2³¹ - 1]</code>.</li>
<li>The answer is <b>guaranteed</b> to fit in a <b>32-bit integer</b>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/basic-calculator-ii/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int calculate(string s) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string s;
    LeetCodeIO::scan(cin, s);

    Solution *obj = new Solution();
    auto res = obj-&gt;calculate(s);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-implement-queue-using-stackslink-easy" class="outline-3">
<h3 id="implement-queue-using-stackslink-easy"><span class="section-number-3">8.76.</span> <a href="https://leetcode.com/problems/implement-queue-using-stacks/">232. Implement Queue using Stacks</a> (Easy)</h3>
<div class="outline-text-3" id="text-implement-queue-using-stackslink-easy">
<p>
Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue ( <code>push</code>, <code>peek</code>, <code>pop</code>, and <code>empty</code>).
</p>

<p>
Implement the <code>MyQueue</code> class:
</p>

<ul class="org-ul">
<li><code>void push(int x)</code> Pushes element x to the back of the queue.</li>
<li><code>int pop()</code> Removes the element from the front of the queue and returns it.</li>
<li><code>int peek()</code> Returns the element at the front of the queue.</li>
<li><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code> otherwise.</li>
</ul>

<p>
<b>Notes:</b>
</p>

<ul class="org-ul">
<li>You must use <b>only</b> standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.</li>
</ul>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org6ed5cf6">
Input
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
Output
[null, null, null, 1, 1, false]

Explanation
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> x &lt;= 9=</li>
<li>At most <code>100</code> calls will be made to <code>push</code>, <code>pop</code>, <code>peek</code>, and <code>empty</code>.</li>
<li>All the calls to <code>pop</code> and <code>peek</code> are valid.</li>
</ul>

<p>
<b>Follow-up:</b> Can you implement the queue such that each operation is <b><a href="https://en.wikipedia.org/wiki/Amortized_analysis">amortized</a></b> <code>O(1)</code> time complexity? In other words, performing <code>n</code> operations will take overall <code>O(n)</code> time even if one of those operations may take longer.
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/implement-queue-using-stacks/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class MyQueue {
public:
    MyQueue() {

    }

    void push(int x) {

    }

    int pop() {

    }

    int peek() {

    }

    bool empty() {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;string&gt; method_names;
    LeetCodeIO::scan(cin, method_names);

    MyQueue *obj;
    const unordered_map&lt;string, function&lt;void()&gt;&gt; methods = {
        { "MyQueue", [&amp;]() {
            cin.ignore();
            obj = new MyQueue();
            out_stream &lt;&lt; "null,";
        } },
        { "push", [&amp;]() {
            int x; LeetCodeIO::scan(cin, x); cin.ignore();
            obj-&gt;push(x);
            out_stream &lt;&lt; "null,";
        } },
        { "pop", [&amp;]() {
            cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;pop()); out_stream &lt;&lt; ',';
        } },
        { "peek", [&amp;]() {
            cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;peek()); out_stream &lt;&lt; ',';
        } },
        { "empty", [&amp;]() {
            cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;empty()); out_stream &lt;&lt; ',';
        } },
    };
    cin &gt;&gt; ws;
    out_stream &lt;&lt; '[';
    for (auto &amp;&amp;method_name : method_names) {
        cin.ignore(2);
        methods.at(method_name)();
    }
    cin.ignore();
    out_stream.seekp(-1, ios_base::end); out_stream &lt;&lt; ']';
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-lowest-common-ancestor-of-a-binary-search-treelink-medium" class="outline-3">
<h3 id="lowest-common-ancestor-of-a-binary-search-treelink-medium"><span class="section-number-3">8.77.</span> <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. Lowest Common Ancestor of a Binary Search Tree</a> (Medium)</h3>
<div class="outline-text-3" id="text-lowest-common-ancestor-of-a-binary-search-treelink-medium">
<p>
Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.
</p>

<p>
According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: "The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <b>a node to be a descendant of itself</b>)."
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org7d46902" class="figure">
<p><img src="../Leetcode/src/0235.lowest-common-ancestor-of-a-binary-search-tree/binarysearchtree_improved.png" alt="binarysearchtree_improved.png" />
</p>
</div>

<pre class="example" id="org85fc045">
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org0b90c03" class="figure">
<p><img src="../Leetcode/src/0235.lowest-common-ancestor-of-a-binary-search-tree/binarysearchtree_improved.png" alt="binarysearchtree_improved.png" />
</p>
</div>

<pre class="example" id="org4fa474a">
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to
the LCA definition.
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orgd0fa347">
Input: root = [2,1], p = 2, q = 1
Output: 2
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[2, 10⁵]</code>.</li>
<li><code>-10⁹ &lt;</code> Node.val &lt;= 10⁹=</li>
<li>All <code>Node.val</code> are <b>unique</b>.</li>
<li><code>p !</code> q=</li>
<li><code>p</code> and <code>q</code> will exist in the BST.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

    }
};

// @lc code=end

// Warning: this is a manual question, the generated test code may be incorrect.
int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);
    int p;
    LeetCodeIO::scan(cin, p);
    int q;
    LeetCodeIO::scan(cin, q);

    Solution *obj = new Solution();
    auto res = obj-&gt;lowestCommonAncestor(root, p, q);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-lowest-common-ancestor-of-a-binary-treelink-medium" class="outline-3">
<h3 id="lowest-common-ancestor-of-a-binary-treelink-medium"><span class="section-number-3">8.78.</span> <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Tree</a> (Medium)</h3>
<div class="outline-text-3" id="text-lowest-common-ancestor-of-a-binary-treelink-medium">
<p>
Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
</p>

<p>
According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: "The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <b>a node to be a descendant of itself</b>)."
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org1222a9f" class="figure">
<p><img src="../Leetcode/src/0236.lowest-common-ancestor-of-a-binary-tree/binarytree.png" alt="binarytree.png" />
</p>
</div>

<pre class="example" id="org667e22c">
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="orgb741f7c" class="figure">
<p><img src="../Leetcode/src/0236.lowest-common-ancestor-of-a-binary-tree/binarytree.png" alt="binarytree.png" />
</p>
</div>

<pre class="example" id="org0af2353">
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to
the LCA definition.
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orgaa822b9">
Input: root = [1,2], p = 1, q = 2
Output: 1
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[2, 10⁵]</code>.</li>
<li><code>-10⁹ &lt;</code> Node.val &lt;= 10⁹=</li>
<li>All <code>Node.val</code> are <b>unique</b>.</li>
<li><code>p !</code> q=</li>
<li><code>p</code> and <code>q</code> will exist in the tree.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

    }
};

// @lc code=end

// Warning: this is a manual question, the generated test code may be incorrect.
int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);
    int p;
    LeetCodeIO::scan(cin, p);
    int q;
    LeetCodeIO::scan(cin, q);

    Solution *obj = new Solution();
    auto res = obj-&gt;lowestCommonAncestor(root, p, q);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-product-of-array-except-selflink-medium" class="outline-3">
<h3 id="product-of-array-except-selflink-medium"><span class="section-number-3">8.79.</span> <a href="https://leetcode.com/problems/product-of-array-except-self/">238. Product of Array Except Self</a> (Medium)</h3>
<div class="outline-text-3" id="text-product-of-array-except-selflink-medium">
<p>
Given an integer array <code>nums</code>, return an array <code>answer=such that =answer[i]=is equal to the product of all the elements of =nums=except =nums[i]</code>.
</p>

<p>
The product of any prefix or suffix of <code>nums</code> is <b>guaranteed</b> to fit in a <b>32-bit</b> integer.
</p>

<p>
You must write an algorithm that runs in <code>O(n)</code> time and without using the division operation.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org53aef7d">
Input: nums = [1,2,3,4]
Output: [24,12,8,6]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgda2ac16">
Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>2 &lt;</code> nums.length &lt;= 10⁵=</li>
<li><code>-30 &lt;</code> nums[i] &lt;= 30=</li>
<li>The input is generated such that <code>answer[i]</code> is <b>guaranteed</b> to fit in a <b>32-bit</b> integer.</li>
</ul>

<p>
<b>Follow up:</b> Can you solve the problem in <code>O(1)</code> extra space complexity? (The output array <b>does not</b> count as extra space for space complexity analysis.)
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/product-of-array-except-self/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;productExceptSelf(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-sliding-window-maximumlink-hard" class="outline-3">
<h3 id="sliding-window-maximumlink-hard"><span class="section-number-3">8.80.</span> <a href="https://leetcode.com/problems/sliding-window-maximum/">239. Sliding Window Maximum</a> (Hard)</h3>
<div class="outline-text-3" id="text-sliding-window-maximumlink-hard">
<p>
You are given an array of integers <code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.
</p>

<p>
Return the max sliding window.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org01c6a0a">
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation:
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org770423f">
Input: nums = [1], k = 1
Output: [1]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 10⁵=</li>
<li><code>-10⁴ &lt;</code> nums[i] &lt;= 10⁴=</li>
<li><code>1 &lt;</code> k &lt;= nums.length=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/sliding-window-maximum/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);
    int k;
    LeetCodeIO::scan(cin, k);

    Solution *obj = new Solution();
    auto res = obj-&gt;maxSlidingWindow(nums, k);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-search-a-2d-matrix-iilink-medium" class="outline-3">
<h3 id="search-a-2d-matrix-iilink-medium"><span class="section-number-3">8.81.</span> <a href="https://leetcode.com/problems/search-a-2d-matrix-ii/">240. Search a 2D Matrix II</a> (Medium)</h3>
<div class="outline-text-3" id="text-search-a-2d-matrix-iilink-medium">
<p>
Write an efficient algorithm that searches for a value <code>target</code> in an <code>m x n</code> integer matrix <code>matrix</code>. This matrix has the following properties:
</p>

<ul class="org-ul">
<li>Integers in each row are sorted in ascending from left to right.</li>
<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>

<p>
<b>Example 1:</b>
</p>


<div id="org3866811" class="figure">
<p><img src="../Leetcode/src/0240.search-a-2d-matrix-ii/searchgrid2.jpg" alt="searchgrid2.jpg" />
</p>
</div>

<pre class="example" id="org7720e5a">
Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]],
target = 5
Output: true
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org9d838f5" class="figure">
<p><img src="../Leetcode/src/0240.search-a-2d-matrix-ii/searchgrid.jpg" alt="searchgrid.jpg" />
</p>
</div>

<pre class="example" id="orgde24429">
Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]],
target = 20
Output: false
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>m =</code> matrix.length=</li>
<li><code>n =</code> matrix[i].length=</li>
<li><code>1 &lt;</code> n, m &lt;= 300=</li>
<li><code>-10⁹ &lt;</code> matrix[i][j] &lt;= 10⁹=</li>
<li>All the integers in each row are <b>sorted</b> in ascending order.</li>
<li>All the integers in each column are <b>sorted</b> in ascending order.</li>
<li><code>-10⁹ &lt;</code> target &lt;= 10⁹=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/search-a-2d-matrix-ii/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {

    }
};

// @lc code=end

// Warning: this is a manual question, the generated test code may be incorrect.
int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; matrix;
    LeetCodeIO::scan(cin, matrix);
    int target;
    LeetCodeIO::scan(cin, target);

    Solution *obj = new Solution();
    auto res = obj-&gt;searchMatrix(matrix, target);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-different-ways-to-add-parentheseslink-medium" class="outline-3">
<h3 id="different-ways-to-add-parentheseslink-medium"><span class="section-number-3">8.82.</span> <a href="https://leetcode.com/problems/different-ways-to-add-parentheses/">241. Different Ways to Add Parentheses</a> (Medium)</h3>
<div class="outline-text-3" id="text-different-ways-to-add-parentheseslink-medium">
<p>
Given a string <code>expression</code> of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in <b>any order</b>.
</p>

<p>
The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed <code>10⁴</code>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org3ebd0a7">
Input: expression = "2-1-1"
Output: [0,2]
Explanation:
((2-1)-1) = 0
(2-(1-1)) = 2
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org04a955b">
Input: expression = "2*3-4*5"
Output: [-34,-14,-10,-10,10]
Explanation:
(2*(3-(4*5))) = -34
((2*3)-(4*5)) = -14
((2*(3-4))*5) = -10
(2*((3-4)*5)) = -10
(((2*3)-4)*5) = 10
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> expression.length &lt;= 20=</li>
<li><code>expression</code> consists of digits and the operator <code>'+'</code>, <code>'-'</code>, and <code>'*'</code>.</li>
<li>All the integer values in the input expression are in the range <code>[0, 99]</code>.</li>
<li>The integer values in the input expression do not have a leading <code>'-'</code> or <code>'+'</code> denoting the sign.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/different-ways-to-add-parentheses/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; diffWaysToCompute(string expression) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string expression;
    LeetCodeIO::scan(cin, expression);

    Solution *obj = new Solution();
    auto res = obj-&gt;diffWaysToCompute(expression);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-valid-anagramlink-easy" class="outline-3">
<h3 id="valid-anagramlink-easy"><span class="section-number-3">8.83.</span> <a href="https://leetcode.com/problems/valid-anagram/">242. Valid Anagram</a> (Easy)</h3>
<div class="outline-text-3" id="text-valid-anagramlink-easy">
<p>
Given two strings <code>s</code> and <code>t</code>, return <code>true</code> if <code>t</code> is an anagram of <code>s</code>, and <code>false</code> otherwise.
</p>

<p>
<b>Example 1:</b>
</p>

<p>
<b>Input:</b> s = "anagram", t = "nagaram"
</p>

<p>
<b>Output:</b> true
</p>

<p>
<b>Example 2:</b>
</p>

<p>
<b>Input:</b> s = "rat", t = "car"
</p>

<p>
<b>Output:</b> false
</p>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> s.length, t.length &lt;= 5 * 10⁴=</li>
<li><code>s</code> and <code>t</code> consist of lowercase English letters.</li>
</ul>

<p>
<b>Follow up:</b> What if the inputs contain Unicode characters? How would you adapt your solution to such a case?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/valid-anagram/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool isAnagram(string s, string t) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string s;
    LeetCodeIO::scan(cin, s);
    string t;
    LeetCodeIO::scan(cin, t);

    Solution *obj = new Solution();
    auto res = obj-&gt;isAnagram(s, t);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-binary-tree-pathslink-easy" class="outline-3">
<h3 id="binary-tree-pathslink-easy"><span class="section-number-3">8.84.</span> <a href="https://leetcode.com/problems/binary-tree-paths/">257. Binary Tree Paths</a> (Easy)</h3>
<div class="outline-text-3" id="text-binary-tree-pathslink-easy">
<p>
Given the <code>root</code> of a binary tree, return all root-to-leaf paths in <b>any order</b>.
</p>

<p>
A <b>leaf</b> is a node with no children.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org099d904" class="figure">
<p><img src="../Leetcode/src/0257.binary-tree-paths/paths-tree.jpg" alt="paths-tree.jpg" />
</p>
</div>

<pre class="example" id="org9800162">
Input: root = [1,2,3,null,5]
Output: ["1-&gt;2-&gt;5","1-&gt;3"]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org9423567">
Input: root = [1]
Output: ["1"]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li>
<li><code>-100 &lt;</code> Node.val &lt;= 100=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/binary-tree-paths/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);

    Solution *obj = new Solution();
    auto res = obj-&gt;binaryTreePaths(root);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-single-number-iiilink-medium" class="outline-3">
<h3 id="single-number-iiilink-medium"><span class="section-number-3">8.85.</span> <a href="https://leetcode.com/problems/single-number-iii/">260. Single Number III</a> (Medium)</h3>
<div class="outline-text-3" id="text-single-number-iiilink-medium">
<p>
Given an integer array <code>nums</code>, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in <b>any order</b>.
</p>

<p>
You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org48e5de2">
Input: nums = [1,2,1,3,2,5]
Output: [3,5]
Explanation:  [5, 3] is also a valid answer.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org93cde6c">
Input: nums = [-1,0]
Output: [-1,0]
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org35dbf23">
Input: nums = [0,1]
Output: [1,0]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>2 &lt;</code> nums.length &lt;= 3 * 10⁴=</li>
<li><code>-2³¹ &lt;</code> nums[i] &lt;= 2³¹ - 1=</li>
<li>Each integer in <code>nums</code> will appear twice, only two integers will appear once.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/single-number-iii/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;singleNumber(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-missing-numberlink-easy" class="outline-3">
<h3 id="missing-numberlink-easy"><span class="section-number-3">8.86.</span> <a href="https://leetcode.com/problems/missing-number/">268. Missing Number</a> (Easy)</h3>
<div class="outline-text-3" id="text-missing-numberlink-easy">
<p>
Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return the only number in the range that is missing from the array.
</p>

<p>
<b>Example 1:</b>
</p>

<p>
<b>Input:</b> nums = [3,0,1]
</p>

<p>
<b>Output:</b> 2
</p>

<p>
<b>Explanation:</b>
</p>

<p>
<code>n = 3</code> since there are 3 numbers, so all numbers are in the range <code>[0,3]</code>. 2 is the missing number in the range since it does not appear in <code>nums</code>.
</p>

<p>
<b>Example 2:</b>
</p>

<p>
<b>Input:</b> nums = [0,1]
</p>

<p>
<b>Output:</b> 2
</p>

<p>
<b>Explanation:</b>
</p>

<p>
<code>n = 2</code> since there are 2 numbers, so all numbers are in the range <code>[0,2]</code>. 2 is the missing number in the range since it does not appear in <code>nums</code>.
</p>

<p>
<b>Example 3:</b>
</p>

<p>
<b>Input:</b> nums = [9,6,4,2,3,5,7,0,1]
</p>

<p>
<b>Output:</b> 8
</p>

<p>
<b>Explanation:</b>
</p>

<p>
<code>n = 9</code> since there are 9 numbers, so all numbers are in the range <code>[0,9]</code>. 8 is the missing number in the range since it does not appear in <code>nums</code>.
</p>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>n =</code> nums.length=</li>
<li><code>1 &lt;</code> n &lt;= 10⁴=</li>
<li><code>0 &lt;</code> nums[i] &lt;= n=</li>
<li>All the numbers of <code>nums</code> are <b>unique</b>.</li>
</ul>

<p>
<b>Follow up:</b> Could you implement a solution using only <code>O(1)</code> extra space complexity and <code>O(n)</code> runtime complexity?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/missing-number/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int missingNumber(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;missingNumber(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-perfect-squareslink-medium" class="outline-3">
<h3 id="perfect-squareslink-medium"><span class="section-number-3">8.87.</span> <a href="https://leetcode.com/problems/perfect-squares/">279. Perfect Squares</a> (Medium)</h3>
<div class="outline-text-3" id="text-perfect-squareslink-medium">
<p>
Given an integer <code>n</code>, return the least number of perfect square numbers that sum to <code>n</code>.
</p>

<p>
A <b>perfect square</b> is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, <code>1</code>, <code>4</code>, <code>9</code>, and <code>16</code> are perfect squares while <code>3</code> and <code>11</code> are not.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org7c39132">
Input: n = 12
Output: 3
Explanation: 12 = 4 + 4 + 4.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org4d36111">
Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> n &lt;= 10⁴=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/perfect-squares/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int numSquares(int n) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int n;
    LeetCodeIO::scan(cin, n);

    Solution *obj = new Solution();
    auto res = obj-&gt;numSquares(n);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-find-the-duplicate-numberlink-medium" class="outline-3">
<h3 id="find-the-duplicate-numberlink-medium"><span class="section-number-3">8.88.</span> <a href="https://leetcode.com/problems/find-the-duplicate-number/">287. Find the Duplicate Number</a> (Medium)</h3>
<div class="outline-text-3" id="text-find-the-duplicate-numberlink-medium">
<p>
Given an array of integers <code>nums</code> containing <code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.
</p>

<p>
There is only <b>one repeated number</b> in <code>nums</code>, return this repeated number.
</p>

<p>
You must solve the problem <b>without</b> modifying the array <code>nums</code> and using only constant extra space.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgfbba7d8">
Input: nums = [1,3,4,2,2]
Output: 2
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org82f9b61">
Input: nums = [3,1,3,4,2]
Output: 3
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orgcb2b996">
Input: nums = [3,3,3,3,3]
Output: 3
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> n &lt;= 10⁵=</li>
<li><code>nums.length =</code> n + 1=</li>
<li><code>1 &lt;</code> nums[i] &lt;= n=</li>
<li>All the integers in <code>nums</code> appear only <b>once</b> except for <b>precisely one integer</b> which appears <b>two or more</b> times.</li>
</ul>

<p>
<b>Follow up:</b>
</p>

<ul class="org-ul">
<li>How can we prove that at least one duplicate number must exist in <code>nums</code>?</li>
<li>Can you solve the problem in linear runtime complexity?</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/find-the-duplicate-number/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int findDuplicate(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;findDuplicate(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-longest-increasing-subsequencelink-medium" class="outline-3">
<h3 id="longest-increasing-subsequencelink-medium"><span class="section-number-3">8.89.</span> <a href="https://leetcode.com/problems/longest-increasing-subsequence/">300. Longest Increasing Subsequence</a> (Medium)</h3>
<div class="outline-text-3" id="text-longest-increasing-subsequencelink-medium">
<p>
Given an integer array <code>nums</code>, return the length of the longest <b>strictly increasingsubsequence</b>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgf198b8f">
Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orga344730">
Input: nums = [0,1,0,3,2,3]
Output: 4
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orga4b9ea4">
Input: nums = [7,7,7,7,7,7,7]
Output: 1
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 2500=</li>
<li><code>-10⁴ &lt;</code> nums[i] &lt;= 10⁴=</li>
</ul>

<p>
<b>Follow up:</b> Can you come up with an algorithm that runs in <code>O(n log(n))</code> time complexity?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/longest-increasing-subsequence/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;lengthOfLIS(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-range-sum-query---immutablelink-easy" class="outline-3">
<h3 id="range-sum-query---immutablelink-easy"><span class="section-number-3">8.90.</span> <a href="https://leetcode.com/problems/range-sum-query-immutable/">303. Range Sum Query - Immutable</a> (Easy)</h3>
<div class="outline-text-3" id="text-range-sum-query---immutablelink-easy">
<p>
Given an integer array <code>nums</code>, handle multiple queries of the following type:
</p>

<ol class="org-ol">
<li>Calculate the <b>sum</b> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <b>inclusive</b> where <code>left &lt;</code> right=.</li>
</ol>

<p>
Implement the <code>NumArray</code> class:
</p>

<ul class="org-ul">
<li><code>NumArray(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li>
<li><code>int sumRange(int left, int right)</code> Returns the <b>sum</b> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <b>inclusive</b> (i.e. <code>nums[left] + nums[left + 1] + ... + nums[right]</code>).</li>
</ul>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org444538d">
Input
["NumArray", "sumRange", "sumRange", "sumRange"]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
Output
[null, 1, -1, -3]

Explanation
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1
numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1
numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 10⁴=</li>
<li><code>-10⁵ &lt;</code> nums[i] &lt;= 10⁵=</li>
<li><code>0 &lt;</code> left &lt;= right &lt; nums.length=</li>
<li>At most <code>10⁴</code> calls will be made to <code>sumRange</code>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/range-sum-query-immutable/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class NumArray {
public:
    NumArray(vector&lt;int&gt;&amp; nums) {

    }

    int sumRange(int left, int right) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;string&gt; method_names;
    LeetCodeIO::scan(cin, method_names);

    NumArray *obj;
    const unordered_map&lt;string, function&lt;void()&gt;&gt; methods = {
        { "NumArray", [&amp;]() {
            vector&lt;int&gt; nums; LeetCodeIO::scan(cin, nums); cin.ignore();
            int numsSize; LeetCodeIO::scan(cin, numsSize); cin.ignore();
            obj = new NumArray(nums, numsSize);
            out_stream &lt;&lt; "null,";
        } },
        { "sumRange", [&amp;]() {
            int left; LeetCodeIO::scan(cin, left); cin.ignore();
            int right; LeetCodeIO::scan(cin, right); cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;sumRange(left, right)); out_stream &lt;&lt; ',';
        } },
    };
    cin &gt;&gt; ws;
    out_stream &lt;&lt; '[';
    for (auto &amp;&amp;method_name : method_names) {
        cin.ignore(2);
        methods.at(method_name)();
    }
    cin.ignore();
    out_stream.seekp(-1, ios_base::end); out_stream &lt;&lt; ']';
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-range-sum-query-2d---immutablelink-medium" class="outline-3">
<h3 id="range-sum-query-2d---immutablelink-medium"><span class="section-number-3">8.91.</span> <a href="https://leetcode.com/problems/range-sum-query-2d-immutable/">304. Range Sum Query 2D - Immutable</a> (Medium)</h3>
<div class="outline-text-3" id="text-range-sum-query-2d---immutablelink-medium">
<p>
Given a 2D matrix <code>matrix</code>, handle multiple queries of the following type:
</p>

<ul class="org-ul">
<li>Calculate the <b>sum</b> of the elements of <code>matrix</code> inside the rectangle defined by its <b>upper left corner</b> <code>(row1, col1)</code> and <b>lower right corner</b> <code>(row2, col2)</code>.</li>
</ul>

<p>
Implement the <code>NumMatrix</code> class:
</p>

<ul class="org-ul">
<li><code>NumMatrix(int[][] matrix)</code> Initializes the object with the integer matrix <code>matrix</code>.</li>
<li><code>int sumRegion(int row1, int col1, int row2, int col2)</code> Returns the <b>sum</b> of the elements of <code>matrix</code> inside the rectangle defined by its <b>upper left corner</b> <code>(row1, col1)</code> and <b>lower right corner</b> <code>(row2, col2)</code>.</li>
</ul>

<p>
You must design an algorithm where <code>sumRegion</code> works on <code>O(1)</code> time complexity.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orga6e9d93" class="figure">
<p><img src="../Leetcode/src/0304.range-sum-query-2d-immutable/sum-grid.jpg" alt="sum-grid.jpg" />
</p>
</div>

<pre class="example" id="orgc6ba13e">
Input
["NumMatrix", "sumRegion", "sumRegion", "sumRegion"]
[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4,
3], [1, 1, 2, 2], [1, 2, 2, 4]]
Output
[null, 8, 11, 12]

Explanation
NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1,
7], [1, 0, 3, 0, 5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)
numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)
numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>m =</code> matrix.length=</li>
<li><code>n =</code> matrix[i].length=</li>
<li><code>1 &lt;</code> m, n &lt;= 200=</li>
<li><code>-10⁴ &lt;</code> matrix[i][j] &lt;= 10⁴=</li>
<li><code>0 &lt;</code> row1 &lt;= row2 &lt; m=</li>
<li><code>0 &lt;</code> col1 &lt;= col2 &lt; n=</li>
<li>At most <code>10⁴</code> calls will be made to <code>sumRegion</code>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/range-sum-query-2d-immutable/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class NumMatrix {
public:
    NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {

    }

    int sumRegion(int row1, int col1, int row2, int col2) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;string&gt; method_names;
    LeetCodeIO::scan(cin, method_names);

    NumMatrix *obj;
    const unordered_map&lt;string, function&lt;void()&gt;&gt; methods = {
        { "NumMatrix", [&amp;]() {
            vector&lt;vector&lt;int&gt;&gt; matrix; LeetCodeIO::scan(cin, matrix); cin.ignore();
            int matrixRowSize; LeetCodeIO::scan(cin, matrixRowSize); cin.ignore();
            int matrixColSize; LeetCodeIO::scan(cin, matrixColSize); cin.ignore();
            obj = new NumMatrix(matrix, matrixRowSize, matrixColSize);
            out_stream &lt;&lt; "null,";
        } },
        { "sumRegion", [&amp;]() {
            int row1; LeetCodeIO::scan(cin, row1); cin.ignore();
            int col1; LeetCodeIO::scan(cin, col1); cin.ignore();
            int row2; LeetCodeIO::scan(cin, row2); cin.ignore();
            int col2; LeetCodeIO::scan(cin, col2); cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;sumRegion(row1, col1, row2, col2)); out_stream &lt;&lt; ',';
        } },
    };
    cin &gt;&gt; ws;
    out_stream &lt;&lt; '[';
    for (auto &amp;&amp;method_name : method_names) {
        cin.ignore(2);
        methods.at(method_name)();
    }
    cin.ignore();
    out_stream.seekp(-1, ios_base::end); out_stream &lt;&lt; ']';
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-range-sum-query---mutablelink-medium" class="outline-3">
<h3 id="range-sum-query---mutablelink-medium"><span class="section-number-3">8.92.</span> <a href="https://leetcode.com/problems/range-sum-query-mutable/">307. Range Sum Query - Mutable</a> (Medium)</h3>
<div class="outline-text-3" id="text-range-sum-query---mutablelink-medium">
<p>
Given an integer array <code>nums</code>, handle multiple queries of the following types:
</p>

<ol class="org-ol">
<li><b>Update</b> the value of an element in <code>nums</code>.</li>
<li>Calculate the <b>sum</b> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <b>inclusive</b> where <code>left &lt;</code> right=.</li>
</ol>

<p>
Implement the <code>NumArray</code> class:
</p>

<ul class="org-ul">
<li><code>NumArray(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li>
<li><code>void update(int index, int val)</code> <b>Updates</b> the value of <code>nums[index]</code> to be <code>val</code>.</li>
<li><code>int sumRange(int left, int right)</code> Returns the <b>sum</b> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <b>inclusive</b> (i.e. <code>nums[left] + nums[left + 1] + ... + nums[right]</code>).</li>
</ul>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org711e3a0">
Input
["NumArray", "sumRange", "update", "sumRange"]
[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]
Output
[null, 9, null, 8]

Explanation
NumArray numArray = new NumArray([1, 3, 5]);
numArray.sumRange(0, 2); // return 1 + 3 + 5 = 9
numArray.update(1, 2);   // nums = [1, 2, 5]
numArray.sumRange(0, 2); // return 1 + 2 + 5 = 8
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 3 * 10⁴=</li>
<li><code>-100 &lt;</code> nums[i] &lt;= 100=</li>
<li><code>0 &lt;</code> index &lt; nums.length=</li>
<li><code>-100 &lt;</code> val &lt;= 100=</li>
<li><code>0 &lt;</code> left &lt;= right &lt; nums.length=</li>
<li>At most <code>3 * 10⁴</code> calls will be made to <code>update</code> and <code>sumRange</code>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/range-sum-query-mutable/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class NumArray {
public:
    NumArray(vector&lt;int&gt;&amp; nums) {

    }

    void update(int index, int val) {

    }

    int sumRange(int left, int right) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;string&gt; method_names;
    LeetCodeIO::scan(cin, method_names);

    NumArray *obj;
    const unordered_map&lt;string, function&lt;void()&gt;&gt; methods = {
        { "NumArray", [&amp;]() {
            vector&lt;int&gt; nums; LeetCodeIO::scan(cin, nums); cin.ignore();
            obj = new NumArray(nums);
            out_stream &lt;&lt; "null,";
        } },
        { "update", [&amp;]() {
            int index; LeetCodeIO::scan(cin, index); cin.ignore();
            int val; LeetCodeIO::scan(cin, val); cin.ignore();
            obj-&gt;update(index, val);
            out_stream &lt;&lt; "null,";
        } },
        { "sumRange", [&amp;]() {
            int left; LeetCodeIO::scan(cin, left); cin.ignore();
            int right; LeetCodeIO::scan(cin, right); cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;sumRange(left, right)); out_stream &lt;&lt; ',';
        } },
    };
    cin &gt;&gt; ws;
    out_stream &lt;&lt; '[';
    for (auto &amp;&amp;method_name : method_names) {
        cin.ignore(2);
        methods.at(method_name)();
    }
    cin.ignore();
    out_stream.seekp(-1, ios_base::end); out_stream &lt;&lt; ']';
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-best-time-to-buy-and-sell-stock-with-cooldownlink-medium" class="outline-3">
<h3 id="best-time-to-buy-and-sell-stock-with-cooldownlink-medium"><span class="section-number-3">8.93.</span> <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. Best Time to Buy and Sell Stock with Cooldown</a> (Medium)</h3>
<div class="outline-text-3" id="text-best-time-to-buy-and-sell-stock-with-cooldownlink-medium">
<p>
You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>iᵗʰ</code> day.
</p>

<p>
Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:
</p>

<ul class="org-ul">
<li>After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).</li>
</ul>

<p>
<b>Note:</b> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org451aa98">
Input: prices = [1,2,3,0,2]
Output: 3
Explanation: transactions = [buy, sell, cooldown, buy, sell]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgebfe940">
Input: prices = [1]
Output: 0
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> prices.length &lt;= 5000=</li>
<li><code>0 &lt;</code> prices[i] &lt;= 1000=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; prices;
    LeetCodeIO::scan(cin, prices);

    Solution *obj = new Solution();
    auto res = obj-&gt;maxProfit(prices);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-minimum-height-treeslink-medium" class="outline-3">
<h3 id="minimum-height-treeslink-medium"><span class="section-number-3">8.94.</span> <a href="https://leetcode.com/problems/minimum-height-trees/">310. Minimum Height Trees</a> (Medium)</h3>
<div class="outline-text-3" id="text-minimum-height-treeslink-medium">
<p>
A tree is an undirected graph in which any two vertices are connected by <i>exactly</i> one path. In other words, any connected graph without simple cycles is a tree.
</p>

<p>
Given a tree of <code>n</code> nodes labelled from <code>0</code> to <code>n - 1</code>, and an array of <code>n - 1</code> <code>edges</code> where <code>edges[i] = [aᵢ, bᵢ]</code> indicates that there is an undirected edge between the two nodes <code>aᵢ</code> and <code>bᵢ</code> in the tree, you can choose any node of the tree as the root. When you select a node <code>x</code> as the root, the result tree has height <code>h</code>. Among all possible rooted trees, those with minimum height (i.e. <code>min(h)</code>) are called <b>minimum height trees</b> (MHTs).
</p>

<p>
Return a list of all <b>MHTs'</b> root labels. You can return the answer in <b>any order</b>.
</p>

<p>
The <b>height</b> of a rooted tree is the number of edges on the longest downward path between the root and a leaf.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org297ed1c" class="figure">
<p><img src="../Leetcode/src/0310.minimum-height-trees/e1.jpg" alt="e1.jpg" />
</p>
</div>

<pre class="example" id="org3e2fdec">
Input: n = 4, edges = [[1,0],[1,2],[1,3]]
Output: [1]
Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is
the only MHT.
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org5acdf11" class="figure">
<p><img src="../Leetcode/src/0310.minimum-height-trees/e2.jpg" alt="e2.jpg" />
</p>
</div>

<pre class="example" id="org712a9a6">
Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
Output: [3,4]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> n &lt;= 2 * 10⁴=</li>
<li><code>edges.length =</code> n - 1=</li>
<li><code>0 &lt;</code> aᵢ, bᵢ &lt; n=</li>
<li><code>aᵢ !</code> bᵢ=</li>
<li>All the pairs <code>(aᵢ, bᵢ)</code> are distinct.</li>
<li>The given input is <b>guaranteed</b> to be a tree and there will be <b>no repeated</b> edges.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/minimum-height-trees/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int n;
    LeetCodeIO::scan(cin, n);
    vector&lt;vector&lt;int&gt;&gt; edges;
    LeetCodeIO::scan(cin, edges);

    Solution *obj = new Solution();
    auto res = obj-&gt;findMinHeightTrees(n, edges);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-burst-balloonslink-hard" class="outline-3">
<h3 id="burst-balloonslink-hard"><span class="section-number-3">8.95.</span> <a href="https://leetcode.com/problems/burst-balloons/">312. Burst Balloons</a> (Hard)</h3>
<div class="outline-text-3" id="text-burst-balloonslink-hard">
<p>
You are given <code>n</code> balloons, indexed from <code>0</code> to <code>n - 1</code>. Each balloon is painted with a number on it represented by an array <code>nums</code>. You are asked to burst all the balloons.
</p>

<p>
If you burst the <code>iᵗʰ</code> balloon, you will get <code>nums[i - 1] * nums[i] * nums[i + 1]</code> coins. If <code>i - 1</code> or <code>i + 1</code> goes out of bounds of the array, then treat it as if there is a balloon with a <code>1</code> painted on it.
</p>

<p>
Return the maximum coins you can collect by bursting the balloons wisely.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org8e97df4">
Input: nums = [3,1,5,8]
Output: 167
Explanation:
nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orga30ddd3">
Input: nums = [1,5]
Output: 10
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>n =</code> nums.length=</li>
<li><code>1 &lt;</code> n &lt;= 300=</li>
<li><code>0 &lt;</code> nums[i] &lt;= 100=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/burst-balloons/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int maxCoins(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;maxCoins(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-super-ugly-numberlink-medium" class="outline-3">
<h3 id="super-ugly-numberlink-medium"><span class="section-number-3">8.96.</span> <a href="https://leetcode.com/problems/super-ugly-number/">313. Super Ugly Number</a> (Medium)</h3>
<div class="outline-text-3" id="text-super-ugly-numberlink-medium">
<p>
A <b>super ugly number</b> is a positive integer whose prime factors are in the array <code>primes</code>.
</p>

<p>
Given an integer <code>n</code> and an array of integers <code>primes</code>, return the =nᵗʰ=*super ugly number*.
</p>

<p>
The <code>nᵗʰ</code> <b>super ugly number</b> is <b>guaranteed</b> to fit in a <b>32-bit</b> signed integer.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orga3f8f6d">
Input: n = 12, primes = [2,7,13,19]
Output: 32
Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers
given primes = [2,7,13,19].
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org88c0b1f">
Input: n = 1, primes = [2,3,5]
Output: 1
Explanation: 1 has no prime factors, therefore all of its prime factors are in the array primes =
[2,3,5].
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> n &lt;= 10⁵=</li>
<li><code>1 &lt;</code> primes.length &lt;= 100=</li>
<li><code>2 &lt;</code> primes[i] &lt;= 1000=</li>
<li><code>primes[i]</code> is <b>guaranteed</b> to be a prime number.</li>
<li>All the values of <code>primes</code> are <b>unique</b> and sorted in <b>ascending order</b>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/super-ugly-number/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int n;
    LeetCodeIO::scan(cin, n);
    vector&lt;int&gt; primes;
    LeetCodeIO::scan(cin, primes);

    Solution *obj = new Solution();
    auto res = obj-&gt;nthSuperUglyNumber(n, primes);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-maximum-product-of-word-lengthslink-medium" class="outline-3">
<h3 id="maximum-product-of-word-lengthslink-medium"><span class="section-number-3">8.97.</span> <a href="https://leetcode.com/problems/maximum-product-of-word-lengths/">318. Maximum Product of Word Lengths</a> (Medium)</h3>
<div class="outline-text-3" id="text-maximum-product-of-word-lengthslink-medium">
<p>
Given a string array <code>words</code>, return the maximum value of <code>length(word[i]) * length(word[j])=where the two words do not share common letters. If no such two words exist, return =0</code>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org9e18284">
Input: words = ["abcw","baz","foo","bar","xtfn","abcdef"]
Output: 16
Explanation: The two words can be "abcw", "xtfn".
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgcc0d05e">
Input: words = ["a","ab","abc","d","cd","bcd","abcd"]
Output: 4
Explanation: The two words can be "ab", "cd".
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orgccdf321">
Input: words = ["a","aa","aaa","aaaa"]
Output: 0
Explanation: No such pair of words.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>2 &lt;</code> words.length &lt;= 1000=</li>
<li><code>1 &lt;</code> words[i].length &lt;= 1000=</li>
<li><code>words[i]</code> consists only of lowercase English letters.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/maximum-product-of-word-lengths/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int maxProduct(vector&lt;string&gt;&amp; words) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;string&gt; words;
    LeetCodeIO::scan(cin, words);

    Solution *obj = new Solution();
    auto res = obj-&gt;maxProduct(words);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-coin-changelink-medium" class="outline-3">
<h3 id="coin-changelink-medium"><span class="section-number-3">8.98.</span> <a href="https://leetcode.com/problems/coin-change/">322. Coin Change</a> (Medium)</h3>
<div class="outline-text-3" id="text-coin-changelink-medium">
<p>
You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.
</p>

<p>
Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.
</p>

<p>
You may assume that you have an infinite number of each kind of coin.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org2c268f6">
Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgb0bc4b3">
Input: coins = [2], amount = 3
Output: -1
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org4788e50">
Input: coins = [1], amount = 0
Output: 0
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> coins.length &lt;= 12=</li>
<li><code>1 &lt;</code> coins[i] &lt;= 2³¹ - 1=</li>
<li><code>0 &lt;</code> amount &lt;= 10⁴=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/coin-change/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int coinChange(vector&lt;int&gt;&amp; coins, int amount) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; coins;
    LeetCodeIO::scan(cin, coins);
    int amount;
    LeetCodeIO::scan(cin, amount);

    Solution *obj = new Solution();
    auto res = obj-&gt;coinChange(coins, amount);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-odd-even-linked-listlink-medium" class="outline-3">
<h3 id="odd-even-linked-listlink-medium"><span class="section-number-3">8.99.</span> <a href="https://leetcode.com/problems/odd-even-linked-list/">328. Odd Even Linked List</a> (Medium)</h3>
<div class="outline-text-3" id="text-odd-even-linked-listlink-medium">
<p>
Given the <code>head</code> of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.
</p>

<p>
The <b>first</b> node is considered <b>odd</b>, and the <b>second</b> node is <b>even</b>, and so on.
</p>

<p>
Note that the relative order inside both the even and odd groups should remain as it was in the input.
</p>

<p>
You must solve the problem in <code>O(1)</code> extra space complexity and <code>O(n)</code> time complexity.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org5ff1254" class="figure">
<p><img src="../Leetcode/src/0328.odd-even-linked-list/oddeven-linked-list.jpg" alt="oddeven-linked-list.jpg" />
</p>
</div>

<pre class="example" id="orga48af89">
Input: head = [1,2,3,4,5]
Output: [1,3,5,2,4]
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="orgda53550" class="figure">
<p><img src="../Leetcode/src/0328.odd-even-linked-list/oddeven2-linked-list.jpg" alt="oddeven2-linked-list.jpg" />
</p>
</div>

<pre class="example" id="org7c4cd32">
Input: head = [2,1,3,5,6,4,7]
Output: [2,3,6,7,1,5,4]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the linked list is in the range <code>[0, 10⁴]</code>.</li>
<li><code>-10⁶ &lt;</code> Node.val &lt;= 10⁶=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/odd-even-linked-list/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    ListNode* head;
    LeetCodeIO::scan(cin, head);

    Solution *obj = new Solution();
    auto res = obj-&gt;oddEvenList(head);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-reconstruct-itinerarylink-hard" class="outline-3">
<h3 id="reconstruct-itinerarylink-hard"><span class="section-number-3">8.100.</span> <a href="https://leetcode.com/problems/reconstruct-itinerary/">332. Reconstruct Itinerary</a> (Hard)</h3>
<div class="outline-text-3" id="text-reconstruct-itinerarylink-hard">
<p>
You are given a list of airline <code>tickets</code> where <code>tickets[i] = [fromᵢ, toᵢ]</code> represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.
</p>

<p>
All of the tickets belong to a man who departs from <code>"JFK"</code>, thus, the itinerary must begin with <code>"JFK"</code>. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.
</p>

<ul class="org-ul">
<li>For example, the itinerary <code>["JFK", "LGA"]</code> has a smaller lexical order than <code>["JFK", "LGB"]</code>.</li>
</ul>

<p>
You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org0c6ed43" class="figure">
<p><img src="../Leetcode/src/0332.reconstruct-itinerary/itinerary1-graph.jpg" alt="itinerary1-graph.jpg" />
</p>
</div>

<pre class="example" id="orgc3f2b1b">
Input: tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
Output: ["JFK","MUC","LHR","SFO","SJC"]
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org9cf3dbe" class="figure">
<p><img src="../Leetcode/src/0332.reconstruct-itinerary/itinerary2-graph.jpg" alt="itinerary2-graph.jpg" />
</p>
</div>

<pre class="example" id="orgf2744a3">
Input: tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
Output: ["JFK","ATL","JFK","SFO","ATL","SFO"]
Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"] but it is
larger in lexical order.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> tickets.length &lt;= 300=</li>
<li><code>tickets[i].length =</code> 2=</li>
<li><code>fromᵢ.length =</code> 3=</li>
<li><code>toᵢ.length =</code> 3=</li>
<li><code>fromᵢ</code> and <code>toᵢ</code> consist of uppercase English letters.</li>
<li><code>fromᵢ !</code> toᵢ=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/reconstruct-itinerary/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;string&gt;&gt; tickets;
    LeetCodeIO::scan(cin, tickets);

    Solution *obj = new Solution();
    auto res = obj-&gt;findItinerary(tickets);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-counting-bitslink-easy" class="outline-3">
<h3 id="counting-bitslink-easy"><span class="section-number-3">8.101.</span> <a href="https://leetcode.com/problems/counting-bits/">338. Counting Bits</a> (Easy)</h3>
<div class="outline-text-3" id="text-counting-bitslink-easy">
<p>
Given an integer <code>n</code>, return an array <code>ans</code> of length <code>n + 1</code> such that for each <code>i=( =0 &lt;</code> i &lt;= n=), <code>ans[i]</code> is the <b>number of</b> <code>1=*'s* in the binary representation of =i</code>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org3b718e2">
Input: n = 2
Output: [0,1,1]
Explanation:
0 --&gt; 0
1 --&gt; 1
2 --&gt; 10
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgd86c6d9">
Input: n = 5
Output: [0,1,1,2,1,2]
Explanation:
0 --&gt; 0
1 --&gt; 1
2 --&gt; 10
3 --&gt; 11
4 --&gt; 100
5 --&gt; 101
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>0 &lt;</code> n &lt;= 10⁵=</li>
</ul>

<p>
<b>Follow up:</b>
</p>

<ul class="org-ul">
<li>It is very easy to come up with a solution with a runtime of <code>O(n log n)</code>. Can you do it in linear time <code>O(n)</code> and possibly in a single pass?</li>
<li>Can you do it without using any built-in function (i.e., like <code>__builtin_popcount</code> in C++)?</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/counting-bits/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; countBits(int n) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int n;
    LeetCodeIO::scan(cin, n);

    Solution *obj = new Solution();
    auto res = obj-&gt;countBits(n);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-integer-breaklink-medium" class="outline-3">
<h3 id="integer-breaklink-medium"><span class="section-number-3">8.102.</span> <a href="https://leetcode.com/problems/integer-break/">343. Integer Break</a> (Medium)</h3>
<div class="outline-text-3" id="text-integer-breaklink-medium">
<p>
Given an integer <code>n</code>, break it into the sum of <code>k</code> <b>positive integers</b>, where <code>k &gt;</code> 2=, and maximize the product of those integers.
</p>

<p>
Return the maximum product you can get.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orga3ecce5">
Input: n = 2
Output: 1
Explanation: 2 = 1 + 1, 1 × 1 = 1.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org5de5d97">
Input: n = 10
Output: 36
Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>2 &lt;</code> n &lt;= 58=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/integer-break/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int integerBreak(int n) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int n;
    LeetCodeIO::scan(cin, n);

    Solution *obj = new Solution();
    auto res = obj-&gt;integerBreak(n);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-top-k-frequent-elementslink-medium" class="outline-3">
<h3 id="top-k-frequent-elementslink-medium"><span class="section-number-3">8.103.</span> <a href="https://leetcode.com/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a> (Medium)</h3>
<div class="outline-text-3" id="text-top-k-frequent-elementslink-medium">
<p>
Given an integer array <code>nums</code> and an integer <code>k</code>, return the =k=most frequent elements. You may return the answer in <b>any order</b>.
</p>

<p>
<b>Example 1:</b>
</p>

<p>
<b>Input:</b> nums = [1,1,1,2,2,3], k = 2
</p>

<p>
<b>Output:</b>[1,2]
</p>

<p>
<b>Example 2:</b>
</p>

<p>
<b>Input:</b> nums = [1], k = 1
</p>

<p>
<b>Output:</b>[1]
</p>

<p>
<b>Example 3:</b>
</p>

<p>
<b>Input:</b> nums = [1,2,1,2,1,2,3,1,3,2], k = 2
</p>

<p>
<b>Output:</b>[1,2]
</p>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 10⁵=</li>
<li><code>-10⁴ &lt;</code> nums[i] &lt;= 10⁴=</li>
<li><code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>.</li>
<li>It is <b>guaranteed</b> that the answer is <b>unique</b>.</li>
</ul>

<p>
<b>Follow up:</b> Your algorithm's time complexity must be better than <code>O(n log n)</code>, where n is the array's size.
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/top-k-frequent-elements/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);
    int k;
    LeetCodeIO::scan(cin, k);

    Solution *obj = new Solution();
    auto res = obj-&gt;topKFrequent(nums, k);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-wiggle-subsequencelink-medium" class="outline-3">
<h3 id="wiggle-subsequencelink-medium"><span class="section-number-3">8.104.</span> <a href="https://leetcode.com/problems/wiggle-subsequence/">376. Wiggle Subsequence</a> (Medium)</h3>
<div class="outline-text-3" id="text-wiggle-subsequencelink-medium">
<p>
A <b>wiggle sequence</b> is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.
</p>

<ul class="org-ul">
<li>For example, <code>[1, 7, 4, 9, 2, 5]</code> is a <b>wiggle sequence</b> because the differences <code>(6, -3, 5, -7, 3)</code> alternate between positive and negative.</li>
<li>In contrast, <code>[1, 4, 7, 2, 5]</code> and <code>[1, 7, 4, 5, 5]</code> are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.</li>
</ul>

<p>
A <b>subsequence</b> is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.
</p>

<p>
Given an integer array <code>nums</code>, return the length of the longest <b>wiggle subsequence</b> of <code>nums</code>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgb27ec83">
Input: nums = [1,7,4,9,2,5]
Output: 6
Explanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgbc4dbc3">
Input: nums = [1,17,5,10,13,15,10,5,16,8]
Output: 7
Explanation: There are several subsequences that achieve this length.
One is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org24b7bcf">
Input: nums = [1,2,3,4,5,6,7,8,9]
Output: 2
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 1000=</li>
<li><code>0 &lt;</code> nums[i] &lt;= 1000=</li>
</ul>

<p>
<b>Follow up:</b> Could you solve this in <code>O(n)</code> time?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/wiggle-subsequence/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;wiggleMaxLength(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-combination-sum-ivlink-medium" class="outline-3">
<h3 id="combination-sum-ivlink-medium"><span class="section-number-3">8.105.</span> <a href="https://leetcode.com/problems/combination-sum-iv/">377. Combination Sum IV</a> (Medium)</h3>
<div class="outline-text-3" id="text-combination-sum-ivlink-medium">
<p>
Given an array of <b>distinct</b> integers <code>nums</code> and a target integer <code>target</code>, return the number of possible combinations that add up to <code>target</code>.
</p>

<p>
The test cases are generated so that the answer can fit in a <b>32-bit</b> integer.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org90dccba">
Input: nums = [1,2,3], target = 4
Output: 7
Explanation:
The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
Note that different sequences are counted as different combinations.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org1e624a0">
Input: nums = [9], target = 3
Output: 0
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 200=</li>
<li><code>1 &lt;</code> nums[i] &lt;= 1000=</li>
<li>All the elements of <code>nums</code> are <b>unique</b>.</li>
<li><code>1 &lt;</code> target &lt;= 1000=</li>
</ul>

<p>
<b>Follow up:</b> What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/combination-sum-iv/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);
    int target;
    LeetCodeIO::scan(cin, target);

    Solution *obj = new Solution();
    auto res = obj-&gt;combinationSum4(nums, target);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-insert-delete-getrandom-o1link-medium" class="outline-3">
<h3 id="insert-delete-getrandom-o1link-medium"><span class="section-number-3">8.106.</span> <a href="https://leetcode.com/problems/insert-delete-getrandom-o1/">380. Insert Delete GetRandom O(1)</a> (Medium)</h3>
<div class="outline-text-3" id="text-insert-delete-getrandom-o1link-medium">
<p>
Implement the <code>RandomizedSet</code> class:
</p>

<ul class="org-ul">
<li><code>RandomizedSet()</code> Initializes the <code>RandomizedSet</code> object.</li>
<li><code>bool insert(int val)</code> Inserts an item <code>val</code> into the set if not present. Returns <code>true</code> if the item was not present, <code>false</code> otherwise.</li>
<li><code>bool remove(int val)</code> Removes an item <code>val</code> from the set if present. Returns <code>true</code> if the item was present, <code>false</code> otherwise.</li>
<li><code>int getRandom()</code> Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the <b>same probability</b> of being returned.</li>
</ul>

<p>
You must implement the functions of the class such that each function works in <b>average</b> <code>O(1)</code> time complexity.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orga9e22da">
Input
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]
Output
[null, true, false, true, 2, true, false, 2]

Explanation
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
randomizedSet.insert(2); // 2 was already in the set, so return false.
randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return
2.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>-2³¹ &lt;</code> val &lt;= 2³¹ - 1=</li>
<li>At most <code>2 *</code> <code>10⁵</code> calls will be made to <code>insert</code>, <code>remove</code>, and <code>getRandom</code>.</li>
<li>There will be <b>at least one</b> element in the data structure when <code>getRandom</code> is called.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/insert-delete-getrandom-o1/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class RandomizedSet {
public:
    RandomizedSet() {

    }

    bool insert(int val) {

    }

    bool remove(int val) {

    }

    int getRandom() {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;string&gt; method_names;
    LeetCodeIO::scan(cin, method_names);

    RandomizedSet *obj;
    const unordered_map&lt;string, function&lt;void()&gt;&gt; methods = {
        { "RandomizedSet", [&amp;]() {
            cin.ignore();
            obj = new RandomizedSet();
            out_stream &lt;&lt; "null,";
        } },
        { "insert", [&amp;]() {
            int val; LeetCodeIO::scan(cin, val); cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;insert(val)); out_stream &lt;&lt; ',';
        } },
        { "remove", [&amp;]() {
            int val; LeetCodeIO::scan(cin, val); cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;remove(val)); out_stream &lt;&lt; ',';
        } },
        { "getRandom", [&amp;]() {
            cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;getRandom()); out_stream &lt;&lt; ',';
        } },
    };
    cin &gt;&gt; ws;
    out_stream &lt;&lt; '[';
    for (auto &amp;&amp;method_name : method_names) {
        cin.ignore(2);
        methods.at(method_name)();
    }
    cin.ignore();
    out_stream.seekp(-1, ios_base::end); out_stream &lt;&lt; ']';
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-sum-of-left-leaveslink-easy" class="outline-3">
<h3 id="sum-of-left-leaveslink-easy"><span class="section-number-3">8.107.</span> <a href="https://leetcode.com/problems/sum-of-left-leaves/">404. Sum of Left Leaves</a> (Easy)</h3>
<div class="outline-text-3" id="text-sum-of-left-leaveslink-easy">
<p>
Given the <code>root</code> of a binary tree, return the sum of all left leaves.
</p>

<p>
A <b>leaf</b> is a node with no children. A <b>left leaf</b> is a leaf that is the left child of another node.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org2b549f4" class="figure">
<p><img src="../Leetcode/src/0404.sum-of-left-leaves/leftsum-tree.jpg" alt="leftsum-tree.jpg" />
</p>
</div>

<pre class="example" id="orgf009d10">
Input: root = [3,9,20,null,null,15,7]
Output: 24
Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org82a1399">
Input: root = [1]
Output: 0
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
<li><code>-1000 &lt;</code> Node.val &lt;= 1000=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/sum-of-left-leaves/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);

    Solution *obj = new Solution();
    auto res = obj-&gt;sumOfLeftLeaves(root);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-queue-reconstruction-by-heightlink-medium" class="outline-3">
<h3 id="queue-reconstruction-by-heightlink-medium"><span class="section-number-3">8.108.</span> <a href="https://leetcode.com/problems/queue-reconstruction-by-height/">406. Queue Reconstruction by Height</a> (Medium)</h3>
<div class="outline-text-3" id="text-queue-reconstruction-by-heightlink-medium">
<p>
You are given an array of people, <code>people</code>, which are the attributes of some people in a queue (not necessarily in order). Each <code>people[i] = [hᵢ, kᵢ]</code> represents the <code>iᵗʰ</code> person of height <code>hᵢ</code> with <b>exactly</b> <code>kᵢ</code> other people in front who have a height greater than or equal to <code>hᵢ</code>.
</p>

<p>
Reconstruct and return the queue that is represented by the input array <code>people</code>. The returned queue should be formatted as an array <code>queue</code>, where <code>queue[j] = [hⱼ, kⱼ]</code> is the attributes of the <code>jᵗʰ</code> person in the queue ( <code>queue[0]</code> is the person at the front of the queue).
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org901d24a">
Input: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
Explanation:
Person 0 has height 5 with no other people taller or the same height in front.
Person 1 has height 7 with no other people taller or the same height in front.
Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.
Person 3 has height 6 with one person taller or the same height in front, which is person 1.
Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2,
and 3.
Person 5 has height 7 with one person taller or the same height in front, which is person 1.
Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org6c9a372">
Input: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> people.length &lt;= 2000=</li>
<li><code>0 &lt;</code> hᵢ &lt;= 10⁶=</li>
<li><code>0 &lt;</code> kᵢ &lt; people.length=</li>
<li>It is guaranteed that the queue can be reconstructed.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/queue-reconstruction-by-height/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; people;
    LeetCodeIO::scan(cin, people);

    Solution *obj = new Solution();
    auto res = obj-&gt;reconstructQueue(people);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-longest-palindromelink-easy" class="outline-3">
<h3 id="longest-palindromelink-easy"><span class="section-number-3">8.109.</span> <a href="https://leetcode.com/problems/longest-palindrome/">409. Longest Palindrome</a> (Easy)</h3>
<div class="outline-text-3" id="text-longest-palindromelink-easy">
<p>
Given a string <code>s</code> which consists of lowercase or uppercase letters, return the length of the <b>longest palindrome</b> that can be built with those letters.
</p>

<p>
Letters are <b>case sensitive</b>, for example, <code>"Aa"</code> is not considered a palindrome.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org1f58f09">
Input: s = "abccccdd"
Output: 7
Explanation: One longest palindrome that can be built is "dccaccd", whose length is 7.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org9d7442d">
Input: s = "a"
Output: 1
Explanation: The longest palindrome that can be built is "a", whose length is 1.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> s.length &lt;= 2000=</li>
<li><code>s</code> consists of lowercase <b>and/or</b> uppercase English letters only.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/longest-palindrome/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int longestPalindrome(string s) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string s;
    LeetCodeIO::scan(cin, s);

    Solution *obj = new Solution();
    auto res = obj-&gt;longestPalindrome(s);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-arithmetic-sliceslink-medium" class="outline-3">
<h3 id="arithmetic-sliceslink-medium"><span class="section-number-3">8.110.</span> <a href="https://leetcode.com/problems/arithmetic-slices/">413. Arithmetic Slices</a> (Medium)</h3>
<div class="outline-text-3" id="text-arithmetic-sliceslink-medium">
<p>
An integer array is called arithmetic if it consists of <b>at least three elements</b> and if the difference between any two consecutive elements is the same.
</p>

<ul class="org-ul">
<li>For example, <code>[1,3,5,7,9]</code>, <code>[7,7,7,7]</code>, and <code>[3,-1,-5,-9]</code> are arithmetic sequences.</li>
</ul>

<p>
Given an integer array <code>nums</code>, return the number of arithmetic <b>subarrays</b> of <code>nums</code>.
</p>

<p>
A <b>subarray</b> is a contiguous subsequence of the array.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgcb53113">
Input: nums = [1,2,3,4]
Output: 3
Explanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgcf0bb98">
Input: nums = [1]
Output: 0
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 5000=</li>
<li><code>-1000 &lt;</code> nums[i] &lt;= 1000=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/arithmetic-slices/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;numberOfArithmeticSlices(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-partition-equal-subset-sumlink-medium" class="outline-3">
<h3 id="partition-equal-subset-sumlink-medium"><span class="section-number-3">8.111.</span> <a href="https://leetcode.com/problems/partition-equal-subset-sum/">416. Partition Equal Subset Sum</a> (Medium)</h3>
<div class="outline-text-3" id="text-partition-equal-subset-sumlink-medium">
<p>
Given an integer array <code>nums</code>, return <code>true=if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or =false</code> otherwise.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org15a628f">
Input: nums = [1,5,11,5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orge4a549d">
Input: nums = [1,2,3,5]
Output: false
Explanation: The array cannot be partitioned into equal sum subsets.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 200=</li>
<li><code>1 &lt;</code> nums[i] &lt;= 100=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/partition-equal-subset-sum/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool canPartition(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;canPartition(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-pacific-atlantic-water-flowlink-medium" class="outline-3">
<h3 id="pacific-atlantic-water-flowlink-medium"><span class="section-number-3">8.112.</span> <a href="https://leetcode.com/problems/pacific-atlantic-water-flow/">417. Pacific Atlantic Water Flow</a> (Medium)</h3>
<div class="outline-text-3" id="text-pacific-atlantic-water-flowlink-medium">
<p>
There is an <code>m x n</code> rectangular island that borders both the <b>Pacific Ocean</b> and <b>Atlantic Ocean</b>. The <b>Pacific Ocean</b> touches the island's left and top edges, and the <b>Atlantic Ocean</b> touches the island's right and bottom edges.
</p>

<p>
The island is partitioned into a grid of square cells. You are given an <code>m x n</code> integer matrix <code>heights</code> where <code>heights[r][c]</code> represents the <b>height above sea level</b> of the cell at coordinate <code>(r, c)</code>.
</p>

<p>
The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is <b>less than or equal to</b> the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.
</p>

<p>
Return a <b>2D list</b> of grid coordinates <code>result</code> where <code>result[i] = [rᵢ, cᵢ]</code> denotes that rain water can flow from cell <code>(rᵢ, cᵢ)</code> to <b>both</b> the Pacific and Atlantic oceans.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orgb28dd7d" class="figure">
<p><img src="../Leetcode/src/0417.pacific-atlantic-water-flow/waterflow-grid.jpg" alt="waterflow-grid.jpg" />
</p>
</div>

<pre class="example" id="org26b7256">
Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
Explanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:
[0,4]: [0,4] -&gt; Pacific Ocean
       [0,4] -&gt; Atlantic Ocean
[1,3]: [1,3] -&gt; [0,3] -&gt; Pacific Ocean
       [1,3] -&gt; [1,4] -&gt; Atlantic Ocean
[1,4]: [1,4] -&gt; [1,3] -&gt; [0,3] -&gt; Pacific Ocean
       [1,4] -&gt; Atlantic Ocean
[2,2]: [2,2] -&gt; [1,2] -&gt; [0,2] -&gt; Pacific Ocean
       [2,2] -&gt; [2,3] -&gt; [2,4] -&gt; Atlantic Ocean
[3,0]: [3,0] -&gt; Pacific Ocean
       [3,0] -&gt; [4,0] -&gt; Atlantic Ocean
[3,1]: [3,1] -&gt; [3,0] -&gt; Pacific Ocean
       [3,1] -&gt; [4,1] -&gt; Atlantic Ocean
[4,0]: [4,0] -&gt; Pacific Ocean
       [4,0] -&gt; Atlantic Ocean
Note that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgda3b126">
Input: heights = [[1]]
Output: [[0,0]]
Explanation: The water can flow from the only cell to the Pacific and Atlantic oceans.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>m =</code> heights.length=</li>
<li><code>n =</code> heights[r].length=</li>
<li><code>1 &lt;</code> m, n &lt;= 200=</li>
<li><code>0 &lt;</code> heights[r][c] &lt;= 10⁵=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/pacific-atlantic-water-flow/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; heights) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; heights;
    LeetCodeIO::scan(cin, heights);

    Solution *obj = new Solution();
    auto res = obj-&gt;pacificAtlantic(heights);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-all-oone-data-structurelink-hard" class="outline-3">
<h3 id="all-oone-data-structurelink-hard"><span class="section-number-3">8.113.</span> <a href="https://leetcode.com/problems/all-oone-data-structure/">432. All O`one Data Structure</a> (Hard)</h3>
<div class="outline-text-3" id="text-all-oone-data-structurelink-hard">
<p>
Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.
</p>

<p>
Implement the <code>AllOne</code> class:
</p>

<ul class="org-ul">
<li><code>AllOne()</code> Initializes the object of the data structure.</li>
<li><code>inc(String key)</code> Increments the count of the string <code>key</code> by <code>1</code>. If <code>key</code> does not exist in the data structure, insert it with count <code>1</code>.</li>
<li><code>dec(String key)</code> Decrements the count of the string <code>key</code> by <code>1</code>. If the count of <code>key</code> is <code>0</code> after the decrement, remove it from the data structure. It is guaranteed that <code>key</code> exists in the data structure before the decrement.</li>
<li><code>getMaxKey()</code> Returns one of the keys with the maximal count. If no element exists, return an empty string <code>""</code>.</li>
<li><code>getMinKey()</code> Returns one of the keys with the minimum count. If no element exists, return an empty string <code>""</code>.</li>
</ul>

<p>
<b>Note</b> that each function must run in <code>O(1)</code> average time complexity.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgbe9d141">
Input
["AllOne", "inc", "inc", "getMaxKey", "getMinKey", "inc", "getMaxKey", "getMinKey"]
[[], ["hello"], ["hello"], [], [], ["leet"], [], []]
Output
[null, null, null, "hello", "hello", null, "hello", "leet"]

Explanation
AllOne allOne = new AllOne();
allOne.inc("hello");
allOne.inc("hello");
allOne.getMaxKey(); // return "hello"
allOne.getMinKey(); // return "hello"
allOne.inc("leet");
allOne.getMaxKey(); // return "hello"
allOne.getMinKey(); // return "leet"
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> key.length &lt;= 10=</li>
<li><code>key</code> consists of lowercase English letters.</li>
<li>It is guaranteed that for each call to <code>dec</code>, <code>key</code> is existing in the data structure.</li>
<li>At most <code>5 * 10⁴</code> calls will be made to <code>inc</code>, <code>dec</code>, <code>getMaxKey</code>, and <code>getMinKey</code>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/all-oone-data-structure/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class AllOne {
public:
    AllOne() {

    }

    void inc(string key) {

    }

    void dec(string key) {

    }

    string getMaxKey() {

    }

    string getMinKey() {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;string&gt; method_names;
    LeetCodeIO::scan(cin, method_names);

    AllOne *obj;
    const unordered_map&lt;string, function&lt;void()&gt;&gt; methods = {
        { "AllOne", [&amp;]() {
            cin.ignore();
            obj = new AllOne();
            out_stream &lt;&lt; "null,";
        } },
        { "inc", [&amp;]() {
            string key; LeetCodeIO::scan(cin, key); cin.ignore();
            obj-&gt;inc(key);
            out_stream &lt;&lt; "null,";
        } },
        { "dec", [&amp;]() {
            string key; LeetCodeIO::scan(cin, key); cin.ignore();
            obj-&gt;dec(key);
            out_stream &lt;&lt; "null,";
        } },
        { "getMaxKey", [&amp;]() {
            cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;getMaxKey()); out_stream &lt;&lt; ',';
        } },
        { "getMinKey", [&amp;]() {
            cin.ignore();
            LeetCodeIO::print(out_stream, obj-&gt;getMinKey()); out_stream &lt;&lt; ',';
        } },
    };
    cin &gt;&gt; ws;
    out_stream &lt;&lt; '[';
    for (auto &amp;&amp;method_name : method_names) {
        cin.ignore(2);
        methods.at(method_name)();
    }
    cin.ignore();
    out_stream.seekp(-1, ios_base::end); out_stream &lt;&lt; ']';
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-non-overlapping-intervalslink-medium" class="outline-3">
<h3 id="non-overlapping-intervalslink-medium"><span class="section-number-3">8.114.</span> <a href="https://leetcode.com/problems/non-overlapping-intervals/">435. Non-overlapping Intervals</a> (Medium)</h3>
<div class="outline-text-3" id="text-non-overlapping-intervalslink-medium">
<p>
Given an array of intervals <code>intervals</code> where <code>intervals[i] = [startᵢ, endᵢ]</code>, return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.
</p>

<p>
<b>Note</b> that intervals which only touch at a point are <b>non-overlapping</b>. For example, <code>[1, 2]</code> and <code>[2, 3]</code> are non-overlapping.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgb0808ce">
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orge81c58f">
Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orgc713824">
Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> intervals.length &lt;= 10⁵=</li>
<li><code>intervals[i].length =</code> 2=</li>
<li><code>-5 * 10⁴ &lt;</code> startᵢ &lt; endᵢ &lt;= 5 * 10⁴=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/non-overlapping-intervals/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; intervals;
    LeetCodeIO::scan(cin, intervals);

    Solution *obj = new Solution();
    auto res = obj-&gt;eraseOverlapIntervals(intervals);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-path-sum-iiilink-medium" class="outline-3">
<h3 id="path-sum-iiilink-medium"><span class="section-number-3">8.115.</span> <a href="https://leetcode.com/problems/path-sum-iii/">437. Path Sum III</a> (Medium)</h3>
<div class="outline-text-3" id="text-path-sum-iiilink-medium">
<p>
Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return the number of paths where the sum of the values along the path equals <code>targetSum</code>.
</p>

<p>
The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org3745b74" class="figure">
<p><img src="../Leetcode/src/0437.path-sum-iii/pathsum3-1-tree.jpg" alt="pathsum3-1-tree.jpg" />
</p>
</div>

<pre class="example" id="org9893242">
Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
Output: 3
Explanation: The paths that sum to 8 are shown.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org1392bfb">
Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
Output: 3
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[0, 1000]</code>.</li>
<li><code>-10⁹ &lt;</code> Node.val &lt;= 10⁹=</li>
<li><code>-1000 &lt;</code> targetSum &lt;= 1000=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/path-sum-iii/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int pathSum(TreeNode* root, int targetSum) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);
    int targetSum;
    LeetCodeIO::scan(cin, targetSum);

    Solution *obj = new Solution();
    auto res = obj-&gt;pathSum(root, targetSum);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-find-all-numbers-disappeared-in-an-arraylink-easy" class="outline-3">
<h3 id="find-all-numbers-disappeared-in-an-arraylink-easy"><span class="section-number-3">8.116.</span> <a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/">448. Find All Numbers Disappeared in an Array</a> (Easy)</h3>
<div class="outline-text-3" id="text-find-all-numbers-disappeared-in-an-arraylink-easy">
<p>
Given an array <code>nums</code> of <code>n</code> integers where <code>nums[i]</code> is in the range <code>[1, n]</code>, return an array of all the integers in the range <code>[1, n]=that do not appear in =nums</code>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgd0a7871">
Input: nums = [4,3,2,7,8,2,3,1]
Output: [5,6]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgf7c2bb5">
Input: nums = [1,1]
Output: [2]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>n =</code> nums.length=</li>
<li><code>1 &lt;</code> n &lt;= 10⁵=</li>
<li><code>1 &lt;</code> nums[i] &lt;= n=</li>
</ul>

<p>
<b>Follow up:</b> Could you do it without extra space and in <code>O(n)</code> runtime? You may assume the returned list does not count as extra space.
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;findDisappearedNumbers(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-delete-node-in-a-bstlink-medium" class="outline-3">
<h3 id="delete-node-in-a-bstlink-medium"><span class="section-number-3">8.117.</span> <a href="https://leetcode.com/problems/delete-node-in-a-bst/">450. Delete Node in a BST</a> (Medium)</h3>
<div class="outline-text-3" id="text-delete-node-in-a-bstlink-medium">
<p>
Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the <b>root node reference</b> (possibly updated) of the BST.
</p>

<p>
Basically, the deletion can be divided into two stages:
</p>

<ol class="org-ol">
<li>Search for a node to remove.</li>
<li>If the node is found, delete the node.</li>
</ol>

<p>
<b>Example 1:</b>
</p>


<div id="orgbc6533c" class="figure">
<p><img src="../Leetcode/src/0450.delete-node-in-a-bst/del_node_1.jpg" alt="del_node_1.jpg" />
</p>
</div>

<pre class="example" id="org01373de">
Input: root = [5,3,6,2,4,null,7], key = 3
Output: [5,4,6,2,null,null,7]
Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.
One valid answer is [5,4,6,2,null,null,7], shown in the above BST.
Please notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orga256a60">
Input: root = [5,3,6,2,4,null,7], key = 0
Output: [5,3,6,2,4,null,7]
Explanation: The tree does not contain a node with value = 0.
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org2b659ae">
Input: root = [], key = 0
Output: []
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[0, 10⁴]</code>.</li>
<li><code>-10⁵ &lt;</code> Node.val &lt;= 10⁵=</li>
<li>Each node has a <b>unique</b> value.</li>
<li><code>root</code> is a valid binary search tree.</li>
<li><code>-10⁵ &lt;</code> key &lt;= 10⁵=</li>
</ul>

<p>
<b>Follow up:</b> Could you solve it with time complexity <code>O(height of tree)</code>?
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/delete-node-in-a-bst/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);
    int key;
    LeetCodeIO::scan(cin, key);

    Solution *obj = new Solution();
    auto res = obj-&gt;deleteNode(root, key);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-sort-characters-by-frequencylink-medium" class="outline-3">
<h3 id="sort-characters-by-frequencylink-medium"><span class="section-number-3">8.118.</span> <a href="https://leetcode.com/problems/sort-characters-by-frequency/">451. Sort Characters By Frequency</a> (Medium)</h3>
<div class="outline-text-3" id="text-sort-characters-by-frequencylink-medium">
<p>
Given a string <code>s</code>, sort it in <b>decreasing order</b> based on the <b>frequency</b> of the characters. The <b>frequency</b> of a character is the number of times it appears in the string.
</p>

<p>
Return the sorted string. If there are multiple answers, return any of them.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org63350eb">
Input: s = "tree"
Output: "eert"
Explanation: 'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgd1a2b33">
Input: s = "cccaaa"
Output: "aaaccc"
Explanation: Both 'c' and 'a' appear three times, so both "cccaaa" and "aaaccc" are valid answers.
Note that "cacaca" is incorrect, as the same characters must be together.
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orgb663030">
Input: s = "Aabb"
Output: "bbAa"
Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect.
Note that 'A' and 'a' are treated as two different characters.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> s.length &lt;= 5 * 10⁵=</li>
<li><code>s</code> consists of uppercase and lowercase English letters and digits.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/sort-characters-by-frequency/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    string frequencySort(string s) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string s;
    LeetCodeIO::scan(cin, s);

    Solution *obj = new Solution();
    auto res = obj-&gt;frequencySort(s);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-minimum-number-of-arrows-to-burst-balloonslink-medium" class="outline-3">
<h3 id="minimum-number-of-arrows-to-burst-balloonslink-medium"><span class="section-number-3">8.119.</span> <a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. Minimum Number of Arrows to Burst Balloons</a> (Medium)</h3>
<div class="outline-text-3" id="text-minimum-number-of-arrows-to-burst-balloonslink-medium">
<p>
There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array <code>points</code> where <code>points[i] = [xₛₜₐᵣₜ, xₑₙd]</code> denotes a balloon whose <b>horizontal diameter</b> stretches between <code>xₛₜₐᵣₜ</code> and <code>xₑₙd</code>. You do not know the exact y- coordinates of the balloons.
</p>

<p>
Arrows can be shot up <b>directly vertically</b> (in the positive y-direction) from different points along the x-axis. A balloon with <code>xₛₜₐᵣₜ</code> and <code>xₑₙd</code> is <b>burst</b> by an arrow shot at <code>x</code> if <code>xₛₜₐᵣₜ &lt;</code> x &lt;= xₑₙd=. There is <b>no limit</b> to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.
</p>

<p>
Given the array <code>points</code>, return the <b>minimum</b> number of arrows that must be shot to burst all balloons.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org7a4b04a">
Input: points = [[10,16],[2,8],[1,6],[7,12]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].
- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org2aa006c">
Input: points = [[1,2],[3,4],[5,6],[7,8]]
Output: 4
Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows.
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orgbfaa7bc">
Input: points = [[1,2],[2,3],[3,4],[4,5]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].
- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> points.length &lt;= 10⁵=</li>
<li><code>points[i].length =</code> 2=</li>
<li><code>-2³¹ &lt;</code> xₛₜₐᵣₜ &lt; xₑₙd &lt;= 2³¹ - 1=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; points;
    LeetCodeIO::scan(cin, points);

    Solution *obj = new Solution();
    auto res = obj-&gt;findMinArrowShots(points);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-assign-cookieslink-easy" class="outline-3">
<h3 id="assign-cookieslink-easy"><span class="section-number-3">8.120.</span> <a href="https://leetcode.com/problems/assign-cookies/">455. Assign Cookies</a> (Easy)</h3>
<div class="outline-text-3" id="text-assign-cookieslink-easy">
<p>
Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.
</p>

<p>
Each child <code>i</code> has a greed factor <code>g[i]</code>, which is the minimum size of a cookie that the child will be content with; and each cookie <code>j</code> has a size <code>s[j]</code>. If <code>s[j] &gt;</code> g[i]=, we can assign the cookie <code>j</code> to the child <code>i</code>, and the child <code>i</code> will be content. Your goal is to maximize the number of your content children and output the maximum number.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org7c209af">
Input: g = [1,2,3], s = [1,1]
Output: 1
Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.
And even though you have 2 cookies, since their size is both 1, you could only make the child whose
greed factor is 1 content.
You need to output 1.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org3c4a26c">
Input: g = [1,2], s = [1,2,3]
Output: 2
Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.
You have 3 cookies and their sizes are big enough to gratify all of the children,
You need to output 2.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> g.length &lt;= 3 * 10⁴=</li>
<li><code>0 &lt;</code> s.length &lt;= 3 * 10⁴=</li>
<li><code>1 &lt;</code> g[i], s[j] &lt;= 2³¹ - 1=</li>
</ul>

<p>
<b>Note:</b> This question is the same as <a href="https://leetcode.com/problems/maximum-matching-of-players-with-trainers/description/">2410: Maximum Matching of Players With Trainers.</a>
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/assign-cookies/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; g;
    LeetCodeIO::scan(cin, g);
    vector&lt;int&gt; s;
    LeetCodeIO::scan(cin, s);

    Solution *obj = new Solution();
    auto res = obj-&gt;findContentChildren(g, s);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-hamming-distancelink-easy" class="outline-3">
<h3 id="hamming-distancelink-easy"><span class="section-number-3">8.121.</span> <a href="https://leetcode.com/problems/hamming-distance/">461. Hamming Distance</a> (Easy)</h3>
<div class="outline-text-3" id="text-hamming-distancelink-easy">
<p>
The <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.
</p>

<p>
Given two integers <code>x</code> and <code>y</code>, return the <b>Hamming distance</b> between them.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org23e64d3">
Input: x = 1, y = 4
Output: 2
Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
The above arrows point to positions where the corresponding bits are different.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org4c0e17e">
Input: x = 3, y = 1
Output: 1
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>0 &lt;</code> x, y &lt;= 2³¹ - 1=</li>
</ul>

<p>
<b>Note:</b> This question is the same as <a href="https://leetcode.com/problems/minimum-bit-flips-to-convert-number/description/">2220: Minimum Bit Flips to Convert Number.</a>
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/hamming-distance/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int hammingDistance(int x, int y) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int x;
    LeetCodeIO::scan(cin, x);
    int y;
    LeetCodeIO::scan(cin, y);

    Solution *obj = new Solution();
    auto res = obj-&gt;hammingDistance(x, y);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-minimum-moves-to-equal-array-elements-iilink-medium" class="outline-3">
<h3 id="minimum-moves-to-equal-array-elements-iilink-medium"><span class="section-number-3">8.122.</span> <a href="https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/">462. Minimum Moves to Equal Array Elements II</a> (Medium)</h3>
<div class="outline-text-3" id="text-minimum-moves-to-equal-array-elements-iilink-medium">
<p>
Given an integer array <code>nums</code> of size <code>n</code>, return the minimum number of moves required to make all array elements equal.
</p>

<p>
In one move, you can increment or decrement an element of the array by <code>1</code>.
</p>

<p>
Test cases are designed so that the answer will fit in a <b>32-bit</b> integer.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org9091494">
Input: nums = [1,2,3]
Output: 2
Explanation:
Only two moves are needed (remember each move increments or decrements one element):
[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgc62c380">
Input: nums = [1,10,2,9]
Output: 16
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>n =</code> nums.length=</li>
<li><code>1 &lt;</code> nums.length &lt;= 10⁵=</li>
<li><code>-10⁹ &lt;</code> nums[i] &lt;= 10⁹=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int minMoves2(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;minMoves2(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-ones-and-zeroeslink-medium" class="outline-3">
<h3 id="ones-and-zeroeslink-medium"><span class="section-number-3">8.123.</span> <a href="https://leetcode.com/problems/ones-and-zeroes/">474. Ones and Zeroes</a> (Medium)</h3>
<div class="outline-text-3" id="text-ones-and-zeroeslink-medium">
<p>
You are given an array of binary strings <code>strs</code> and two integers <code>m</code> and <code>n</code>.
</p>

<p>
Return the size of the largest subset of <code>strs</code> such that there are <b>at most</b> <code>m</code> <code>0</code>'s and <code>n</code> <code>1</code>'s in the subset.
</p>

<p>
A set <code>x</code> is a <b>subset</b> of a set <code>y</code> if all elements of <code>x</code> are also elements of <code>y</code>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org6d97594">
Input: strs = ["10","0001","111001","1","0"], m = 5, n = 3
Output: 4
Explanation: The largest subset with at most 5 0's and 3 1's is {"10", "0001", "1", "0"}, so the
answer is 4.
Other valid but smaller subsets include {"0001", "1"} and {"10", "1", "0"}.
{"111001"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgfc54bbf">
Input: strs = ["10","0","1"], m = 1, n = 1
Output: 2
Explanation: The largest subset is {"0", "1"}, so the answer is 2.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> strs.length &lt;= 600=</li>
<li><code>1 &lt;</code> strs[i].length &lt;= 100=</li>
<li><code>strs[i]</code> consists only of digits <code>'0'</code> and <code>'1'</code>.</li>
<li><code>1 &lt;</code> m, n &lt;= 100=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/ones-and-zeroes/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;string&gt; strs;
    LeetCodeIO::scan(cin, strs);
    int m;
    LeetCodeIO::scan(cin, m);
    int n;
    LeetCodeIO::scan(cin, n);

    Solution *obj = new Solution();
    auto res = obj-&gt;findMaxForm(strs, m, n);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-number-complementlink-easy" class="outline-3">
<h3 id="number-complementlink-easy"><span class="section-number-3">8.124.</span> <a href="https://leetcode.com/problems/number-complement/">476. Number Complement</a> (Easy)</h3>
<div class="outline-text-3" id="text-number-complementlink-easy">
<p>
The <b>complement</b> of an integer is the integer you get when you flip all the <code>0</code>'s to <code>1</code>'s and all the <code>1</code>'s to <code>0</code>'s in its binary representation.
</p>

<ul class="org-ul">
<li>For example, The integer <code>5</code> is <code>"101"</code> in binary and its <b>complement</b> is <code>"010"</code> which is the integer <code>2</code>.</li>
</ul>

<p>
Given an integer <code>num</code>, return its complement.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org6409088">
Input: num = 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is
010. So you need to output 2.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org72a7e28">
Input: num = 1
Output: 0
Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So
you need to output 0.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> num &lt; 2³¹=</li>
</ul>

<p>
<b>Note:</b> This question is the same as 1009: <a href="https://leetcode.com/problems/complement-of-base-10-integer/">https://leetcode.com/problems/complement-of-base-10- integer/</a>
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/number-complement/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int findComplement(int num) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int num;
    LeetCodeIO::scan(cin, num);

    Solution *obj = new Solution();
    auto res = obj-&gt;findComplement(num);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-target-sumlink-medium" class="outline-3">
<h3 id="target-sumlink-medium"><span class="section-number-3">8.125.</span> <a href="https://leetcode.com/problems/target-sum/">494. Target Sum</a> (Medium)</h3>
<div class="outline-text-3" id="text-target-sumlink-medium">
<p>
You are given an integer array <code>nums</code> and an integer <code>target</code>.
</p>

<p>
You want to build an <b>expression</b> out of nums by adding one of the symbols <code>'+'</code> and <code>'-'</code> before each integer in nums and then concatenate all the integers.
</p>

<ul class="org-ul">
<li>For example, if <code>nums = [2, 1]</code>, you can add a <code>'+'</code> before <code>2</code> and a <code>'-'</code> before <code>1</code> and concatenate them to build the expression <code>"+2-1"</code>.</li>
</ul>

<p>
Return the number of different <b>expressions</b> that you can build, which evaluates to <code>target</code>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org8c2f8a3">
Input: nums = [1,1,1,1,1], target = 3
Output: 5
Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgc0d80db">
Input: nums = [1], target = 1
Output: 1
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 20=</li>
<li><code>0 &lt;</code> nums[i] &lt;= 1000=</li>
<li><code>0 &lt;</code> sum(nums[i]) &lt;= 1000=</li>
<li><code>-1000 &lt;</code> target &lt;= 1000=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/target-sum/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);
    int target;
    LeetCodeIO::scan(cin, target);

    Solution *obj = new Solution();
    auto res = obj-&gt;findTargetSumWays(nums, target);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-next-greater-element-iilink-medium" class="outline-3">
<h3 id="next-greater-element-iilink-medium"><span class="section-number-3">8.126.</span> <a href="https://leetcode.com/problems/next-greater-element-ii/">503. Next Greater Element II</a> (Medium)</h3>
<div class="outline-text-3" id="text-next-greater-element-iilink-medium">
<p>
Given a circular integer array <code>nums</code> (i.e., the next element of <code>nums[nums.length - 1]</code> is <code>nums[0]</code>), return the <b>next greater number</b> for every element in <code>nums</code>.
</p>

<p>
The <b>next greater number</b> of a number <code>x</code> is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return <code>-1</code> for this number.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orge0b3357">
Input: nums = [1,2,1]
Output: [2,-1,2]
Explanation: The first 1's next greater number is 2;
The number 2 can't find next greater number.
The second 1's next greater number needs to search circularly, which is also 2.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orga077086">
Input: nums = [1,2,3,4,3]
Output: [2,3,4,-1,4]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 10⁴=</li>
<li><code>-10⁹ &lt;</code> nums[i] &lt;= 10⁹=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/next-greater-element-ii/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;nextGreaterElements(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-find-bottom-left-tree-valuelink-medium" class="outline-3">
<h3 id="find-bottom-left-tree-valuelink-medium"><span class="section-number-3">8.127.</span> <a href="https://leetcode.com/problems/find-bottom-left-tree-value/">513. Find Bottom Left Tree Value</a> (Medium)</h3>
<div class="outline-text-3" id="text-find-bottom-left-tree-valuelink-medium">
<p>
Given the <code>root</code> of a binary tree, return the leftmost value in the last row of the tree.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org8fc7c59" class="figure">
<p><img src="../Leetcode/src/0513.find-bottom-left-tree-value/tree1.jpg" alt="tree1.jpg" />
</p>
</div>

<pre class="example" id="org5c0e7fa">
Input: root = [2,1,3]
Output: 1
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org0661c88" class="figure">
<p><img src="../Leetcode/src/0513.find-bottom-left-tree-value/tree2.jpg" alt="tree2.jpg" />
</p>
</div>

<pre class="example" id="org7c123fd">
Input: root = [1,2,3,4,null,5,6,null,null,7]
Output: 7
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[1, 10⁴]</code>.</li>
<li><code>-2³¹ &lt;</code> Node.val &lt;= 2³¹ - 1=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/find-bottom-left-tree-value/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);

    Solution *obj = new Solution();
    auto res = obj-&gt;findBottomLeftValue(root);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-minimum-absolute-difference-in-bstlink-easy" class="outline-3">
<h3 id="minimum-absolute-difference-in-bstlink-easy"><span class="section-number-3">8.128.</span> <a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/">530. Minimum Absolute Difference in BST</a> (Easy)</h3>
<div class="outline-text-3" id="text-minimum-absolute-difference-in-bstlink-easy">
<p>
Given the <code>root</code> of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org3d08ad5" class="figure">
<p><img src="../Leetcode/src/0530.minimum-absolute-difference-in-bst/bst1.jpg" alt="bst1.jpg" />
</p>
</div>

<pre class="example" id="org7b0e65e">
Input: root = [4,2,6,1,3]
Output: 1
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org667433b" class="figure">
<p><img src="../Leetcode/src/0530.minimum-absolute-difference-in-bst/bst2.jpg" alt="bst2.jpg" />
</p>
</div>

<pre class="example" id="org2edeebd">
Input: root = [1,0,48,null,null,12,49]
Output: 1
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[2, 10⁴]</code>.</li>
<li><code>0 &lt;</code> Node.val &lt;= 10⁵=</li>
</ul>

<p>
<b>Note:</b> This question is the same as 783: <a href="https://leetcode.com/problems/minimum-distance-between-bst-nodes/">https://leetcode.com/problems/minimum-distance-between-bst- nodes/</a>
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/minimum-absolute-difference-in-bst/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int getMinimumDifference(TreeNode* root) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);

    Solution *obj = new Solution();
    auto res = obj-&gt;getMinimumDifference(root);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-convert-bst-to-greater-treelink-medium" class="outline-3">
<h3 id="convert-bst-to-greater-treelink-medium"><span class="section-number-3">8.129.</span> <a href="https://leetcode.com/problems/convert-bst-to-greater-tree/">538. Convert BST to Greater Tree</a> (Medium)</h3>
<div class="outline-text-3" id="text-convert-bst-to-greater-treelink-medium">
<p>
Given the <code>root</code> of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.
</p>

<p>
As a reminder, a binary search tree is a tree that satisfies these constraints:
</p>

<ul class="org-ul">
<li>The left subtree of a node contains only nodes with keys <b>less than</b> the node's key.</li>
<li>The right subtree of a node contains only nodes with keys <b>greater than</b> the node's key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>

<p>
<b>Example 1:</b>
</p>


<div id="org9cb1015" class="figure">
<p><img src="../Leetcode/src/0538.convert-bst-to-greater-tree/tree.png" alt="tree.png" />
</p>
</div>

<pre class="example" id="org95fc270">
Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgf95d469">
Input: root = [0,null,1]
Output: [1,null,1]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[0, 10⁴]</code>.</li>
<li><code>-10⁴ &lt;</code> Node.val &lt;= 10⁴=</li>
<li>All the values in the tree are <b>unique</b>.</li>
<li><code>root</code> is guaranteed to be a valid binary search tree.</li>
</ul>

<p>
<b>Note:</b> This question is the same as 1038: <a href="https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode.com/problems/binary-search-tree-to- greater-sum-tree/</a>
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/convert-bst-to-greater-tree/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    TreeNode* convertBST(TreeNode* root) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);

    Solution *obj = new Solution();
    auto res = obj-&gt;convertBST(root);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-single-element-in-a-sorted-arraylink-medium" class="outline-3">
<h3 id="single-element-in-a-sorted-arraylink-medium"><span class="section-number-3">8.130.</span> <a href="https://leetcode.com/problems/single-element-in-a-sorted-array/">540. Single Element in a Sorted Array</a> (Medium)</h3>
<div class="outline-text-3" id="text-single-element-in-a-sorted-arraylink-medium">
<p>
You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.
</p>

<p>
Return the single element that appears only once.
</p>

<p>
Your solution must run in <code>O(log n)</code> time and <code>O(1)</code> space.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org69520b9">
Input: nums = [1,1,2,3,3,4,4,8,8]
Output: 2
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orge0c8cf0">
Input: nums = [3,3,7,7,10,11,11]
Output: 10
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 10⁵=</li>
<li><code>0 &lt;</code> nums[i] &lt;= 10⁵=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/single-element-in-a-sorted-array/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int singleNonDuplicate(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;singleNonDuplicate(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-matrixlink-medium" class="outline-3">
<h3 id="matrixlink-medium"><span class="section-number-3">8.131.</span> <a href="https://leetcode.com/problems/01-matrix/">542. 01 Matrix</a> (Medium)</h3>
<div class="outline-text-3" id="text-matrixlink-medium">
<p>
Given an <code>m x n</code> binary matrix <code>mat</code>, return the distance of the nearest <code>0</code> for each cell.
</p>

<p>
The distance between two cells sharing a common edge is <code>1</code>.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org1a5ddaa" class="figure">
<p><img src="../Leetcode/src/0542.01-matrix/01-1-grid.jpg" alt="01-1-grid.jpg" />
</p>
</div>

<pre class="example" id="orgbc9973c">
Input: mat = [[0,0,0],[0,1,0],[0,0,0]]
Output: [[0,0,0],[0,1,0],[0,0,0]]
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="orgc942bcf" class="figure">
<p><img src="../Leetcode/src/0542.01-matrix/01-2-grid.jpg" alt="01-2-grid.jpg" />
</p>
</div>

<pre class="example" id="orge456bc5">
Input: mat = [[0,0,0],[0,1,0],[1,1,1]]
Output: [[0,0,0],[0,1,0],[1,2,1]]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>m =</code> mat.length=</li>
<li><code>n =</code> mat[i].length=</li>
<li><code>1 &lt;</code> m, n &lt;= 10⁴=</li>
<li><code>1 &lt;</code> m * n &lt;= 10⁴=</li>
<li><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
<li>There is at least one <code>0</code> in <code>mat</code>.</li>
</ul>

<p>
<b>Note:</b> This question is the same as 1765: <a href="https://leetcode.com/problems/map-of-highest-peak/description/">https://leetcode.com/problems/map-of-highest- peak/</a>
</p>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/01-matrix/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; mat) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; mat;
    LeetCodeIO::scan(cin, mat);

    Solution *obj = new Solution();
    auto res = obj-&gt;updateMatrix(mat);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-diameter-of-binary-treelink-easy" class="outline-3">
<h3 id="diameter-of-binary-treelink-easy"><span class="section-number-3">8.132.</span> <a href="https://leetcode.com/problems/diameter-of-binary-tree/">543. Diameter of Binary Tree</a> (Easy)</h3>
<div class="outline-text-3" id="text-diameter-of-binary-treelink-easy">
<p>
Given the <code>root</code> of a binary tree, return the length of the <b>diameter</b> of the tree.
</p>

<p>
The <b>diameter</b> of a binary tree is the <b>length</b> of the longest path between any two nodes in a tree. This path may or may not pass through the <code>root</code>.
</p>

<p>
The <b>length</b> of a path between two nodes is represented by the number of edges between them.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org9b3c055" class="figure">
<p><img src="../Leetcode/src/0543.diameter-of-binary-tree/diamtree.jpg" alt="diamtree.jpg" />
</p>
</div>

<pre class="example" id="org758ff69">
Input: root = [1,2,3,4,5]
Output: 3
Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org3a30064">
Input: root = [1,2]
Output: 1
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[1, 10⁴]</code>.</li>
<li><code>-100 &lt;</code> Node.val &lt;= 100=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/diameter-of-binary-tree/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);

    Solution *obj = new Solution();
    auto res = obj-&gt;diameterOfBinaryTree(root);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-number-of-provinceslink-medium" class="outline-3">
<h3 id="number-of-provinceslink-medium"><span class="section-number-3">8.133.</span> <a href="https://leetcode.com/problems/number-of-provinces/">547. Number of Provinces</a> (Medium)</h3>
<div class="outline-text-3" id="text-number-of-provinceslink-medium">
<p>
There are <code>n</code> cities. Some of them are connected, while some are not. If city <code>a</code> is connected directly with city <code>b</code>, and city <code>b</code> is connected directly with city <code>c</code>, then city <code>a</code> is connected indirectly with city <code>c</code>.
</p>

<p>
A <b>province</b> is a group of directly or indirectly connected cities and no other cities outside of the group.
</p>

<p>
You are given an <code>n x n</code> matrix <code>isConnected</code> where <code>isConnected[i][j] = 1</code> if the <code>iᵗʰ</code> city and the <code>jᵗʰ</code> city are directly connected, and <code>isConnected[i][j] = 0</code> otherwise.
</p>

<p>
Return the total number of <b>provinces</b>.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orgad363c9" class="figure">
<p><img src="../Leetcode/src/0547.number-of-provinces/graph1.jpg" alt="graph1.jpg" />
</p>
</div>

<pre class="example" id="org7204cd6">
Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]
Output: 2
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org1623910" class="figure">
<p><img src="../Leetcode/src/0547.number-of-provinces/graph2.jpg" alt="graph2.jpg" />
</p>
</div>

<pre class="example" id="org37a4e3e">
Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]
Output: 3
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> n &lt;= 200=</li>
<li><code>n =</code> isConnected.length=</li>
<li><code>n =</code> isConnected[i].length=</li>
<li><code>isConnected[i][j]</code> is <code>1</code> or <code>0</code>.</li>
<li><code>isConnected[i][i] =</code> 1=</li>
<li><code>isConnected[i][j] =</code> isConnected[j][i]=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/number-of-provinces/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; isConnected;
    LeetCodeIO::scan(cin, isConnected);

    Solution *obj = new Solution();
    auto res = obj-&gt;findCircleNum(isConnected);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-reshape-the-matrixlink-easy" class="outline-3">
<h3 id="reshape-the-matrixlink-easy"><span class="section-number-3">8.134.</span> <a href="https://leetcode.com/problems/reshape-the-matrix/">566. Reshape the Matrix</a> (Easy)</h3>
<div class="outline-text-3" id="text-reshape-the-matrixlink-easy">
<p>
In MATLAB, there is a handy function called <code>reshape</code> which can reshape an <code>m x n</code> matrix into a new one with a different size <code>r x c</code> keeping its original data.
</p>

<p>
You are given an <code>m x n</code> matrix <code>mat</code> and two integers <code>r</code> and <code>c</code> representing the number of rows and the number of columns of the wanted reshaped matrix.
</p>

<p>
The reshaped matrix should be filled with all the elements of the original matrix in the same row- traversing order as they were.
</p>

<p>
If the <code>reshape</code> operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org92b7e42" class="figure">
<p><img src="../Leetcode/src/0566.reshape-the-matrix/reshape1-grid.jpg" alt="reshape1-grid.jpg" />
</p>
</div>

<pre class="example" id="org8b49f85">
Input: mat = [[1,2],[3,4]], r = 1, c = 4
Output: [[1,2,3,4]]
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="orge10b435" class="figure">
<p><img src="../Leetcode/src/0566.reshape-the-matrix/reshape2-grid.jpg" alt="reshape2-grid.jpg" />
</p>
</div>

<pre class="example" id="org39223b0">
Input: mat = [[1,2],[3,4]], r = 2, c = 4
Output: [[1,2],[3,4]]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>m =</code> mat.length=</li>
<li><code>n =</code> mat[i].length=</li>
<li><code>1 &lt;</code> m, n &lt;= 100=</li>
<li><code>-1000 &lt;</code> mat[i][j] &lt;= 1000=</li>
<li><code>1 &lt;</code> r, c &lt;= 300=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/reshape-the-matrix/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int r, int c) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; mat;
    LeetCodeIO::scan(cin, mat);
    int r;
    LeetCodeIO::scan(cin, r);
    int c;
    LeetCodeIO::scan(cin, c);

    Solution *obj = new Solution();
    auto res = obj-&gt;matrixReshape(mat, r, c);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-subtree-of-another-treelink-easy" class="outline-3">
<h3 id="subtree-of-another-treelink-easy"><span class="section-number-3">8.135.</span> <a href="https://leetcode.com/problems/subtree-of-another-tree/">572. Subtree of Another Tree</a> (Easy)</h3>
<div class="outline-text-3" id="text-subtree-of-another-treelink-easy">
<p>
Given the roots of two binary trees <code>root</code> and <code>subRoot</code>, return <code>true</code> if there is a subtree of <code>root</code> with the same structure and node values of <code>subRoot</code> and <code>false</code> otherwise.
</p>

<p>
A subtree of a binary tree <code>tree</code> is a tree that consists of a node in <code>tree</code> and all of this node's descendants. The tree <code>tree</code> could also be considered as a subtree of itself.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orgbd2de82" class="figure">
<p><img src="../Leetcode/src/0572.subtree-of-another-tree/subtree1-tree.jpg" alt="subtree1-tree.jpg" />
</p>
</div>

<pre class="example" id="org804d1c2">
Input: root = [3,4,5,1,2], subRoot = [4,1,2]
Output: true
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="orgd54e93f" class="figure">
<p><img src="../Leetcode/src/0572.subtree-of-another-tree/subtree2-tree.jpg" alt="subtree2-tree.jpg" />
</p>
</div>

<pre class="example" id="org7118300">
Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
Output: false
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the <code>root</code> tree is in the range <code>[1, 2000]</code>.</li>
<li>The number of nodes in the <code>subRoot</code> tree is in the range <code>[1, 1000]</code>.</li>
<li><code>-10⁴ &lt;</code> root.val &lt;= 10⁴=</li>
<li><code>-10⁴ &lt;</code> subRoot.val &lt;= 10⁴=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/subtree-of-another-tree/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);
    TreeNode* subRoot;
    LeetCodeIO::scan(cin, subRoot);

    Solution *obj = new Solution();
    auto res = obj-&gt;isSubtree(root, subRoot);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-delete-operation-for-two-stringslink-medium" class="outline-3">
<h3 id="delete-operation-for-two-stringslink-medium"><span class="section-number-3">8.136.</span> <a href="https://leetcode.com/problems/delete-operation-for-two-strings/">583. Delete Operation for Two Strings</a> (Medium)</h3>
<div class="outline-text-3" id="text-delete-operation-for-two-stringslink-medium">
<p>
Given two strings <code>word1</code> and <code>word2</code>, return the minimum number of <b>steps</b> required to make =word1=and =word2=the same.
</p>

<p>
In one <b>step</b>, you can delete exactly one character in either string.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org467a19f">
Input: word1 = "sea", word2 = "eat"
Output: 2
Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgae4b069">
Input: word1 = "leetcode", word2 = "etco"
Output: 4
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> word1.length, word2.length &lt;= 500=</li>
<li><code>word1</code> and <code>word2</code> consist of only lowercase English letters.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/delete-operation-for-two-strings/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int minDistance(string word1, string word2) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string word1;
    LeetCodeIO::scan(cin, word1);
    string word2;
    LeetCodeIO::scan(cin, word2);

    Solution *obj = new Solution();
    auto res = obj-&gt;minDistance(word1, word2);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-longest-harmonious-subsequencelink-easy" class="outline-3">
<h3 id="longest-harmonious-subsequencelink-easy"><span class="section-number-3">8.137.</span> <a href="https://leetcode.com/problems/longest-harmonious-subsequence/">594. Longest Harmonious Subsequence</a> (Easy)</h3>
<div class="outline-text-3" id="text-longest-harmonious-subsequencelink-easy">
<p>
We define a harmonious array as an array where the difference between its maximum value and its minimum value is <b>exactly</b> <code>1</code>.
</p>

<p>
Given an integer array <code>nums</code>, return the length of its longest harmonious subsequence among all its possible subsequences.
</p>

<p>
<b>Example 1:</b>
</p>

<p>
<b>Input:</b> nums = [1,3,2,2,5,2,3,7]
</p>

<p>
<b>Output:</b> 5
</p>

<p>
<b>Explanation:</b>
</p>

<p>
The longest harmonious subsequence is <code>[3,2,2,2,3]</code>.
</p>

<p>
<b>Example 2:</b>
</p>

<p>
<b>Input:</b> nums = [1,2,3,4]
</p>

<p>
<b>Output:</b> 2
</p>

<p>
<b>Explanation:</b>
</p>

<p>
The longest harmonious subsequences are <code>[1,2]</code>, <code>[2,3]</code>, and <code>[3,4]</code>, all of which have a length of 2.
</p>

<p>
<b>Example 3:</b>
</p>

<p>
<b>Input:</b> nums = [1,1,1,1]
</p>

<p>
<b>Output:</b> 0
</p>

<p>
<b>Explanation:</b>
</p>

<p>
No harmonic subsequence exists.
</p>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums.length &lt;= 2 * 10⁴=</li>
<li><code>-10⁹ &lt;</code> nums[i] &lt;= 10⁹=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/longest-harmonious-subsequence/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int findLHS(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;findLHS(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-can-place-flowerslink-easy" class="outline-3">
<h3 id="can-place-flowerslink-easy"><span class="section-number-3">8.138.</span> <a href="https://leetcode.com/problems/can-place-flowers/">605. Can Place Flowers</a> (Easy)</h3>
<div class="outline-text-3" id="text-can-place-flowerslink-easy">
<p>
You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in <b>adjacent</b> plots.
</p>

<p>
Given an integer array <code>flowerbed</code> containing <code>0</code>'s and <code>1</code>'s, where <code>0</code> means empty and <code>1</code> means not empty, and an integer <code>n</code>, return =true=if =n=new flowers can be planted in the =flowerbed=without violating the no-adjacent-flowers rule and =false=otherwise.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgd5663ad">
Input: flowerbed = [1,0,0,0,1], n = 1
Output: true
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org9fccc1b">
Input: flowerbed = [1,0,0,0,1], n = 2
Output: false
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> flowerbed.length &lt;= 2 * 10⁴=</li>
<li><code>flowerbed[i]</code> is <code>0</code> or <code>1</code>.</li>
<li>There are no two adjacent flowers in <code>flowerbed</code>.</li>
<li><code>0 &lt;</code> n &lt;= flowerbed.length=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/can-place-flowers/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; flowerbed;
    LeetCodeIO::scan(cin, flowerbed);
    int n;
    LeetCodeIO::scan(cin, n);

    Solution *obj = new Solution();
    auto res = obj-&gt;canPlaceFlowers(flowerbed, n);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-merge-two-binary-treeslink-easy" class="outline-3">
<h3 id="merge-two-binary-treeslink-easy"><span class="section-number-3">8.139.</span> <a href="https://leetcode.com/problems/merge-two-binary-trees/">617. Merge Two Binary Trees</a> (Easy)</h3>
<div class="outline-text-3" id="text-merge-two-binary-treeslink-easy">
<p>
You are given two binary trees <code>root1</code> and <code>root2</code>.
</p>

<p>
Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.
</p>

<p>
Return the merged tree.
</p>

<p>
<b>Note:</b> The merging process must start from the root nodes of both trees.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org4127bcd" class="figure">
<p><img src="../Leetcode/src/0617.merge-two-binary-trees/merge.jpg" alt="merge.jpg" />
</p>
</div>

<pre class="example" id="orgc45e722">
Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
Output: [3,4,5,5,4,null,7]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgd5bb8cf">
Input: root1 = [1], root2 = [1,2]
Output: [2,2]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in both trees is in the range <code>[0, 2000]</code>.</li>
<li><code>-10⁴ &lt;</code> Node.val &lt;= 10⁴=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/merge-two-binary-trees/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root1;
    LeetCodeIO::scan(cin, root1);
    TreeNode* root2;
    LeetCodeIO::scan(cin, root2);

    Solution *obj = new Solution();
    auto res = obj-&gt;mergeTrees(root1, root2);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-sum-of-square-numberslink-medium" class="outline-3">
<h3 id="sum-of-square-numberslink-medium"><span class="section-number-3">8.140.</span> <a href="https://leetcode.com/problems/sum-of-square-numbers/">633. Sum of Square Numbers</a> (Medium)</h3>
<div class="outline-text-3" id="text-sum-of-square-numberslink-medium">
<p>
Given a non-negative integer <code>c</code>, decide whether there're two integers <code>a</code> and <code>b</code> such that <code>a² + b² = c</code>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgc1bd8a4">
Input: c = 5
Output: true
Explanation: 1 * 1 + 2 * 2 = 5
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org322d538">
Input: c = 3
Output: false
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>0 &lt;</code> c &lt;= 2³¹ - 1=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/sum-of-square-numbers/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool judgeSquareSum(int c) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int c;
    LeetCodeIO::scan(cin, c);

    Solution *obj = new Solution();
    auto res = obj-&gt;judgeSquareSum(c);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-average-of-levels-in-binary-treelink-easy" class="outline-3">
<h3 id="average-of-levels-in-binary-treelink-easy"><span class="section-number-3">8.141.</span> <a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">637. Average of Levels in Binary Tree</a> (Easy)</h3>
<div class="outline-text-3" id="text-average-of-levels-in-binary-treelink-easy">
<p>
Given the <code>root</code> of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within <code>10⁻⁵</code> of the actual answer will be accepted.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orgf1f09a3" class="figure">
<p><img src="../Leetcode/src/0637.average-of-levels-in-binary-tree/avg1-tree.jpg" alt="avg1-tree.jpg" />
</p>
</div>

<pre class="example" id="org6c4970f">
Input: root = [3,9,20,null,null,15,7]
Output: [3.00000,14.50000,11.00000]
Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.
Hence return [3, 14.5, 11].
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org50ed162" class="figure">
<p><img src="../Leetcode/src/0637.average-of-levels-in-binary-tree/avg2-tree.jpg" alt="avg2-tree.jpg" />
</p>
</div>

<pre class="example" id="org9408b6e">
Input: root = [3,9,20,15,7]
Output: [3.00000,14.50000,11.00000]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[1, 10⁴]</code>.</li>
<li><code>-2³¹ &lt;</code> Node.val &lt;= 2³¹ - 1=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/average-of-levels-in-binary-tree/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;double&gt; averageOfLevels(TreeNode* root) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);

    Solution *obj = new Solution();
    auto res = obj-&gt;averageOfLevels(root);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-maximum-length-of-pair-chainlink-medium" class="outline-3">
<h3 id="maximum-length-of-pair-chainlink-medium"><span class="section-number-3">8.142.</span> <a href="https://leetcode.com/problems/maximum-length-of-pair-chain/">646. Maximum Length of Pair Chain</a> (Medium)</h3>
<div class="outline-text-3" id="text-maximum-length-of-pair-chainlink-medium">
<p>
You are given an array of <code>n</code> pairs <code>pairs</code> where <code>pairs[i] = [leftᵢ, rightᵢ]</code> and <code>leftᵢ &lt; rightᵢ</code>.
</p>

<p>
A pair <code>p2 = [c, d]</code> <b>follows</b> a pair <code>p1 = [a, b]</code> if <code>b &lt; c</code>. A <b>chain</b> of pairs can be formed in this fashion.
</p>

<p>
Return the length longest chain which can be formed.
</p>

<p>
You do not need to use up all the given intervals. You can select pairs in any order.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orga6a91e5">
Input: pairs = [[1,2],[2,3],[3,4]]
Output: 2
Explanation: The longest chain is [1,2] -&gt; [3,4].
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org99039e3">
Input: pairs = [[1,2],[7,8],[4,5]]
Output: 3
Explanation: The longest chain is [1,2] -&gt; [4,5] -&gt; [7,8].
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>n =</code> pairs.length=</li>
<li><code>1 &lt;</code> n &lt;= 1000=</li>
<li><code>-1000 &lt;</code> leftᵢ &lt; rightᵢ &lt;= 1000=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/maximum-length-of-pair-chain/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int findLongestChain(vector&lt;vector&lt;int&gt;&gt;&amp; pairs) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; pairs;
    LeetCodeIO::scan(cin, pairs);

    Solution *obj = new Solution();
    auto res = obj-&gt;findLongestChain(pairs);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-palindromic-substringslink-medium" class="outline-3">
<h3 id="palindromic-substringslink-medium"><span class="section-number-3">8.143.</span> <a href="https://leetcode.com/problems/palindromic-substrings/">647. Palindromic Substrings</a> (Medium)</h3>
<div class="outline-text-3" id="text-palindromic-substringslink-medium">
<p>
Given a string <code>s</code>, return the number of <b>palindromic substrings</b> in it.
</p>

<p>
A string is a <b>palindrome</b> when it reads the same backward as forward.
</p>

<p>
A <b>substring</b> is a contiguous sequence of characters within the string.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgdac11b1">
Input: s = "abc"
Output: 3
Explanation: Three palindromic strings: "a", "b", "c".
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org55a7fba">
Input: s = "aaa"
Output: 6
Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> s.length &lt;= 1000=</li>
<li><code>s</code> consists of lowercase English letters.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/palindromic-substrings/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int countSubstrings(string s) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string s;
    LeetCodeIO::scan(cin, s);

    Solution *obj = new Solution();
    auto res = obj-&gt;countSubstrings(s);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-keys-keyboardlink-medium" class="outline-3">
<h3 id="keys-keyboardlink-medium"><span class="section-number-3">8.144.</span> <a href="https://leetcode.com/problems/2-keys-keyboard/">650. 2 Keys Keyboard</a> (Medium)</h3>
<div class="outline-text-3" id="text-keys-keyboardlink-medium">
<p>
There is only one character <code>'A'</code> on the screen of a notepad. You can perform one of two operations on this notepad for each step:
</p>

<ul class="org-ul">
<li>Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).</li>
<li>Paste: You can paste the characters which are copied last time.</li>
</ul>

<p>
Given an integer <code>n</code>, return the minimum number of operations to get the character ='A'=exactly =n=times on the screen.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org6110d08">
Input: n = 3
Output: 3
Explanation: Initially, we have one character 'A'.
In step 1, we use Copy All operation.
In step 2, we use Paste operation to get 'AA'.
In step 3, we use Paste operation to get 'AAA'.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org8063061">
Input: n = 1
Output: 0
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> n &lt;= 1000=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/2-keys-keyboard/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int minSteps(int n) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int n;
    LeetCodeIO::scan(cin, n);

    Solution *obj = new Solution();
    auto res = obj-&gt;minSteps(n);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-two-sum-iv---input-is-a-bstlink-easy" class="outline-3">
<h3 id="two-sum-iv---input-is-a-bstlink-easy"><span class="section-number-3">8.145.</span> <a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/">653. Two Sum IV - Input is a BST</a> (Easy)</h3>
<div class="outline-text-3" id="text-two-sum-iv---input-is-a-bstlink-easy">
<p>
Given the <code>root</code> of a binary search tree and an integer <code>k</code>, return <code>true=if there exist two elements in the BST such that their sum is equal to =k</code>, or =false=otherwise.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org57fb3c7" class="figure">
<p><img src="../Leetcode/src/0653.two-sum-iv-input-is-a-bst/sum_tree_1.jpg" alt="sum_tree_1.jpg" />
</p>
</div>

<pre class="example" id="org2a65991">
Input: root = [5,3,6,2,4,null,7], k = 9
Output: true
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org18dec0c" class="figure">
<p><img src="../Leetcode/src/0653.two-sum-iv-input-is-a-bst/sum_tree_2.jpg" alt="sum_tree_2.jpg" />
</p>
</div>

<pre class="example" id="org287ca1c">
Input: root = [5,3,6,2,4,null,7], k = 28
Output: false
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[1, 10⁴]</code>.</li>
<li><code>-10⁴ &lt;</code> Node.val &lt;= 10⁴=</li>
<li><code>root</code> is guaranteed to be a <b>valid</b> binary search tree.</li>
<li><code>-10⁵ &lt;</code> k &lt;= 10⁵=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/two-sum-iv-input-is-a-bst/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool findTarget(TreeNode* root, int k) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);
    int k;
    LeetCodeIO::scan(cin, k);

    Solution *obj = new Solution();
    auto res = obj-&gt;findTarget(root, k);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-non-decreasing-arraylink-medium" class="outline-3">
<h3 id="non-decreasing-arraylink-medium"><span class="section-number-3">8.146.</span> <a href="https://leetcode.com/problems/non-decreasing-array/">665. Non-decreasing Array</a> (Medium)</h3>
<div class="outline-text-3" id="text-non-decreasing-arraylink-medium">
<p>
Given an array <code>nums</code> with <code>n</code> integers, your task is to check if it could become non-decreasing by modifying <b>at most one element</b>.
</p>

<p>
We define an array is non-decreasing if <code>nums[i] &lt;</code> nums[i + 1]= holds for every <code>i</code> ( <b>0-based</b>) such that ( <code>0 &lt;</code> i &lt;= n - 2=).
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgc7159ba">
Input: nums = [4,2,3]
Output: true
Explanation: You could modify the first 4 to 1 to get a non-decreasing array.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org3e0955f">
Input: nums = [4,2,1]
Output: false
Explanation: You cannot get a non-decreasing array by modifying at most one element.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>n =</code> nums.length=</li>
<li><code>1 &lt;</code> n &lt;= 10⁴=</li>
<li><code>-10⁵ &lt;</code> nums[i] &lt;= 10⁵=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/non-decreasing-array/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool checkPossibility(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;checkPossibility(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-trim-a-binary-search-treelink-medium" class="outline-3">
<h3 id="trim-a-binary-search-treelink-medium"><span class="section-number-3">8.147.</span> <a href="https://leetcode.com/problems/trim-a-binary-search-tree/">669. Trim a Binary Search Tree</a> (Medium)</h3>
<div class="outline-text-3" id="text-trim-a-binary-search-treelink-medium">
<p>
Given the <code>root</code> of a binary search tree and the lowest and highest boundaries as <code>low</code> and <code>high</code>, trim the tree so that all its elements lies in <code>[low, high]</code>. Trimming the tree should <b>not</b> change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). It can be proven that there is a <b>unique answer</b>.
</p>

<p>
Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orgad2fc69" class="figure">
<p><img src="../Leetcode/src/0669.trim-a-binary-search-tree/trim1.jpg" alt="trim1.jpg" />
</p>
</div>

<pre class="example" id="orgddf2321">
Input: root = [1,0,2], low = 1, high = 2
Output: [1,null,2]
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org57d637b" class="figure">
<p><img src="../Leetcode/src/0669.trim-a-binary-search-tree/trim2.jpg" alt="trim2.jpg" />
</p>
</div>

<pre class="example" id="org4d46ee0">
Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3
Output: [3,2,null,1]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the tree is in the range <code>[1, 10⁴]</code>.</li>
<li><code>0 &lt;</code> Node.val &lt;= 10⁴=</li>
<li>The value of each node in the tree is <b>unique</b>.</li>
<li><code>root</code> is guaranteed to be a valid binary search tree.</li>
<li><code>0 &lt;</code> low &lt;= high &lt;= 10⁴=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/trim-a-binary-search-tree/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);
    int low;
    LeetCodeIO::scan(cin, low);
    int high;
    LeetCodeIO::scan(cin, high);

    Solution *obj = new Solution();
    auto res = obj-&gt;trimBST(root, low, high);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-valid-palindrome-iilink-easy" class="outline-3">
<h3 id="valid-palindrome-iilink-easy"><span class="section-number-3">8.148.</span> <a href="https://leetcode.com/problems/valid-palindrome-ii/">680. Valid Palindrome II</a> (Easy)</h3>
<div class="outline-text-3" id="text-valid-palindrome-iilink-easy">
<p>
Given a string <code>s</code>, return <code>true=if the =s</code> can be palindrome after deleting <b>at most one</b> character from it.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org20848c2">
Input: s = "aba"
Output: true
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org371c39e">
Input: s = "abca"
Output: true
Explanation: You could delete the character 'c'.
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org6c8acac">
Input: s = "abc"
Output: false
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> s.length &lt;= 10⁵=</li>
<li><code>s</code> consists of lowercase English letters.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/valid-palindrome-ii/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool validPalindrome(string s) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string s;
    LeetCodeIO::scan(cin, s);

    Solution *obj = new Solution();
    auto res = obj-&gt;validPalindrome(s);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-redundant-connectionlink-medium" class="outline-3">
<h3 id="redundant-connectionlink-medium"><span class="section-number-3">8.149.</span> <a href="https://leetcode.com/problems/redundant-connection/">684. Redundant Connection</a> (Medium)</h3>
<div class="outline-text-3" id="text-redundant-connectionlink-medium">
<p>
In this problem, a tree is an <b>undirected graph</b> that is connected and has no cycles.
</p>

<p>
You are given a graph that started as a tree with <code>n</code> nodes labeled from <code>1</code> to <code>n</code>, with one additional edge added. The added edge has two <b>different</b> vertices chosen from <code>1</code> to <code>n</code>, and was not an edge that already existed. The graph is represented as an array <code>edges</code> of length <code>n</code> where <code>edges[i] = [aᵢ, bᵢ]</code> indicates that there is an edge between nodes <code>aᵢ</code> and <code>bᵢ</code> in the graph.
</p>

<p>
Return an edge that can be removed so that the resulting graph is a tree of <code>n</code> nodes. If there are multiple answers, return the answer that occurs last in the input.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org785b9c8" class="figure">
<p><img src="../Leetcode/src/0684.redundant-connection/reduntant1-1-graph.jpg" alt="reduntant1-1-graph.jpg" />
</p>
</div>

<pre class="example" id="org5b0483d">
Input: edges = [[1,2],[1,3],[2,3]]
Output: [2,3]
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org7813aa6" class="figure">
<p><img src="../Leetcode/src/0684.redundant-connection/reduntant1-2-graph.jpg" alt="reduntant1-2-graph.jpg" />
</p>
</div>

<pre class="example" id="org38f94c7">
Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]
Output: [1,4]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>n =</code> edges.length=</li>
<li><code>3 &lt;</code> n &lt;= 1000=</li>
<li><code>edges[i].length =</code> 2=</li>
<li><code>1 &lt;</code> aᵢ &lt; bᵢ &lt;= edges.length=</li>
<li><code>aᵢ !</code> bᵢ=</li>
<li>There are no repeated edges.</li>
<li>The given graph is connected.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/redundant-connection/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; edges;
    LeetCodeIO::scan(cin, edges);

    Solution *obj = new Solution();
    auto res = obj-&gt;findRedundantConnection(edges);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-binary-number-with-alternating-bitslink-easy" class="outline-3">
<h3 id="binary-number-with-alternating-bitslink-easy"><span class="section-number-3">8.150.</span> <a href="https://leetcode.com/problems/binary-number-with-alternating-bits/">693. Binary Number with Alternating Bits</a> (Easy)</h3>
<div class="outline-text-3" id="text-binary-number-with-alternating-bitslink-easy">
<p>
Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org68697d9">
Input: n = 5
Output: true
Explanation: The binary representation of 5 is: 101
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orga85c34a">
Input: n = 7
Output: false
Explanation: The binary representation of 7 is: 111.
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orgc8f97bd">
Input: n = 11
Output: false
Explanation: The binary representation of 11 is: 1011.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> n &lt;= 2³¹ - 1=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/binary-number-with-alternating-bits/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool hasAlternatingBits(int n) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int n;
    LeetCodeIO::scan(cin, n);

    Solution *obj = new Solution();
    auto res = obj-&gt;hasAlternatingBits(n);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-max-area-of-islandlink-medium" class="outline-3">
<h3 id="max-area-of-islandlink-medium"><span class="section-number-3">8.151.</span> <a href="https://leetcode.com/problems/max-area-of-island/">695. Max Area of Island</a> (Medium)</h3>
<div class="outline-text-3" id="text-max-area-of-islandlink-medium">
<p>
You are given an <code>m x n</code> binary matrix <code>grid</code>. An island is a group of <code>1</code>'s (representing land) connected <b>4-directionally</b> (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.
</p>

<p>
The <b>area</b> of an island is the number of cells with a value <code>1</code> in the island.
</p>

<p>
Return the maximum <b>area</b> of an island in <code>grid</code>. If there is no island, return <code>0</code>.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orgd63fc18" class="figure">
<p><img src="../Leetcode/src/0695.max-area-of-island/maxarea1-grid.jpg" alt="maxarea1-grid.jpg" />
</p>
</div>

<pre class="example" id="org4bd79b0">
Input: grid =
[[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
Output: 6
Explanation: The answer is not 11, because the island must be connected 4-directionally.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org089502d">
Input: grid = [[0,0,0,0,0,0,0,0]]
Output: 0
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>m =</code> grid.length=</li>
<li><code>n =</code> grid[i].length=</li>
<li><code>1 &lt;</code> m, n &lt;= 50=</li>
<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/max-area-of-island/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; grid;
    LeetCodeIO::scan(cin, grid);

    Solution *obj = new Solution();
    auto res = obj-&gt;maxAreaOfIsland(grid);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-count-binary-substringslink-easy" class="outline-3">
<h3 id="count-binary-substringslink-easy"><span class="section-number-3">8.152.</span> <a href="https://leetcode.com/problems/count-binary-substrings/">696. Count Binary Substrings</a> (Easy)</h3>
<div class="outline-text-3" id="text-count-binary-substringslink-easy">
<p>
Given a binary string <code>s</code>, return the number of non-empty substrings that have the same number of <code>0</code>'s and <code>1</code>'s, and all the <code>0</code>'s and all the <code>1</code>'s in these substrings are grouped consecutively.
</p>

<p>
Substrings that occur multiple times are counted the number of times they occur.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgd38dc9f">
Input: s = "00110011"
Output: 6
Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01",
"1100", "10", "0011", and "01".
Notice that some of these substrings repeat and are counted the number of times they occur.
Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgc42543e">
Input: s = "10101"
Output: 4
Explanation: There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive
1's and 0's.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> s.length &lt;= 10⁵=</li>
<li><code>s[i]</code> is either <code>'0'</code> or <code>'1'</code>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/count-binary-substrings/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int countBinarySubstrings(string s) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string s;
    LeetCodeIO::scan(cin, s);

    Solution *obj = new Solution();
    auto res = obj-&gt;countBinarySubstrings(s);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-degree-of-an-arraylink-easy" class="outline-3">
<h3 id="degree-of-an-arraylink-easy"><span class="section-number-3">8.153.</span> <a href="https://leetcode.com/problems/degree-of-an-array/">697. Degree of an Array</a> (Easy)</h3>
<div class="outline-text-3" id="text-degree-of-an-arraylink-easy">
<p>
Given a non-empty array of non-negative integers <code>nums</code>, the <b>degree</b> of this array is defined as the maximum frequency of any one of its elements.
</p>

<p>
Your task is to find the smallest possible length of a (contiguous) subarray of <code>nums</code>, that has the same degree as <code>nums</code>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org4b8eded">
Input: nums = [1,2,2,3,1]
Output: 2
Explanation:
The input array has a degree of 2 because both elements 1 and 2 appear twice.
Of the subarrays that have the same degree:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
The shortest length is 2. So return 2.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org620a617">
Input: nums = [1,2,2,3,1,4,2]
Output: 6
Explanation:
The degree is 3 because the element 2 is repeated 3 times.
So [2,2,3,1,4,2] is the shortest subarray, therefore returning 6.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>nums.length</code> will be between 1 and 50,000.</li>
<li><code>nums[i]</code> will be an integer between 0 and 49,999.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/degree-of-an-array/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int findShortestSubArray(vector&lt;int&gt;&amp; nums) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums;
    LeetCodeIO::scan(cin, nums);

    Solution *obj = new Solution();
    auto res = obj-&gt;findShortestSubArray(nums);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-best-time-to-buy-and-sell-stock-with-transaction-feelink-medium" class="outline-3">
<h3 id="best-time-to-buy-and-sell-stock-with-transaction-feelink-medium"><span class="section-number-3">8.154.</span> <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. Best Time to Buy and Sell Stock with Transaction Fee</a> (Medium)</h3>
<div class="outline-text-3" id="text-best-time-to-buy-and-sell-stock-with-transaction-feelink-medium">
<p>
You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>iᵗʰ</code> day, and an integer <code>fee</code> representing a transaction fee.
</p>

<p>
Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.
</p>

<p>
<b>Note:</b>
</p>

<ul class="org-ul">
<li>You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</li>
<li>The transaction fee is only charged once for each stock purchase and sale.</li>
</ul>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgdc2f501">
Input: prices = [1,3,2,8,4,9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
- Buying at prices[0] = 1
- Selling at prices[3] = 8
- Buying at prices[4] = 4
- Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org967b060">
Input: prices = [1,3,7,5,10,3], fee = 3
Output: 6
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> prices.length &lt;= 5 * 10⁴=</li>
<li><code>1 &lt;</code> prices[i] &lt; 5 * 10⁴=</li>
<li><code>0 &lt;</code> fee &lt; 5 * 10⁴=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; prices;
    LeetCodeIO::scan(cin, prices);
    int fee;
    LeetCodeIO::scan(cin, fee);

    Solution *obj = new Solution();
    auto res = obj-&gt;maxProfit(prices, fee);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-daily-temperatureslink-medium" class="outline-3">
<h3 id="daily-temperatureslink-medium"><span class="section-number-3">8.155.</span> <a href="https://leetcode.com/problems/daily-temperatures/">739. Daily Temperatures</a> (Medium)</h3>
<div class="outline-text-3" id="text-daily-temperatureslink-medium">
<p>
Given an array of integers <code>temperatures</code> represents the daily temperatures, return an array <code>answer=such that =answer[i]=is the number of days you have to wait after the =iᵗʰ=day to get a warmer temperature. If there is no future day for which this is possible, keep =answer[i] =</code> 0= instead.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org44e5ef4">
Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org6c31057">
Input: temperatures = [30,40,50,60]
Output: [1,1,1,0]
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org2969624">
Input: temperatures = [30,60,90]
Output: [1,1,0]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> temperatures.length &lt;= 10⁵=</li>
<li><code>30 &lt;</code> temperatures[i] &lt;= 100=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/daily-temperatures/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; temperatures;
    LeetCodeIO::scan(cin, temperatures);

    Solution *obj = new Solution();
    auto res = obj-&gt;dailyTemperatures(temperatures);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-partition-labelslink-medium" class="outline-3">
<h3 id="partition-labelslink-medium"><span class="section-number-3">8.156.</span> <a href="https://leetcode.com/problems/partition-labels/">763. Partition Labels</a> (Medium)</h3>
<div class="outline-text-3" id="text-partition-labelslink-medium">
<p>
You are given a string <code>s</code>. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string <code>"ababcc"</code> can be partitioned into <code>["abab", "cc"]</code>, but partitions such as <code>["aba", "bcc"]</code> or <code>["ab", "ab", "cc"]</code> are invalid.
</p>

<p>
Note that the partition is done so that after concatenating all the parts in order, the resultant string should be <code>s</code>.
</p>

<p>
Return a list of integers representing the size of these parts.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgde74633">
Input: s = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits s into less parts.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org632b4b7">
Input: s = "eccbbbbdec"
Output: [10]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> s.length &lt;= 500=</li>
<li><code>s</code> consists of lowercase English letters.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/partition-labels/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; partitionLabels(string s) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string s;
    LeetCodeIO::scan(cin, s);

    Solution *obj = new Solution();
    auto res = obj-&gt;partitionLabels(s);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-max-chunks-to-make-sortedlink-medium" class="outline-3">
<h3 id="max-chunks-to-make-sortedlink-medium"><span class="section-number-3">8.157.</span> <a href="https://leetcode.com/problems/max-chunks-to-make-sorted/">769. Max Chunks To Make Sorted</a> (Medium)</h3>
<div class="outline-text-3" id="text-max-chunks-to-make-sortedlink-medium">
<p>
You are given an integer array <code>arr</code> of length <code>n</code> that represents a permutation of the integers in the range <code>[0, n - 1]</code>.
</p>

<p>
We split <code>arr</code> into some number of <b>chunks</b> (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.
</p>

<p>
Return the largest number of chunks we can make to sort the array.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgd1cd1b9">
Input: arr = [4,3,2,1,0]
Output: 1
Explanation:
Splitting into two or more chunks will not return the required result.
For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgc7c2610">
Input: arr = [1,0,2,3,4]
Output: 4
Explanation:
We can split into two chunks, such as [1, 0], [2, 3, 4].
However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>n =</code> arr.length=</li>
<li><code>1 &lt;</code> n &lt;= 10=</li>
<li><code>0 &lt;</code> arr[i] &lt; n=</li>
<li>All the elements of <code>arr</code> are <b>unique</b>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/max-chunks-to-make-sorted/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int maxChunksToSorted(vector&lt;int&gt;&amp; arr) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; arr;
    LeetCodeIO::scan(cin, arr);

    Solution *obj = new Solution();
    auto res = obj-&gt;maxChunksToSorted(arr);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-is-graph-bipartitelink-medium" class="outline-3">
<h3 id="is-graph-bipartitelink-medium"><span class="section-number-3">8.158.</span> <a href="https://leetcode.com/problems/is-graph-bipartite/">785. Is Graph Bipartite?</a> (Medium)</h3>
<div class="outline-text-3" id="text-is-graph-bipartitelink-medium">
<p>
There is an <b>undirected</b> graph with <code>n</code> nodes, where each node is numbered between <code>0</code> and <code>n - 1</code>. You are given a 2D array <code>graph</code>, where <code>graph[u]</code> is an array of nodes that node <code>u</code> is adjacent to. More formally, for each <code>v</code> in <code>graph[u]</code>, there is an undirected edge between node <code>u</code> and node <code>v</code>. The graph has the following properties:
</p>

<ul class="org-ul">
<li>There are no self-edges ( <code>graph[u]</code> does not contain <code>u</code>).</li>
<li>There are no parallel edges ( <code>graph[u]</code> does not contain duplicate values).</li>
<li>If <code>v</code> is in <code>graph[u]</code>, then <code>u</code> is in <code>graph[v]</code> (the graph is undirected).</li>
<li>The graph may not be connected, meaning there may be two nodes <code>u</code> and <code>v</code> such that there is no path between them.</li>
</ul>

<p>
A graph is <b>bipartite</b> if the nodes can be partitioned into two independent sets <code>A</code> and <code>B</code> such that <b>every</b> edge in the graph connects a node in set <code>A</code> and a node in set <code>B</code>.
</p>

<p>
Return <code>true</code> if and only if it is <b>bipartite</b>.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orgc0b73e8" class="figure">
<p><img src="../Leetcode/src/0785.is-graph-bipartite/bi2.jpg" alt="bi2.jpg" />
</p>
</div>

<pre class="example" id="org8652373">
Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
Output: false
Explanation: There is no way to partition the nodes into two independent sets such that every edge
connects a node in one and a node in the other.
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org1e75cd1" class="figure">
<p><img src="../Leetcode/src/0785.is-graph-bipartite/bi1.jpg" alt="bi1.jpg" />
</p>
</div>

<pre class="example" id="org26115cf">
Input: graph = [[1,3],[0,2],[1,3],[0,2]]
Output: true
Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>graph.length =</code> n=</li>
<li><code>1 &lt;</code> n &lt;= 100=</li>
<li><code>0 &lt;</code> graph[u].length &lt; n=</li>
<li><code>0 &lt;</code> graph[u][i] &lt;= n - 1=</li>
<li><code>graph[u]</code> does not contain <code>u</code>.</li>
<li>All the values of <code>graph[u]</code> are <b>unique</b>.</li>
<li>If <code>graph[u]</code> contains <code>v</code>, then <code>graph[v]</code> contains <code>u</code>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/is-graph-bipartite/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; graph;
    LeetCodeIO::scan(cin, graph);

    Solution *obj = new Solution();
    auto res = obj-&gt;isBipartite(graph);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-advantage-shufflelink-medium" class="outline-3">
<h3 id="advantage-shufflelink-medium"><span class="section-number-3">8.159.</span> <a href="https://leetcode.com/problems/advantage-shuffle/">870. Advantage Shuffle</a> (Medium)</h3>
<div class="outline-text-3" id="text-advantage-shufflelink-medium">
<p>
You are given two integer arrays <code>nums1</code> and <code>nums2</code> both of the same length. The <b>advantage</b> of <code>nums1</code> with respect to <code>nums2</code> is the number of indices <code>i</code> for which <code>nums1[i] &gt; nums2[i]</code>.
</p>

<p>
Return any permutation of <code>nums1</code> that maximizes its <b>advantage</b> with respect to <code>nums2</code>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org6b82b2c">
Input: nums1 = [2,7,11,15], nums2 = [1,10,4,11]
Output: [2,11,7,15]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org8d104b2">
Input: nums1 = [12,24,8,32], nums2 = [13,25,32,11]
Output: [24,32,8,12]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> nums1.length &lt;= 10⁵=</li>
<li><code>nums2.length =</code> nums1.length=</li>
<li><code>0 &lt;</code> nums1[i], nums2[i] &lt;= 10⁹=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/advantage-shuffle/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; advantageCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; nums1;
    LeetCodeIO::scan(cin, nums1);
    vector&lt;int&gt; nums2;
    LeetCodeIO::scan(cin, nums2);

    Solution *obj = new Solution();
    auto res = obj-&gt;advantageCount(nums1, nums2);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-reachable-nodes-in-subdivided-graphlink-hard" class="outline-3">
<h3 id="reachable-nodes-in-subdivided-graphlink-hard"><span class="section-number-3">8.160.</span> <a href="https://leetcode.com/problems/reachable-nodes-in-subdivided-graph/">882. Reachable Nodes In Subdivided Graph</a> (Hard)</h3>
<div class="outline-text-3" id="text-reachable-nodes-in-subdivided-graphlink-hard">
<p>
You are given an undirected graph (the <b>"original graph"</b>) with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>. You decide to <b>subdivide</b> each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge.
</p>

<p>
The graph is given as a 2D array of <code>edges</code> where <code>edges[i] = [uᵢ, vᵢ, cntᵢ]</code> indicates that there is an edge between nodes <code>uᵢ</code> and <code>vᵢ</code> in the original graph, and <code>cntᵢ</code> is the total number of new nodes that you will <b>subdivide</b> the edge into. Note that <code>cntᵢ =</code> 0= means you will not subdivide the edge.
</p>

<p>
To <b>subdivide</b> the edge <code>[uᵢ, vᵢ]</code>, replace it with <code>(cntᵢ + 1)</code> new edges and <code>cntᵢ</code> new nodes. The new nodes are <code>x₁</code>, <code>x₂</code>, &#x2026;, <code>xcₙₜ</code>, and the new edges are <code>[uᵢ, x₁]</code>, <code>[x₁, x₂]</code>, <code>[x₂, x₃]</code>, &#x2026;, <code>[xcₙₜ₋₁, xcₙₜ]</code>, <code>[xcₙₜ, vᵢ]</code>.
</p>

<p>
In this <b>new graph</b>, you want to know how many nodes are <b>reachable</b> from the node <code>0</code>, where a node is <b>reachable</b> if the distance is <code>maxMoves</code> or less.
</p>

<p>
Given the original graph and <code>maxMoves</code>, return the number of nodes that are <b>reachable</b> from node <code>0</code> in the new graph.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orge458c6b" class="figure">
<p><img src="../Leetcode/src/0882.reachable-nodes-in-subdivided-graph/origfinal.png" alt="origfinal.png" />
</p>
</div>

<pre class="example" id="orgc61c1af">
Input: edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3
Output: 13
Explanation: The edge subdivisions are shown in the image above.
The nodes that are reachable are highlighted in yellow.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgdba21d8">
Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4
Output: 23
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org2fa3442">
Input: edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5
Output: 1
Explanation: Node 0 is disconnected from the rest of the graph, so only node 0 is reachable.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>0 &lt;</code> edges.length &lt;= min(n * (n - 1) / 2, 10⁴)=</li>
<li><code>edges[i].length =</code> 3=</li>
<li><code>0 &lt;</code> uᵢ &lt; vᵢ &lt; n=</li>
<li>There are <b>no multiple edges</b> in the graph.</li>
<li><code>0 &lt;</code> cntᵢ &lt;= 10⁴=</li>
<li><code>0 &lt;</code> maxMoves &lt;= 10⁹=</li>
<li><code>1 &lt;</code> n &lt;= 3000=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/reachable-nodes-in-subdivided-graph/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int reachableNodes(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int maxMoves, int n) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; edges;
    LeetCodeIO::scan(cin, edges);
    int maxMoves;
    LeetCodeIO::scan(cin, maxMoves);
    int n;
    LeetCodeIO::scan(cin, n);

    Solution *obj = new Solution();
    auto res = obj-&gt;reachableNodes(edges, maxMoves, n);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-construct-binary-tree-from-preorder-and-postorder-traversallink-medium" class="outline-3">
<h3 id="construct-binary-tree-from-preorder-and-postorder-traversallink-medium"><span class="section-number-3">8.161.</span> <a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. Construct Binary Tree from Preorder and Postorder Traversal</a> (Medium)</h3>
<div class="outline-text-3" id="text-construct-binary-tree-from-preorder-and-postorder-traversallink-medium">
<p>
Given two integer arrays, <code>preorder</code> and <code>postorder</code> where <code>preorder</code> is the preorder traversal of a binary tree of <b>distinct</b> values and <code>postorder</code> is the postorder traversal of the same tree, reconstruct and return the binary tree.
</p>

<p>
If there exist multiple answers, you can <b>return any</b> of them.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org367e18d" class="figure">
<p><img src="../Leetcode/src/0889.construct-binary-tree-from-preorder-and-postorder-traversal/lc-prepost.jpg" alt="lc-prepost.jpg" />
</p>
</div>

<pre class="example" id="org0ab959f">
Input: preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
Output: [1,2,3,4,5,6,7]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org73aec42">
Input: preorder = [1], postorder = [1]
Output: [1]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> preorder.length &lt;= 30=</li>
<li><code>1 &lt;</code> preorder[i] &lt;= preorder.length=</li>
<li>All the values of <code>preorder</code> are <b>unique</b>.</li>
<li><code>postorder.length =</code> preorder.length=</li>
<li><code>1 &lt;</code> postorder[i] &lt;= postorder.length=</li>
<li>All the values of <code>postorder</code> are <b>unique</b>.</li>
<li>It is guaranteed that <code>preorder</code> and <code>postorder</code> are the preorder traversal and postorder traversal of the same binary tree.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; postorder) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;int&gt; preorder;
    LeetCodeIO::scan(cin, preorder);
    vector&lt;int&gt; postorder;
    LeetCodeIO::scan(cin, postorder);

    Solution *obj = new Solution();
    auto res = obj-&gt;constructFromPrePost(preorder, postorder);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-increasing-order-search-treelink-easy" class="outline-3">
<h3 id="increasing-order-search-treelink-easy"><span class="section-number-3">8.162.</span> <a href="https://leetcode.com/problems/increasing-order-search-tree/">897. Increasing Order Search Tree</a> (Easy)</h3>
<div class="outline-text-3" id="text-increasing-order-search-treelink-easy">
<p>
Given the <code>root</code> of a binary search tree, rearrange the tree in <b>in-order</b> so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org1ef757a" class="figure">
<p><img src="../Leetcode/src/0897.increasing-order-search-tree/ex1.jpg" alt="ex1.jpg" />
</p>
</div>

<pre class="example" id="org0b693ec">
Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="org064a5ef" class="figure">
<p><img src="../Leetcode/src/0897.increasing-order-search-tree/ex2.jpg" alt="ex2.jpg" />
</p>
</div>

<pre class="example" id="org3c4685d">
Input: root = [5,1,7]
Output: [1,null,5,null,7]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the given tree will be in the range <code>[1, 100]</code>.</li>
<li><code>0 &lt;</code> Node.val &lt;= 1000=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/increasing-order-search-tree/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    TreeNode* increasingBST(TreeNode* root) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);

    Solution *obj = new Solution();
    auto res = obj-&gt;increasingBST(root);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-beautiful-arraylink-medium" class="outline-3">
<h3 id="beautiful-arraylink-medium"><span class="section-number-3">8.163.</span> <a href="https://leetcode.com/problems/beautiful-array/">932. Beautiful Array</a> (Medium)</h3>
<div class="outline-text-3" id="text-beautiful-arraylink-medium">
<p>
An array <code>nums</code> of length <code>n</code> is <b>beautiful</b> if:
</p>

<ul class="org-ul">
<li><code>nums</code> is a permutation of the integers in the range <code>[1, n]</code>.</li>
<li>For every <code>0 &lt;</code> i &lt; j &lt; n=, there is no index <code>k</code> with <code>i &lt; k &lt; j</code> where <code>2 * nums[k] =</code> nums[i] + nums[j]=.</li>
</ul>

<p>
Given the integer <code>n</code>, return any <b>beautiful</b> array <code>nums</code> of length <code>n</code>. There will be at least one valid answer for the given <code>n</code>.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgbe4ceff">
Input: n = 4
Output: [2,1,4,3]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgd935109">
Input: n = 5
Output: [3,1,2,5,4]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> n &lt;= 1000=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/beautiful-array/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;int&gt; beautifulArray(int n) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    int n;
    LeetCodeIO::scan(cin, n);

    Solution *obj = new Solution();
    auto res = obj-&gt;beautifulArray(n);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-shortest-bridgelink-medium" class="outline-3">
<h3 id="shortest-bridgelink-medium"><span class="section-number-3">8.164.</span> <a href="https://leetcode.com/problems/shortest-bridge/">934. Shortest Bridge</a> (Medium)</h3>
<div class="outline-text-3" id="text-shortest-bridgelink-medium">
<p>
You are given an <code>n x n</code> binary matrix <code>grid</code> where <code>1</code> represents land and <code>0</code> represents water.
</p>

<p>
An <b>island</b> is a 4-directionally connected group of <code>1</code>'s not connected to any other <code>1</code>'s. There are <b>exactly two islands</b> in <code>grid</code>.
</p>

<p>
You may change <code>0</code>'s to <code>1</code>'s to connect the two islands to form <b>one island</b>.
</p>

<p>
Return the smallest number of <code>0</code>'s you must flip to connect the two islands.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgc787cb7">
Input: grid = [[0,1],[1,0]]
Output: 1
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org1ead2a2">
Input: grid = [[0,1,0],[0,0,0],[0,0,1]]
Output: 2
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org66561e5">
Input: grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
Output: 1
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>n =</code> grid.length <code>= grid[i].length</code></li>
<li><code>2 &lt;</code> n &lt;= 100=</li>
<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>
<li>There are exactly two islands in <code>grid</code>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/shortest-bridge/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; grid;
    LeetCodeIO::scan(cin, grid);

    Solution *obj = new Solution();
    auto res = obj-&gt;shortestBridge(grid);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-shortest-path-in-binary-matrixlink-medium" class="outline-3">
<h3 id="shortest-path-in-binary-matrixlink-medium"><span class="section-number-3">8.165.</span> <a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/">1091. Shortest Path in Binary Matrix</a> (Medium)</h3>
<div class="outline-text-3" id="text-shortest-path-in-binary-matrixlink-medium">
<p>
Given an <code>n x n</code> binary matrix <code>grid</code>, return the length of the shortest <b>clear path</b> in the matrix. If there is no clear path, return <code>-1</code>.
</p>

<p>
A <b>clear path</b> in a binary matrix is a path from the <b>top-left</b> cell (i.e., <code>(0, 0)</code>) to the <b>bottom-right</b> cell (i.e., <code>(n - 1, n - 1)</code>) such that:
</p>

<ul class="org-ul">
<li>All the visited cells of the path are <code>0</code>.</li>
<li>All the adjacent cells of the path are <b>8-directionally</b> connected (i.e., they are different and they share an edge or a corner).</li>
</ul>

<p>
The <b>length of a clear path</b> is the number of visited cells of this path.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org398be5b" class="figure">
<p><img src="../Leetcode/src/1091.shortest-path-in-binary-matrix/example1_1.png" alt="example1_1.png" />
</p>
</div>

<pre class="example" id="org4177a16">
Input: grid = [[0,1],[1,0]]
Output: 2
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="orgb582a49" class="figure">
<p><img src="../Leetcode/src/1091.shortest-path-in-binary-matrix/example2_1.png" alt="example2_1.png" />
</p>
</div>

<pre class="example" id="org09f42da">
Input: grid = [[0,0,0],[1,1,0],[1,1,0]]
Output: 4
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orge38acdb">
Input: grid = [[1,0,0],[1,1,0],[1,1,0]]
Output: -1
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>n =</code> grid.length=</li>
<li><code>n =</code> grid[i].length=</li>
<li><code>1 &lt;</code> n &lt;= 100=</li>
<li><code>grid[i][j] is 0 or 1</code></li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/shortest-path-in-binary-matrix/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; grid;
    LeetCodeIO::scan(cin, grid);

    Solution *obj = new Solution();
    auto res = obj-&gt;shortestPathBinaryMatrix(grid);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-filling-bookcase-shelveslink-medium" class="outline-3">
<h3 id="filling-bookcase-shelveslink-medium"><span class="section-number-3">8.166.</span> <a href="https://leetcode.com/problems/filling-bookcase-shelves/">1105. Filling Bookcase Shelves</a> (Medium)</h3>
<div class="outline-text-3" id="text-filling-bookcase-shelveslink-medium">
<p>
You are given an array <code>books</code> where <code>books[i] = [thicknessᵢ, heightᵢ]</code> indicates the thickness and height of the <code>iᵗʰ</code> book. You are also given an integer <code>shelfWidth</code>.
</p>

<p>
We want to place these books in order onto bookcase shelves that have a total width <code>shelfWidth</code>.
</p>

<p>
We choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to <code>shelfWidth</code>, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.
</p>

<p>
Note that at each step of the above process, the order of the books we place is the same order as the given sequence of books.
</p>

<ul class="org-ul">
<li>For example, if we have an ordered list of <code>5</code> books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.</li>
</ul>

<p>
Return the minimum possible height that the total bookshelf can be after placing shelves in this manner.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orgf7faf61" class="figure">
<p><img src="../Leetcode/src/1105.filling-bookcase-shelves/shelves.png" alt="shelves.png" />
</p>
</div>

<pre class="example" id="org9248fdb">
Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelfWidth = 4
Output: 6
Explanation:
The sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.
Notice that book number 2 does not have to be on the first shelf.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgf4fa759">
Input: books = [[1,3],[2,4],[3,2]], shelfWidth = 6
Output: 4
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> books.length &lt;= 1000=</li>
<li><code>1 &lt;</code> thicknessᵢ &lt;= shelfWidth &lt;= 1000=</li>
<li><code>1 &lt;</code> heightᵢ &lt;= 1000=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/filling-bookcase-shelves/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int minHeightShelves(vector&lt;vector&lt;int&gt;&gt;&amp; books, int shelfWidth) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    vector&lt;vector&lt;int&gt;&gt; books;
    LeetCodeIO::scan(cin, books);
    int shelfWidth;
    LeetCodeIO::scan(cin, shelfWidth);

    Solution *obj = new Solution();
    auto res = obj-&gt;minHeightShelves(books, shelfWidth);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-delete-nodes-and-return-forestlink-medium" class="outline-3">
<h3 id="delete-nodes-and-return-forestlink-medium"><span class="section-number-3">8.167.</span> <a href="https://leetcode.com/problems/delete-nodes-and-return-forest/">1110. Delete Nodes And Return Forest</a> (Medium)</h3>
<div class="outline-text-3" id="text-delete-nodes-and-return-forestlink-medium">
<p>
Given the <code>root</code> of a binary tree, each node in the tree has a distinct value.
</p>

<p>
After deleting all nodes with a value in <code>to_delete</code>, we are left with a forest (a disjoint union of trees).
</p>

<p>
Return the roots of the trees in the remaining forest. You may return the result in any order.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="org5e22b24" class="figure">
<p><img src="../Leetcode/src/1110.delete-nodes-and-return-forest/screen-shot-2019-07-01-at-53836-pm.png" alt="screen-shot-2019-07-01-at-53836-pm.png" />
</p>
</div>

<pre class="example" id="orge7e73f8">
Input: root = [1,2,3,4,5,6,7], to_delete = [3,5]
Output: [[1,2,null,4],[6],[7]]
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orgde6f83c">
Input: root = [1,2,4,null,3], to_delete = [3]
Output: [[1,2,4]]
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the given tree is at most <code>1000</code>.</li>
<li>Each node has a distinct value between <code>1</code> and <code>1000</code>.</li>
<li><code>to_delete.length &lt;</code> 1000=</li>
<li><code>to_delete</code> contains distinct values between <code>1</code> and <code>1000</code>.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/delete-nodes-and-return-forest/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    vector&lt;TreeNode*&gt; delNodes(TreeNode* root, vector&lt;int&gt;&amp; to_delete) {

    }
};

// @lc code=end

// Warning: this is a manual question, the generated test code may be incorrect.
int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);
    vector&lt;int&gt; to_delete;
    LeetCodeIO::scan(cin, to_delete);

    Solution *obj = new Solution();
    auto res = obj-&gt;delNodes(root, to_delete);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-longest-common-subsequencelink-medium" class="outline-3">
<h3 id="longest-common-subsequencelink-medium"><span class="section-number-3">8.168.</span> <a href="https://leetcode.com/problems/longest-common-subsequence/">1143. Longest Common Subsequence</a> (Medium)</h3>
<div class="outline-text-3" id="text-longest-common-subsequencelink-medium">
<p>
Given two strings <code>text1</code> and <code>text2</code>, return the length of their longest <b>common subsequence</b>. If there is no <b>common subsequence</b>, return <code>0</code>.
</p>

<p>
A <b>subsequence</b> of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.
</p>

<ul class="org-ul">
<li>For example, <code>"ace"</code> is a subsequence of <code>"abcde"</code>.</li>
</ul>

<p>
A <b>common subsequence</b> of two strings is a subsequence that is common to both strings.
</p>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="orgfc0e53d">
Input: text1 = "abcde", text2 = "ace"
Output: 3
Explanation: The longest common subsequence is "ace" and its length is 3.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="org70df827">
Input: text1 = "abc", text2 = "abc"
Output: 3
Explanation: The longest common subsequence is "abc" and its length is 3.
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="orgb10374b">
Input: text1 = "abc", text2 = "def"
Output: 0
Explanation: There is no such common subsequence, so the result is 0.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> text1.length, text2.length &lt;= 1000=</li>
<li><code>text1</code> and <code>text2</code> consist of only lowercase English characters.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/longest-common-subsequence/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string text1;
    LeetCodeIO::scan(cin, text1);
    string text2;
    LeetCodeIO::scan(cin, text2);

    Solution *obj = new Solution();
    auto res = obj-&gt;longestCommonSubsequence(text1, text2);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-minimum-remove-to-make-valid-parentheseslink-medium" class="outline-3">
<h3 id="minimum-remove-to-make-valid-parentheseslink-medium"><span class="section-number-3">8.169.</span> <a href="https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/">1249. Minimum Remove to Make Valid Parentheses</a> (Medium)</h3>
<div class="outline-text-3" id="text-minimum-remove-to-make-valid-parentheseslink-medium">
<p>
Given a string s of <code>'('</code> , <code>')'</code> and lowercase English characters.
</p>

<p>
Your task is to remove the minimum number of parentheses ( <code>'('</code> or <code>')'</code>, in any positions ) so that the resulting parentheses string is valid and return <b>any</b> valid string.
</p>

<p>
Formally, a parentheses string is valid if and only if:
</p>

<ul class="org-ul">
<li>It is the empty string, contains only lowercase characters, or</li>
<li>It can be written as <code>AB</code> ( <code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are valid strings, or</li>
<li>It can be written as <code>(A)</code>, where <code>A</code> is a valid string.</li>
</ul>

<p>
<b>Example 1:</b>
</p>

<pre class="example" id="org6011810">
Input: s = "lee(t(c)o)de)"
Output: "lee(t(c)o)de"
Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.
</pre>

<p>
<b>Example 2:</b>
</p>

<pre class="example" id="orga7d20c1">
Input: s = "a)b(c)d"
Output: "ab(c)d"
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org2e8730d">
Input: s = "))(("
Output: ""
Explanation: An empty string is also valid.
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li><code>1 &lt;</code> s.length &lt;= 10⁵=</li>
<li><code>s[i]</code> is either <code>'('</code> , <code>')'</code>, or lowercase English letter.</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    string minRemoveToMakeValid(string s) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    string s;
    LeetCodeIO::scan(cin, s);

    Solution *obj = new Solution();
    auto res = obj-&gt;minRemoveToMakeValid(s);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-number-of-good-leaf-nodes-pairslink-medium" class="outline-3">
<h3 id="number-of-good-leaf-nodes-pairslink-medium"><span class="section-number-3">8.170.</span> <a href="https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/">1530. Number of Good Leaf Nodes Pairs</a> (Medium)</h3>
<div class="outline-text-3" id="text-number-of-good-leaf-nodes-pairslink-medium">
<p>
You are given the <code>root</code> of a binary tree and an integer <code>distance</code>. A pair of two different <b>leaf</b> nodes of a binary tree is said to be good if the length of <b>the shortest path</b> between them is less than or equal to <code>distance</code>.
</p>

<p>
Return the number of good leaf node pairs in the tree.
</p>

<p>
<b>Example 1:</b>
</p>


<div id="orgf84c43e" class="figure">
<p><img src="../Leetcode/src/1530.number-of-good-leaf-nodes-pairs/e1.jpg" alt="e1.jpg" />
</p>
</div>

<pre class="example" id="org0b7e1f8">
Input: root = [1,2,3,null,4], distance = 3
Output: 1
Explanation: The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them
is 3. This is the only good pair.
</pre>

<p>
<b>Example 2:</b>
</p>


<div id="orgf530004" class="figure">
<p><img src="../Leetcode/src/1530.number-of-good-leaf-nodes-pairs/e2.jpg" alt="e2.jpg" />
</p>
</div>

<pre class="example" id="org21bd3d8">
Input: root = [1,2,3,4,5,6,7], distance = 3
Output: 2
Explanation: The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good
because the length of ther shortest path between them is 4.
</pre>

<p>
<b>Example 3:</b>
</p>

<pre class="example" id="org4da6d71">
Input: root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3
Output: 1
Explanation: The only good pair is [2,5].
</pre>

<p>
<b>Constraints:</b>
</p>

<ul class="org-ul">
<li>The number of nodes in the <code>tree</code> is in the range <code>[1, 2¹⁰].</code></li>
<li><code>1 &lt;</code> Node.val &lt;= 100=</li>
<li><code>1 &lt;</code> distance &lt;= 10=</li>
</ul>

<p>
\newpage 
 <b>题解如下:</b> 
</p>
<div class="org-src-container">
<pre class="src src-C++">// -*- compile-command: "make -f ../Makefile submit" -*-
// https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/

#include &lt;bits/stdc++.h&gt;
#include "LC_IO.h"
using namespace std;

// @lc code=begin

class Solution {
public:
    int countPairs(TreeNode* root, int distance) {

    }
};

// @lc code=end

int main() {
    ios_base::sync_with_stdio(false);
    stringstream out_stream;

    TreeNode* root;
    LeetCodeIO::scan(cin, root);
    int distance;
    LeetCodeIO::scan(cin, distance);

    Solution *obj = new Solution();
    auto res = obj-&gt;countPairs(root, distance);
    LeetCodeIO::print(out_stream, res);
    cout &lt;&lt; "\noutput: " &lt;&lt; out_stream.rdbuf() &lt;&lt; endl;

    delete obj;
    return 0;
}
</pre>
</div>
<p>
\newpage
</p>
</div>
</div>
<div id="outline-container-org9dc7889" class="outline-3">
<h3 id="org9dc7889"><span class="section-number-3">8.171.</span> 设计刷题环境</h3>
<div class="outline-text-3" id="text-8-171">
</div>
<div id="outline-container-org845295e" class="outline-4">
<h4 id="org845295e"><span class="section-number-4">8.171.1.</span> leetgo</h4>
<div class="outline-text-4" id="text-8-171-1">
<p>
本来打算刷多门语言的，现在看了还是太高估自己了，把cpp刷好就可以了。
</p>

<ol class="org-ol">
<li>准备leetgo，使用leetgo init，默认的模板就行，没多少需要修改的，如果需要多语言的可以改out<sub>dir</sub>，cookie不用自己找在浏览器里登录就行。</li>

<li>准备emacs</li>
</ol>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defvar my/leetcode-root "~/leetcode/src/"
  "Root directory of leetgo-generated problems.")

(defun my/leetcode-format-number (n)
  "Return N formatted like 1 → \"0001\"."
  (format "%04d" n))

(defun my/leetcode--find-problem-dir (n)
  "Return directory path for problem number N."
  (let* ((prefix (my/leetcode-format-number n))
         (dirs (directory-files my/leetcode-root t
                                (concat "^" prefix "\\."))))
    (car dirs)))

(defun my/leetcode--pandoc-md-to-org (md-file org-file)
  "Convert MD-FILE → ORG-FILE using pandoc."
  (call-process "pandoc" nil nil nil md-file "-o" org-file "--wrap=none"))

(defun my/leetcode--download-image (url dest)
  "Download image URL to DEST file path."
  (url-copy-file url dest t))

(defun my/leetcode--process-org-images (org-file problem-dir)
  "Download remote images using wget and replace links with local filenames."
  (with-temp-buffer
    (insert-file-contents org-file)
    (goto-char (point-min))

    ;; 匹配所有 http 图片链接
    (while (re-search-forward "\\[\\[\\(https?://[^]]+\\.\\(png\\|jpg\\|jpeg\\|gif\\)\\)\\]\\]" nil t)
      (let* ((url (match-string 1))
             (filename (file-name-nondirectory url))  ;; 保留原始图片名
             (local-path (expand-file-name filename problem-dir)))

        ;; 如果图片不存在 -&gt; 用 wget 下载
        (unless (file-exists-p local-path)
          (message "Downloading image via wget: %s" url)
          (call-process "wget" nil nil nil "-q" "-O" local-path url))

        ;; 替换 org 链接为相对路径
        (replace-match (format "[[./%s]]" filename) t t)))

    (write-region (point-min) (point-max) org-file nil 'quiet)))

(defun my/leetcode-open (n)
  "Open Leetcode problem N. If not found, auto-fetch using `leetgo pick -l cpp N`."
  (interactive "nProblem number: ")
  (let* ((dir (my/leetcode--find-problem-dir n)))

    ;; If not found → auto call: leetgo pick -l cpp n
    (unless dir
      (message "Problem %d not found. Fetching via `leetgo pick -l cpp %d`..." n n)
      (let ((default-directory (expand-file-name "../" my/leetcode-root)))
        (call-process "leetgo" nil "*leetgo-pick*" t
                      "pick" "-l" "cpp" (number-to-string n)))
      ;; Re-scan after fetch
      (setq dir (my/leetcode--find-problem-dir n))
      (unless dir
        (error "After running `leetgo pick`, problem %d still not found. Check leetgo login." n)))

    ;; ---- If directory exists, continue normal code ----
    (let* ((md (expand-file-name "question.md" dir))
           (org (expand-file-name "question.org" dir))
           (cpp (expand-file-name "solution.cpp" dir)))

      ;; 1. Convert MD → ORG
      (my/leetcode--pandoc-md-to-org md org)

      ;; 2. Replace remote images → local images
      (my/leetcode--process-org-images org dir)

      ;; 3. Add include block to org
      (with-temp-buffer
        (insert-file-contents org)
        (goto-char (point-max))
        (insert "\n#+INCLUDE: \"./solution.cpp\" src cpp\n\n\\newpage")
        (write-region (point-min) (point-max) org nil 'quiet))

      ;; 4. Add compile-command to solution.cpp
      (with-temp-buffer
        (insert-file-contents cpp)
        (goto-char (point-min))
        (unless (looking-at "// -*- compile-command:")
          (insert "// -*- compile-command: \"make -f ../Makefile submit\" -*-\n"))
        (write-region (point-min) (point-max) cpp nil 'quiet))

      ;; 5. Open org and cpp buffers
      (find-file org)
      (save-window-excursion
        (find-file cpp))
      (message "Loaded LeetCode %d from %s" n dir))))

(defun my/leetcode-generate-includes ()
  "Generate #+INCLUDE lines for all LeetCode question org files."
  (let* ((root (expand-file-name "src" default-directory))
         (dirs (directory-files root t "^[0-9]+\\..+"))
         results)
    (dolist (d dirs (nreverse results))
      (let ((q (expand-file-name "question.org" d)))
        (when (file-exists-p q)
          (push (format "#+INCLUDE: \"%s\" :minlevel 1"
                        (file-relative-name q default-directory))
                results))))))

(defun my/leetcode-fetch-one-silent (n)
  "Fetch problem N silently (no opening buffers), generating question.org and downloading images."
  (let* ((dir (my/leetcode--find-problem-dir n)))

    ;; pick if missing
    (unless dir
      (message "Fetching %d via leetgo pick ..." n)
      (let ((default-directory (expand-file-name "../" my/leetcode-root)))
        (call-process "leetgo" nil nil nil "pick" "-l" "cpp" (number-to-string n)))
      (setq dir (my/leetcode--find-problem-dir n)))

    (unless dir
      (message "Failed to fetch problem %d" n)
      (cl-return-from my/leetcode-fetch-one-silent nil))

    (let* ((md (expand-file-name "question.md" dir))
           (org (expand-file-name "question.org" dir))
           (cpp (expand-file-name "solution.cpp" dir)))

      ;; convert
      (my/leetcode--pandoc-md-to-org md org)
      (my/leetcode--process-org-images org dir)

      ;; add include to org
      (with-temp-buffer
        (insert-file-contents org)
        (goto-char (point-max))
        (insert "\n**** Solution\n#+INCLUDE: \"./solution.cpp\" src cpp\n")
        (write-region (point-min) (point-max) org nil 'quiet))

      ;; add compile-command
      (with-temp-buffer
        (insert-file-contents cpp)
        (goto-char (point-min))
        (unless (looking-at "// -*- compile-command:")
          (insert "// -*- compile-command: \"make -f ../Makefile submit\" -*-\n"))
        (write-region (point-min) (point-max) cpp nil 'quiet)))

    (message "Fetched %d OK" n)))

(defun my/leetcode-fetch-batch (numbers)
  "Fetch multiple problems silently.
NUMBERS is a string like \"1 2 3 11 17 19\"."
  (interactive "sProblem numbers (e.g. \"1 2 3 11\"): ")
  (let ((nums (mapcar #'string-to-number (split-string numbers))))
    (dolist (n nums)
      (ignore-errors
        (my/leetcode-fetch-one-silent n))))
  (message "Batch fetch done."))

(defun my/leetcode-update-includes ()
  "Find marker '# begin of leetcode include', erase old includes, insert new ones."
#+INCLUDE: "src/0001.two-sum/question.org" :minlevel 2
#+INCLUDE: "src/0003.longest-substring-without-repeating-characters/question.org" :minlevel 2
#+INCLUDE: "src/0004.median-of-two-sorted-arrays/question.org" :minlevel 2
#+INCLUDE: "src/0005.longest-palindromic-substring/question.org" :minlevel 2
#+INCLUDE: "src/0010.regular-expression-matching/question.org" :minlevel 2
#+INCLUDE: "src/0015.3sum/question.org" :minlevel 2
#+INCLUDE: "src/0019.remove-nth-node-from-end-of-list/question.org" :minlevel 2
#+INCLUDE: "src/0020.valid-parentheses/question.org" :minlevel 2
#+INCLUDE: "src/0023.merge-k-sorted-lists/question.org" :minlevel 2
#+INCLUDE: "src/0028.find-the-index-of-the-first-occurrence-in-a-string/question.org" :minlevel 2
#+INCLUDE: "src/0034.find-first-and-last-position-of-element-in-sorted-array/question.org" :minlevel 2
#+INCLUDE: "src/0037.sudoku-solver/question.org" :minlevel 2
#+INCLUDE: "src/0040.combination-sum-ii/question.org" :minlevel 2
#+INCLUDE: "src/0046.permutations/question.org" :minlevel 2
#+INCLUDE: "src/0047.permutations-ii/question.org" :minlevel 2
#+INCLUDE: "src/0048.rotate-image/question.org" :minlevel 2
#+INCLUDE: "src/0051.n-queens/question.org" :minlevel 2
#+INCLUDE: "src/0053.maximum-subarray/question.org" :minlevel 2
#+INCLUDE: "src/0064.minimum-path-sum/question.org" :minlevel 2
#+INCLUDE: "src/0067.add-binary/question.org" :minlevel 2
#+INCLUDE: "src/0069.sqrtx/question.org" :minlevel 2
#+INCLUDE: "src/0070.climbing-stairs/question.org" :minlevel 2
#+INCLUDE: "src/0072.edit-distance/question.org" :minlevel 2
#+INCLUDE: "src/0075.sort-colors/question.org" :minlevel 2
#+INCLUDE: "src/0076.minimum-window-substring/question.org" :minlevel 2
#+INCLUDE: "src/0077.combinations/question.org" :minlevel 2
#+INCLUDE: "src/0079.word-search/question.org" :minlevel 2
#+INCLUDE: "src/0081.search-in-rotated-sorted-array-ii/question.org" :minlevel 2
#+INCLUDE: "src/0083.remove-duplicates-from-sorted-list/question.org" :minlevel 2
#+INCLUDE: "src/0088.merge-sorted-array/question.org" :minlevel 2
#+INCLUDE: "src/0091.decode-ways/question.org" :minlevel 2
#+INCLUDE: "src/0094.binary-tree-inorder-traversal/question.org" :minlevel 2
#+INCLUDE: "src/0099.recover-binary-search-tree/question.org" :minlevel 2
#+INCLUDE: "src/0101.symmetric-tree/question.org" :minlevel 2
#+INCLUDE: "src/0104.maximum-depth-of-binary-tree/question.org" :minlevel 2
#+INCLUDE: "src/0105.construct-binary-tree-from-preorder-and-inorder-traversal/question.org" :minlevel 2
#+INCLUDE: "src/0106.construct-binary-tree-from-inorder-and-postorder-traversal/question.org" :minlevel 2
#+INCLUDE: "src/0109.convert-sorted-list-to-binary-search-tree/question.org" :minlevel 2
#+INCLUDE: "src/0110.balanced-binary-tree/question.org" :minlevel 2
#+INCLUDE: "src/0121.best-time-to-buy-and-sell-stock/question.org" :minlevel 2
#+INCLUDE: "src/0122.best-time-to-buy-and-sell-stock-ii/question.org" :minlevel 2
#+INCLUDE: "src/0126.word-ladder-ii/question.org" :minlevel 2
#+INCLUDE: "src/0128.longest-consecutive-sequence/question.org" :minlevel 2
#+INCLUDE: "src/0130.surrounded-regions/question.org" :minlevel 2
#+INCLUDE: "src/0135.candy/question.org" :minlevel 2
#+INCLUDE: "src/0136.single-number/question.org" :minlevel 2
#+INCLUDE: "src/0139.word-break/question.org" :minlevel 2
#+INCLUDE: "src/0142.linked-list-cycle-ii/question.org" :minlevel 2
#+INCLUDE: "src/0144.binary-tree-preorder-traversal/question.org" :minlevel 2
#+INCLUDE: "src/0145.binary-tree-postorder-traversal/question.org" :minlevel 2
#+INCLUDE: "src/0146.lru-cache/question.org" :minlevel 2
#+INCLUDE: "src/0148.sort-list/question.org" :minlevel 2
#+INCLUDE: "src/0149.max-points-on-a-line/question.org" :minlevel 2
#+INCLUDE: "src/0154.find-minimum-in-rotated-sorted-array-ii/question.org" :minlevel 2
#+INCLUDE: "src/0155.min-stack/question.org" :minlevel 2
#+INCLUDE: "src/0162.find-peak-element/question.org" :minlevel 2
#+INCLUDE: "src/0167.two-sum-ii-input-array-is-sorted/question.org" :minlevel 2
#+INCLUDE: "src/0168.excel-sheet-column-title/question.org" :minlevel 2
#+INCLUDE: "src/0169.majority-element/question.org" :minlevel 2
#+INCLUDE: "src/0188.best-time-to-buy-and-sell-stock-iv/question.org" :minlevel 2
#+INCLUDE: "src/0190.reverse-bits/question.org" :minlevel 2
#+INCLUDE: "src/0198.house-robber/question.org" :minlevel 2
#+INCLUDE: "src/0202.happy-number/question.org" :minlevel 2
#+INCLUDE: "src/0205.isomorphic-strings/question.org" :minlevel 2
#+INCLUDE: "src/0208.implement-trie-prefix-tree/question.org" :minlevel 2
#+INCLUDE: "src/0210.course-schedule-ii/question.org" :minlevel 2
#+INCLUDE: "src/0213.house-robber-ii/question.org" :minlevel 2
#+INCLUDE: "src/0215.kth-largest-element-in-an-array/question.org" :minlevel 2
#+INCLUDE: "src/0217.contains-duplicate/question.org" :minlevel 2
#+INCLUDE: "src/0218.the-skyline-problem/question.org" :minlevel 2
#+INCLUDE: "src/0221.maximal-square/question.org" :minlevel 2
#+INCLUDE: "src/0225.implement-stack-using-queues/question.org" :minlevel 2
#+INCLUDE: "src/0226.invert-binary-tree/question.org" :minlevel 2
#+INCLUDE: "src/0227.basic-calculator-ii/question.org" :minlevel 2
#+INCLUDE: "src/0232.implement-queue-using-stacks/question.org" :minlevel 2
#+INCLUDE: "src/0235.lowest-common-ancestor-of-a-binary-search-tree/question.org" :minlevel 2
#+INCLUDE: "src/0236.lowest-common-ancestor-of-a-binary-tree/question.org" :minlevel 2
#+INCLUDE: "src/0238.product-of-array-except-self/question.org" :minlevel 2
#+INCLUDE: "src/0239.sliding-window-maximum/question.org" :minlevel 2
#+INCLUDE: "src/0240.search-a-2d-matrix-ii/question.org" :minlevel 2
#+INCLUDE: "src/0241.different-ways-to-add-parentheses/question.org" :minlevel 2
#+INCLUDE: "src/0242.valid-anagram/question.org" :minlevel 2
#+INCLUDE: "src/0257.binary-tree-paths/question.org" :minlevel 2
#+INCLUDE: "src/0260.single-number-iii/question.org" :minlevel 2
#+INCLUDE: "src/0268.missing-number/question.org" :minlevel 2
#+INCLUDE: "src/0279.perfect-squares/question.org" :minlevel 2
#+INCLUDE: "src/0287.find-the-duplicate-number/question.org" :minlevel 2
#+INCLUDE: "src/0300.longest-increasing-subsequence/question.org" :minlevel 2
#+INCLUDE: "src/0303.range-sum-query-immutable/question.org" :minlevel 2
#+INCLUDE: "src/0304.range-sum-query-2d-immutable/question.org" :minlevel 2
#+INCLUDE: "src/0307.range-sum-query-mutable/question.org" :minlevel 2
#+INCLUDE: "src/0309.best-time-to-buy-and-sell-stock-with-cooldown/question.org" :minlevel 2
#+INCLUDE: "src/0310.minimum-height-trees/question.org" :minlevel 2
#+INCLUDE: "src/0312.burst-balloons/question.org" :minlevel 2
#+INCLUDE: "src/0313.super-ugly-number/question.org" :minlevel 2
#+INCLUDE: "src/0318.maximum-product-of-word-lengths/question.org" :minlevel 2
#+INCLUDE: "src/0322.coin-change/question.org" :minlevel 2
#+INCLUDE: "src/0328.odd-even-linked-list/question.org" :minlevel 2
#+INCLUDE: "src/0332.reconstruct-itinerary/question.org" :minlevel 2
#+INCLUDE: "src/0338.counting-bits/question.org" :minlevel 2
#+INCLUDE: "src/0343.integer-break/question.org" :minlevel 2
#+INCLUDE: "src/0347.top-k-frequent-elements/question.org" :minlevel 2
#+INCLUDE: "src/0376.wiggle-subsequence/question.org" :minlevel 2
#+INCLUDE: "src/0377.combination-sum-iv/question.org" :minlevel 2
#+INCLUDE: "src/0380.insert-delete-getrandom-o1/question.org" :minlevel 2
#+INCLUDE: "src/0404.sum-of-left-leaves/question.org" :minlevel 2
#+INCLUDE: "src/0406.queue-reconstruction-by-height/question.org" :minlevel 2
#+INCLUDE: "src/0409.longest-palindrome/question.org" :minlevel 2
#+INCLUDE: "src/0413.arithmetic-slices/question.org" :minlevel 2
#+INCLUDE: "src/0416.partition-equal-subset-sum/question.org" :minlevel 2
#+INCLUDE: "src/0417.pacific-atlantic-water-flow/question.org" :minlevel 2
#+INCLUDE: "src/0432.all-oone-data-structure/question.org" :minlevel 2
#+INCLUDE: "src/0435.non-overlapping-intervals/question.org" :minlevel 2
#+INCLUDE: "src/0437.path-sum-iii/question.org" :minlevel 2
#+INCLUDE: "src/0448.find-all-numbers-disappeared-in-an-array/question.org" :minlevel 2
#+INCLUDE: "src/0450.delete-node-in-a-bst/question.org" :minlevel 2
#+INCLUDE: "src/0451.sort-characters-by-frequency/question.org" :minlevel 2
#+INCLUDE: "src/0452.minimum-number-of-arrows-to-burst-balloons/question.org" :minlevel 2
#+INCLUDE: "src/0455.assign-cookies/question.org" :minlevel 2
#+INCLUDE: "src/0461.hamming-distance/question.org" :minlevel 2
#+INCLUDE: "src/0462.minimum-moves-to-equal-array-elements-ii/question.org" :minlevel 2
#+INCLUDE: "src/0474.ones-and-zeroes/question.org" :minlevel 2
#+INCLUDE: "src/0476.number-complement/question.org" :minlevel 2
#+INCLUDE: "src/0494.target-sum/question.org" :minlevel 2
#+INCLUDE: "src/0503.next-greater-element-ii/question.org" :minlevel 2
#+INCLUDE: "src/0513.find-bottom-left-tree-value/question.org" :minlevel 2
#+INCLUDE: "src/0530.minimum-absolute-difference-in-bst/question.org" :minlevel 2
#+INCLUDE: "src/0538.convert-bst-to-greater-tree/question.org" :minlevel 2
#+INCLUDE: "src/0540.single-element-in-a-sorted-array/question.org" :minlevel 2
#+INCLUDE: "src/0542.01-matrix/question.org" :minlevel 2
#+INCLUDE: "src/0543.diameter-of-binary-tree/question.org" :minlevel 2
#+INCLUDE: "src/0547.number-of-provinces/question.org" :minlevel 2
#+INCLUDE: "src/0566.reshape-the-matrix/question.org" :minlevel 2
#+INCLUDE: "src/0572.subtree-of-another-tree/question.org" :minlevel 2
#+INCLUDE: "src/0583.delete-operation-for-two-strings/question.org" :minlevel 2
#+INCLUDE: "src/0594.longest-harmonious-subsequence/question.org" :minlevel 2
#+INCLUDE: "src/0605.can-place-flowers/question.org" :minlevel 2
#+INCLUDE: "src/0617.merge-two-binary-trees/question.org" :minlevel 2
#+INCLUDE: "src/0633.sum-of-square-numbers/question.org" :minlevel 2
#+INCLUDE: "src/0637.average-of-levels-in-binary-tree/question.org" :minlevel 2
#+INCLUDE: "src/0646.maximum-length-of-pair-chain/question.org" :minlevel 2
#+INCLUDE: "src/0647.palindromic-substrings/question.org" :minlevel 2
#+INCLUDE: "src/0650.2-keys-keyboard/question.org" :minlevel 2
#+INCLUDE: "src/0653.two-sum-iv-input-is-a-bst/question.org" :minlevel 2
#+INCLUDE: "src/0665.non-decreasing-array/question.org" :minlevel 2
#+INCLUDE: "src/0669.trim-a-binary-search-tree/question.org" :minlevel 2
#+INCLUDE: "src/0680.valid-palindrome-ii/question.org" :minlevel 2
#+INCLUDE: "src/0684.redundant-connection/question.org" :minlevel 2
#+INCLUDE: "src/0693.binary-number-with-alternating-bits/question.org" :minlevel 2
#+INCLUDE: "src/0695.max-area-of-island/question.org" :minlevel 2
#+INCLUDE: "src/0696.count-binary-substrings/question.org" :minlevel 2
#+INCLUDE: "src/0697.degree-of-an-array/question.org" :minlevel 2
#+INCLUDE: "src/0714.best-time-to-buy-and-sell-stock-with-transaction-fee/question.org" :minlevel 2
#+INCLUDE: "src/0739.daily-temperatures/question.org" :minlevel 2
#+INCLUDE: "src/0763.partition-labels/question.org" :minlevel 2
#+INCLUDE: "src/0769.max-chunks-to-make-sorted/question.org" :minlevel 2
#+INCLUDE: "src/0785.is-graph-bipartite/question.org" :minlevel 2
#+INCLUDE: "src/0870.advantage-shuffle/question.org" :minlevel 2
#+INCLUDE: "src/0882.reachable-nodes-in-subdivided-graph/question.org" :minlevel 2
#+INCLUDE: "src/0889.construct-binary-tree-from-preorder-and-postorder-traversal/question.org" :minlevel 2
#+INCLUDE: "src/0897.increasing-order-search-tree/question.org" :minlevel 2
#+INCLUDE: "src/0932.beautiful-array/question.org" :minlevel 2
#+INCLUDE: "src/0934.shortest-bridge/question.org" :minlevel 2
#+INCLUDE: "src/1091.shortest-path-in-binary-matrix/question.org" :minlevel 2
#+INCLUDE: "src/1105.filling-bookcase-shelves/question.org" :minlevel 2
#+INCLUDE: "src/1110.delete-nodes-and-return-forest/question.org" :minlevel 2
#+INCLUDE: "src/1143.longest-common-subsequence/question.org" :minlevel 2
#+INCLUDE: "src/1249.minimum-remove-to-make-valid-parentheses/question.org" :minlevel 2
#+INCLUDE: "src/1530.number-of-good-leaf-nodes-pairs/question.org" :minlevel 2
  (interactive)
  (save-excursion
    (goto-char (point-min))
    ;; 找到标记行
    (if (search-forward "# begin of leetcode include" nil t)
        (progn
          ;; 到下一行（开始删除旧的内容）
          (forward-line 1)

          ;; 记录起点
          (let ((start (point)))

            ;; 删除所有旧的 #+INCLUDE 行
            (while (looking-at "^#\\+INCLUDE:")
              (forward-line 1))
            (delete-region start (point))

            ;; 生成新的 include 内容
            (let* ((root (expand-file-name "src" default-directory))
                   (dirs (directory-files root t "^[0-9]+\\..+")))
              (dolist (d dirs)
                (let ((q (expand-file-name "question.org" d)))
                  (when (file-exists-p q)
                    (insert
                     (format "#+INCLUDE: \"%s\" :minlevel 2\n"
                             (file-relative-name q default-directory)))))))))
      (message "Marker '# begin of leetcode include' not found!"))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc53cfaa" class="outline-4">
<h4 id="orgc53cfaa"><span class="section-number-4">8.171.2.</span> 本地刷题测试</h4>
<div class="outline-text-4" id="text-8-171-2">
<p>
由于本人的网络不是24小时都有，所以有一个能本地刷题的方式就好了，用测试例测好，明天再提交到网页也不失为一种方法。
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>利用本地测试testcase.txt，先过本地才能上传网页</label><pre class="src src-awk">  BEGIN { testcase = 0; input_lines = ""; expected = ""; fail = 0 }

/^input:/ {
    testcase++;
    input_lines = "";
    expected = "";
    next
}

/^output:/ {
    getline expected;

    tmp = "/tmp/input_" testcase ".txt";
    print input_lines &gt; tmp;
    close(tmp);

    cmd = prog " &lt; " tmp;
    result = "";
    while ((cmd | getline line) &gt; 0) {
        if (result != "") result = result "\n";
        result = result line;
    }
    close(cmd);

    sub(/^output:[ \t]*/, "", result);
    sub(/[ \t\r\n]+$/, "", expected);

    if (result == expected) {
        print "Testcase " testcase " PASSED";
    } else {
        print "Testcase " testcase " FAILED";
        print "  Input: " input_lines;
        print "  Expected: " expected;
        print "  Got: " result;
        fail = 1   # 标记失败
    }
    next
}

{
    if (input_lines == "")
        input_lines = $0;
    else
        input_lines = input_lines "\n" $0;
}

END {
    if (fail) exit 1
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>用makefile测试，makefile知道是从那一个subdir传了的make指令</label><pre class="src src-makefile"># Current directory (e.g. 0001.two-sum)
CURDIR_NAME := $(notdir $(CURDIR))
# Extract part after first dot, e.g. "0001.two-sum" -&gt; "two-sum"
SPLIT_DIRNAME := $(word 2, $(subst ., ,$(CURDIR_NAME)))

a.out: solution.cpp
    $(CXX) solution.cpp -I.. -O2 -std=c++17 -Wall -o a.out

submit: testc
    leetgo submit  $(SPLIT_DIRNAME) -l cpp

testc: a.out
    @awk -v prog="./a.out" -f ../../tester.awk testcases.txt

# Default target
testr:
    cargo build --bin $(SPLIT_DIRNAME)
    awk -v prog="./../../target/debug/$(SPLIT_DIRNAME)" -f ../../tester.awk testcases.txt

</pre>
</div>

<p class="verse">
[-] Leetcode<br />
&#xa0;|&#x2013;[-] src<br />
&#xa0;|   |&#x2013;[+] 0001.two-sum<br />
&#xa0;|   |&#x2013;[+] 0002.add-two-numbers<br />
&#xa0;|   |&#x2013;[+] 0004.median-of-two-sorted-arrays<br />
&#xa0;|   |&#x2013;[+] 0005.longest-palindromic-substring<br />
&#xa0;|   |&#x2013;[+] 0006.zigzag-conversion<br />
&#xa0;|   |&#x2013;[+] bits<br />
&#xa0;|   |&#x2013;&#x2014; LC<sub>IO.h</sub><br />
&#xa0;|   `&#x2013;&#x2014; Makefile<br />
&#xa0;|&#x2013;[+] target<br />
&#xa0;|&#x2013;&#x2014; Cargo.lock<br />
&#xa0;|&#x2013;&#x2014; Cargo.toml<br />
&#xa0;|&#x2013;&#x2014; README.org<br />
&#xa0;|&#x2013;&#x2014; hh.elc<br />
&#xa0;|&#x2013;&#x2014; leetgo.yaml<br />
&#xa0;`&#x2013;&#x2014; tester.awk<br />
<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org4153af8" class="outline-2">
<h2 id="org4153af8"><span class="section-number-2">9.</span> 版本更新历史</h2>
<div class="outline-text-2" id="text-9">
<p>
\datechange{2025-11-25}{晴}
</p>
<ul class="org-ul">
<li><b>走路</b>: 晚上和母亲一起在江边走路，她抱怨太远了，脚得走痛了，但还是我陪走完了一圈。我想我是很幸福的，有这样的母亲，虽然嘴碎但还是能陪伴我一行，在冷清的江边，只有两三个跑者与我俩，冬天好像萧条不少。我抡或背着二锤，吃了两个别人落下的柑子，敲敲死树、木桩，在草坪上练练投掷，作壶铃溜两下，中午还曾晒过太阳，晚上吃了红烧鱼，一天就这样，简单。简单也没什么不好，看着那些黄毛和抽烟的女友在摩托上追江风，也许他们的母亲就没有这样的耐心了，当然也许他们自己也无法耐受半小时的无聊，母亲不爱自己放荡的儿子，儿子不耐自己老气的母亲。吹着江风，默默无语的草和人在行走着，灯光亮着一路，一切干净又闲适，又有什么无聊呢?</li>
<li><b>Github</b>: 逛Github其实是最浪费时间的事，因为github就是伪装成编程平台的社交媒体。
<dl class="org-dl">
<dt>为feature点赞</dt><dd>为爱豆的新推点赞</dd>
<dt>为语言传教</dt><dd>为爱豆打call</dd>
<dt>awesome-xx</dt><dd>爱豆图集合订本</dd>
<dt>上传toy project</dt><dd>自己为爱豆做的周边</dd>
<dt>争论语言/编辑器/操作系统/etc</dt><dd>争论韩流/日流/欧美圈/内娱…</dd>
<dt>新工具新框架</dt><dd>网红</dd>
<dt>学习分享</dt><dd>卖课网红</dd>
<dt>开源学习分享</dt><dd>盗版卖课网红</dd>
<dt>discuss/issue</dt><dd>粉丝群群管理答疑</dd>
<dt>(no term)</dt><dd>怎么不把github当成社交媒体?
<dl class="org-dl">
<dt>什么是社交媒体</dt><dd>交互性/排名性/圈子化/免费/易得…
<ul class="org-ul">
<li>不交互
<dl class="org-dl">
<dt>不点赞</dt><dd>作个局外人，它好它坏不必说。</dd>
<dt>不乱传项目</dt><dd>少乱写代码上传github，少立flag。</dd>
<dt>把author看作工具人而不是教主</dt><dd>当然有问题还是得说thanks。</dd>
</dl></li>
<li>不排名
<dl class="org-dl">
<dt>不看star/awesome/trend/weekly</dt><dd>github 项目大多只是 blog。</dd>
<dt>绝不看中文github</dt><dd>中文自带传销属性。</dd>
</dl></li>
<li>不易得
<dl class="org-dl">
<dt>用consult-gh/forge/eww</dt><dd>一分钟加载一个页面…</dd>
</dl></li>
<li>不圈子
<dl class="org-dl">
<dt>工具论</dt><dd>一切只是工具，工具只是乐趣，乐趣不是越多越好。</dd>
</dl></li>
</ul></dd>
</dl></dd>
</dl></li>
</ul>

<p>
\datechange{2025-11-23}{阴}
</p>
<ul class="org-ul">
<li><b>leetcode</b>: 把题都抓完了，这还不开刷开学，想后半生吃草?</li>
<li><b>配emacs</b>:  翻了半天别人的配置，就找两包git-link，git-timemachine感觉不错。</li>
</ul>

<p>
\datechange{2025-11-22}{晴}
</p>
<ul class="org-ul">
<li><b>C语言</b>: 对C语言的复习还没开始。 <b>妈的，互联网</b></li>
<li><b>leetcode</b>: 完成了0题。 <b>妈的，互联网</b></li>
<li><b>又后悔了</b>: 本地有chromium，hosts06忘了加，想用chromium看一下翻墙网站的兼容性，莫名发现谷歌搜索能用，又看起片来!</li>
<li><b>从今天起</b>: 能只用emacs就只用emacs，能只用eww就只用eww，能问gptel就只问gptel。eww不能访问也别去试firefox，firefox不能访问也别去试chromium。</li>
</ul>

<p>
\datechange{2025-11-21}{晴}
</p>
<ul class="org-ul">
<li><b>域名</b>: 为 columndeeply/hosts 提交了17868行新域名，这个 hosts 是我最近在网上看到的最大的 host 文件，达到了近410mb ，共12.576.671 行，专门用于 Porn ，今天比较闲就把之前使用 tempermonkey 写的自动根据关键词用 ublacklist 自动 block 和从 fackads/和 github u3m8 collection 提出来的 cdn 网站和以前又闲又愤青时期屏蔽的各种网站，进行比较有二万三千行的不同 host ，用后缀比如 gov/org/cn 过滤了一些自己动手又删了些，发现像很多云很多热门网站像 cloud.tencent.com./taobao/nvidia/xx.gov.cn 但用了这么久好像没有任何冲突，可能是我实在是没有怎么上网，只是用用 github 就够了。看起来很多，17868行，几天检查不完，但是也就只是它的703分之一，我看了下很多是 blogspot/tumblr ，互联网的域名真得是故意弄成这样难管? 如果说 porn 的域名长成这样: 028b2c9ad2a24433ab97b8e5dbf69597.mediatailor.us-east-1.amazonaws.com(这还真是 porn)，这能管? 设立 whitelist 比 blacklist 更容易，但网络的架构(tcp/ip-dns-domain)就不允许这种事，我也好久没有更新我的host了，用ai比用搜索引索好用多了，ai的用处就是过滤黄色网站，当然openai要开放成人内容这事说明: 其实也没什么一定得搜的事。用emacs看文档，把记忆留在自己的脑子里，比起什么网页要重要的多。</li>
<li><b>折腾emacs</b>: iedit/embark-next-symbol/forge。</li>
<li><b>弄完了leetgo</b>: 明天绝对开始刷题。</li>
<li><b>研究了github热门trending</b>: 发现中文代码质量之差，全是卖课/卖舆论分析/卖盗版书pdf/卖前端ai的… fork外国大神后各种引流的，ruanyifeng周刊是可以的，但评论和想让他在issue里引流的项目也一言难尽的，看看nixpkg几千人才22k星，中文的一个openwrt教程就有30k星几百个人contribute，看看openai也才几十k星，deepseek上百k的星，看看各自的issues，openai很正常，deepseek就好似精神病的故乡，冷清又时不时出来几个弱智问题，外国人看了怕是会笑掉大牙。</li>
</ul>

<p>
\datechange{2025-11-20}{晴}
</p>
<ul class="org-ul">
<li><b>leetcode</b>: 完成对 leetgo工具的elisp改造。chatgpt很给力。明天一定刷leecode。</li>
<li><b>real-mono-themes</b>: 今日maintiner还没有动，看来工作很忙啊。</li>
<li><b>博客/pdf</b>: 加入了新的org snippest，更深入学习了org转入latex更多方法，更完美的使用了本latex模板。</li>
</ul>

<p>
\datechange{2025-11-19}{晴}
</p>
<ul class="org-ul">
<li><b>天气好，玩了一下午</b>: 结果踩在沥水槽腿掉下去了，还好只是擦伤。</li>
<li><b>leetcode</b>: 让chatgpt写leetgo的elisp工具，写到最后凌晨没网了!</li>
<li><b>后悔的一天</b>: reddit里的china\<sub>irl我常常去看</sub>，实在是没意思，但总有一种引力让我去刷，莫名的又想看片，于是乎又成了看片加键政，什么高市什么献忠，吃瓜吃到10年的兽兽门，再看现在的其他事件，感觉10年代清新多了，那时候的主角还是87年“小妹”，现在则是0几年的“小妹”，真是世风日下，历史重是重复又重复，技术重是加强又如强啊，献忠机器人，何时到来? 假韩炳哲的话改下: “互联网让道德世风内涵成了空气，一切除了炫/爽/性没有他用”。</li>
<li><b>折腾nixos/emacs</b>: 精简所有文件到博客这一个仓库。</li>
</ul>
<p>
nixos只用一个flake.nix和secrets.yaml再把一串key放到一个位置就能用了，简直是极简完了。
emacs只用一个post-init.init，再git clone下minimal-emacs到位，org再src运行一下，就能用了。
这两都是2000行的配置。总之我有了一个blog/pdf/emacs/nixos/snippest/hosts集于一体的仓库。完全可重现，从配置到经历，其它的代码也可以从其它repo里clone下来，但总之目前这些就是我大学大概折腾的所有玩具了吧。越说越感自己的脑残了，明明有女生喜欢我，我只有折腾这些sb玩意去了! 现在想起了，后悔得我都成了反科技主义了。
</p>
<ul class="org-ul">
<li><b>越说越后悔</b>: 总之，刷题刷项目，早点找工作，早点重新联系她。别再做reddit上的支人了… 别再看什么瓜片了… 反技术的后果就是“深山老林里的怪人”!!! 第一，你还有家人要养，第二，你也没生存能力，第三，我还是渴望家庭，第四，你都花了二十多年在技术上，现在去深山，那你学的拼音/加法/英文/编程都是屁吗?</li>
</ul>

<p>
\datechange{2025-11-18}{阴}
</p>
<ul class="org-ul">
<li><b>沉迷看书</b><sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup> 错过了我设定的上网时间二点到五点<sup><a id="fnr.6" class="footref" href="#fn.6" role="doc-backlink">6</a></sup>… 明天再测试吧<sup><a id="fnr.7" class="footref" href="#fn.7" role="doc-backlink">7</a></sup></li>
<li><b>C语言</b>: 刷一遍flag代码，发现自己还是不太懂C语言。今天又没刷力扣，感觉自己很废，就这样还想搞什么?</li>
</ul>

<p>
\datechange{2025/11/17}{雨}
</p>
<ul class="org-ul">
<li><b>开始刷Leetcode</b>: 完成0题，折腾leetgo去了，使用async-shell-command与emacs不全好用，两者的时间不一致问题，shell-command又卡emacs本身，两者同样不能管理弹出的shell输出。只能用完整的shell命令和在async里eval emacs function套娃看看。</li>
<li><b>将本“博客”的html和pdf上传了github.io</b>: 只是不只为何几十分钟了 qingsongliao.github.io 还没有，明天再看吧。</li>
<li><b>完成了real-mono-themes的emac主题包</b>: 从此emacs又多了个别具一格的主题，不过也许70年代的emacs就长这样吧，oldfasion never die。</li>
</ul>


<div id="org8b1e6a6" class="figure">
<p><img src="./figure/real-mono-old.png" alt="real-mono-old.png" />
</p>
<p><span class="figure-number">Figure 7: </span>real-mono-old</p>
</div>

<p>
\datechange{2025/11/16}{阴}
</p>
<ul class="org-ul">
<li><b>开始写作</b></li>
<li><b>使用elegent模板</b>: 搭建自己博客? 写书还是写博客? 干脆一起写吧。</li>
</ul>

<p>
\nocite{*}
\printbibliography[heading=bibintoc, title=\ebibname]
\appendix
</p>
</div>
</div>
<div id="outline-container-org76d8830" class="outline-2">
<h2 id="org76d8830"><span class="section-number-2">10.</span> 开发中遇见的各种软件问题</h2>
<div class="outline-text-2" id="text-10">
</div>
<div id="outline-container-org8ba6314" class="outline-4">
<h4 id="org8ba6314"><span class="section-number-4">10.0.1.</span> General Contributions</h4>
<div class="outline-text-4" id="text-10-0-1">
<ul class="org-ul">
<li class="off"><code>[&#xa0;]</code> org-mode，提交pr增加INCLUDE的行末倒数行数的行为代码x, 加入mailing-list提出FR</li>
<li class="off"><code>[&#xa0;]</code> melpa，提交pr增加自己的leetgo package</li>
<li class="on"><code>[X]</code> consult-gh ，提交pr修改readme中的consult-gh-search-code的使用</li>
<li class="on"><code>[X]</code> melpa，提交pr增加自己的real-mono-themes</li>
<li class="on"><code>[X]</code> nixpkg，提交issue增加biospy等nix生理信号包</li>
<li class="on"><code>[X]</code> columndeeply/hosts，提交pr增加17868行新域名,修改脚本为0.0.0.0</li>
<li class="on"><code>[X]</code> pyim，提交issue修改%报错行为</li>
<li class="on"><code>[X]</code> addons.mozilla，eink插件</li>
</ul>
</div>
</div>
<div id="outline-container-orgeec844a" class="outline-4">
<h4 id="orgeec844a"><span class="section-number-4">10.0.2.</span> <span class="todo TODO">TODO</span> Advent of code in zig?</h4>
</div>
<div id="outline-container-org09a53ba" class="outline-4">
<h4 id="org09a53ba"><span class="section-number-4">10.0.3.</span> <span class="todo TODO">TODO</span> package leego elisp package as emacs package</h4>
<div class="outline-text-4" id="text-10-0-3">
<ul class="org-ul">
<li>description: do leetcode in emacs with leetgo</li>
<li>require: wget/pandoc/leetgo/</li>
<li>wget for fetch image</li>
<li>pandoc for markdown to org</li>
<li>leetgo for pick/commit questions</li>
<li>simple init, use leetgo</li>
<li>batch fetch, (leetcode-fetch-batch "1 2 3") to fetch 1/2/3 questions</li>
<li>also you can fetch contest,</li>
<li>auto detected browser cookie, no need to fill cookies by yourself</li>
<li>offline test, use pre fetched testcase/makefile/awk to local test tasks.</li>
<li>org format, local image, and generally you can easily export all questions.</li>
<li>wait I finished doing leetcode</li>
</ul>
</div>
</div>
<div id="outline-container-org7a74304" class="outline-4">
<h4 id="org7a74304"><span class="section-number-4">10.0.4.</span> <span class="done FIXME">FIXME</span> How to modify org-mode's #+INCLUDE:</h4>
<div class="outline-text-4" id="text-10-0-4">
</div>
<ol class="org-ol">
<li><a id="org71785a3"></a>how to contribute to org<br />
<div class="outline-text-5" id="text-10-0-4-1">
<p>
<a href="https://orgmode.org/worg/org-contribute.html">https://orgmode.org/worg/org-contribute.html</a>
<a href="https://orgmode.org/worg/org-mailing-list.html">https://orgmode.org/worg/org-mailing-list.html</a>
</p>
</div>
</li>
<li><a id="org5d669ef"></a>explain FR<br />
<div class="outline-text-5" id="text-10-0-4-2">
<p>
<b><b>Subject:</b></b> [FR] Add support for reverse (negative) line ranges in `#+INCLUDE:` `:lines`
</p>

<p>
Hi all,
</p>

<p>
Org’s current `#+INCLUDE:` keyword supports selecting lines using the `:lines` parameter, e.g.:
</p>

<ul class="org-ul">
<li>`5-10` — lines 5 to 10</li>
<li>`-10` — lines 1 to 10</li>
<li>`10-` — line 10 to EOF</li>
</ul>

<p>
However, Org currently does <b><b>not</b></b> support selecting lines counted from the end of the file.
</p>

<p>
I would like to propose extending the syntax to support “reverse line numbers”, similar to how many tools allow negative indexing. Examples:
</p>

<pre class="example" id="orgbf01448">
#+INCLUDE: "x.txt" :lines "~5-"      ; last 5 lines to EOF
#+INCLUDE: "x.txt" :lines "~5-~1"   ; last 5 lines to last 1 line
#+INCLUDE: "x.txt" :lines "-~5"     ; from beginning to last 5 lines
#+INCLUDE: "x.txt" :lines "10-~1"   ; from line 10 to last 1 line
</pre>

<p>
This would make it much easier to include “the last N lines” of logs, datasets, generated files, etc., without needing to preprocess the file externally.
</p>

<p>
If there is interest, I would be happy to help test or contribute patches.
</p>

<p>
Thanks!
—Qingsong
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgdb7606e" class="outline-4">
<h4 id="orgdb7606e"><span class="section-number-4">10.0.5.</span> <span class="todo DONE">DONE</span> how many hours of pc idle's power consumption is equal to hibernate save ram to disk?</h4>
</div>
<div id="outline-container-org54d4401" class="outline-4">
<h4 id="org54d4401"><span class="section-number-4">10.0.6.</span> <span class="todo DONE">DONE</span> almost same vscode-emacs package.</h4>
</div>
<div id="outline-container-org2b522ae" class="outline-4">
<h4 id="org2b522ae"><span class="section-number-4">10.0.7.</span> <span class="todo DONE">DONE</span> how to run current region's content (if not in region, run that line) into current project's vterm</h4>
<div class="outline-text-4" id="text-10-0-7">
<p>
current I get a command called "multi-vterm-project", when you are not in vterm and vterm is closed use multi-vterm-project to open(or turn on a vterm project shell window) it, and can use it again to toggle it close(not kill, just remove that window), if the project vterm winodw is open and cursor is not in that window, use multi-vterm-project will focus to vterm window. based on this, I want you to write run the current region/line's content into vterm, how it works?
</p>

<p>
Below is the exact design that matches your workflow <b><b>with `multi-vterm-project` already handling window creation/toggle/focus</b></b>.
You only need a function that:
</p>

<ol class="org-ol">
<li>Ensures the project vterm exists (by calling `multi-vterm-project` when needed).</li>
<li>Gets the project vterm buffer.</li>
<li>Sends region or current line.</li>
<li>Does not change your current window unless the vterm does not yet exist.</li>
<li>If the vterm window is already visible but not focused, <b><b>do not move focus</b></b>; only send text.</li>
</ol>

<p>
Assumption:
`multi-vterm-project` creates or returns a vterm buffer named like `*vterm-project: &lt;project&gt;*`.
If your naming differs, adjust the regexp.
</p>

<p>
Code:
</p>

<p>
```elisp
(require 'project)
(require 'vterm)
(require 'multi-vterm)
</p>

<p>
(defun my/get-project-vterm-buffer ()
  "Return the project vterm buffer, or nil if not exists."
  (let* ((proj (project-current t))
         (root (project-root proj))
         (name (file-name-nondirectory (directory-file-name root))))
    (catch 'found
      (dolist (buf (buffer-list))
        (when (string-match (format "\\*vterm-project: %s" name)
                            (buffer-name buf))
          (throw 'found buf)))
      nil)))
</p>

<p>
(defun my/ensure-project-vterm ()
  "Ensure project vterm exists. Do NOT focus it if already exists."
  (let ((buf (my/get-project-vterm-buffer)))
    (unless buf
      ;; Creates and shows it. Your toggle logic is inside multi-vterm-project.
      (multi-vterm-project)
      (setq buf (my/get-project-vterm-buffer)))
    buf))
</p>

<p>
(defun my/send-region-or-line-to-project-vterm ()
  "Send active region or current line to project vterm.
Does not move focus unless no vterm existed."
  (interactive)
  (let* ((text (if (use-region-p)
                   (buffer-substring-no-properties
                    (region-beginning) (region-end))
                 (buffer-substring-no-properties
                  (line-beginning-position) (line-end-position)))))
    ;; Make sure vterm exists
    (let ((vbuf (my/ensure-project-vterm)))
      (when vbuf
        (with-current-buffer vbuf
          (vterm-send-string text)
          (vterm-send-return))))))
</p>

<p>
(global-set-key (kbd "C-c e") #'my/send-region-or-line-to-project-vterm)
```
</p>

<p>
Operation summary:
</p>

<p>
If project vterm <b><b>does not exist</b></b>, this creates it by calling `multi-vterm-project`.
If project vterm <b><b>exists but hidden</b></b>, the function does not toggle it; it simply sends text silently.
If project vterm <b><b>exists and is visible</b></b>, the function does not steal focus; it sends text in place.
Region has priority. No region → send current line.
</p>

<p>
This integrates cleanly with your workflow where `multi-vterm-project` handles all window toggle/focus behavior.
</p>
</div>
</div>
<div id="outline-container-org34ecde9" class="outline-4">
<h4 id="org34ecde9"><span class="section-number-4">10.0.8.</span> <span class="todo DONE">DONE</span> pyim % 字符触发 Not enough arguments for format string</h4>
<div class="outline-text-4" id="text-10-0-8">
<p>
使用虎码码表<a href="https://github.com/welandx/huma-danzi.pyim%EF%BC%8C%E5%90%8C%E6%A0%B7%E4%BD%BF%E7%94%A8%E5%85%B6readme%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE">https://github.com/welandx/huma-danzi.pyim%EF%BC%8C%E5%90%8C%E6%A0%B7%E4%BD%BF%E7%94%A8%E5%85%B6readme%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE</a>
发现输入l时报错:
Debugger entered&#x2013;Lisp error: (error "Not enough arguments for format string")
  message("[l              ]: 1.而 2.% (1/1) $ ")
  #f(compiled-function (string position tooltip) "使用 minibuffer 来显示 STRING。" #&lt;bytecode -0x26f1e7f81176ed3&gt;)("[l              ]: 1.而 2.% (1/1) $ " 620 minibuffer)
  apply(#f(compiled-function (string position tooltip) "使用 minibuffer 来显示 STRING。" #&lt;bytecode -0x26f1e7f81176ed3&gt;) "[l              ]: 1.而 2.% (1/1) $ " 620 minibuffer nil)
  pyim-page-show("[l              ]: 1.而 2.% (1/1) $ " 620 minibuffer)
  pyim-page&#x2013;refresh(nil)
  pyim-process-ui-refresh()
  pyim-process-run()
  pyim-self-insert-command()
  funcall-interactively(pyim-self-insert-command)
  call-interactively(pyim-self-insert-command)
  pyim-process-input-method(108)
  pyim-input-method(108)
</p>

<p>
删除hmdz.pyim中的%或使用中文的％使用时不会报错，发现pyim 有 %  就报错:
Debugger entered&#x2013;Lisp error: (error "Not enough arguments for format string")
  message("[l              ]: 1.% (1/1) $ ")
  #f(compiled-function (string position tooltip) "使用 minibuffer 来显示 STRING。" #&lt;bytecode 0x1d8cdaf8ba1c112a&gt;)("[l              ]: 1.% (1/1) $ " 624 minibuffer)
  apply(#f(compiled-function (string position tooltip) "使用 minibuffer 来显示 STRING。" #&lt;bytecode 0x1d8cdaf8ba1c112a&gt;) "[l              ]: 1.% (1/1) $ " 624 minibuffer nil)
  pyim-page-show("[l              ]: 1.% (1/1) $ " 624 minibuffer)
  pyim-page&#x2013;refresh(nil)
  pyim-process-ui-refresh()
  pyim-process-run()
  pyim-self-insert-command()
  funcall-interactively(pyim-self-insert-command)
  call-interactively(pyim-self-insert-command)
  pyim-process-input-method(108)
  pyim-input-method(108)
</p>
</div>
</div>
<div id="outline-container-orgfbfb7c0" class="outline-4">
<h4 id="orgfbfb7c0"><span class="section-number-4">10.0.9.</span> <span class="todo DONE">DONE</span> explain this wget command</h4>
<div class="outline-text-4" id="text-10-0-9">
<p>
wget -r -p -np -k &lt;url&gt;
含义：
</p>

<p>
-r
启用递归下载。
会下载 &lt;url&gt; 页面以及它引用的其他页面或资源（根据递归规则）。
</p>

<p>
-p
下载页面显示所需的所有资源。
包括图片、CSS、JS、字体等。
这是“下载完整页面以便离线浏览”的选项。
</p>

<p>
-np
不进入父目录（no parent）。
递归下载时不会爬到 &lt;url&gt; 的上级目录。
例如：
如果 &lt;url&gt; 是 <a href="http://example.com/a/b/page.html">http://example.com/a/b/page.html</a>
它不会下载 <a href="http://example.com/a/">http://example.com/a/</a> 或 <a href="http://example.com/">http://example.com/</a> 下的内容。
</p>

<p>
-k
转换下载后的链接为本地相对路径。
方便本地离线浏览时页面中的链接仍然能点击访问
</p>
</div>
</div>
<div id="outline-container-orgde429ec" class="outline-4">
<h4 id="orgde429ec"><span class="section-number-4">10.0.10.</span> <span class="todo DONE">DONE</span> how to do emacs overlay in nixos to config not to have somepackage natively exclude</h4>
<div class="outline-text-4" id="text-10-0-10">
<p>
how to disable gomoku, I am getting addiction to that game&#x2026;
</p>
</div>
</div>
<div id="outline-container-org510f7c5" class="outline-4">
<h4 id="org510f7c5"><span class="section-number-4">10.0.11.</span> <span class="todo DONE">DONE</span> using consult-gh-notifications, and I just type wrong pass as my own pc's pass, not github token</h4>
<div class="outline-text-4" id="text-10-0-11">
<p>
it used to pop a dialog box at first time, then I input my linux user's password, then it just disappered.
why? I want to reinput, but it just no dialog anymore and it just show me:
ghub&#x2013;handle-response-error: HTTP Error: 403, "Forbidden", "<a href="https://api.github.com/graphql">https://api.github.com/graphql</a>", ((message . "Request forbidden by administrative rules. Please make sure your request has a User-Agent header (<a href="https://docs.github.com/en/rest/overview/resources-in-the-rest-api#user-agent-required">https://docs.github.com/en/rest/overview/resources-in-the-rest-api#user-agent-required</a>). Check <a href="https://developer.github.com">https://developer.github.com</a> for other possible causes.") (documentation<sub>url</sub> . "<a href="https://github.com/magit/ghub/wiki/Github-Errors">https://github.com/magit/ghub/wiki/Github-Errors</a>"))
</p>

<p>
it's the issue of url-user-agent.
</p>
</div>
</div>
<div id="outline-container-org3495b77" class="outline-4">
<h4 id="org3495b77"><span class="section-number-4">10.0.12.</span> <span class="todo DONE">DONE</span> how the  ~/.mozilla/firefox/profiles.ini looks like?</h4>
<div class="outline-text-4" id="text-10-0-12">
<p>
the profiles name is set in nix as " profiles.firefox = {", I want you to write the default looks of that file.
</p>
<p class="verse">
[General]<br />
StartWithLastProfile=1<br />
<br />
[Profile0]<br />
Name=firefox<br />
IsRelative=1<br />
Path=firefox<br />
Default=1<br />
</p>
</div>
</div>
<div id="outline-container-orga7e1a4a" class="outline-4">
<h4 id="orga7e1a4a"><span class="section-number-4">10.0.13.</span> <span class="todo DONE">DONE</span> add sway emacs pkg?</h4>
</div>
<div id="outline-container-orge26cab6" class="outline-4">
<h4 id="orge26cab6"><span class="section-number-4">10.0.14.</span> <span class="todo DONE">DONE</span> how to make rm safer?</h4>
<div class="outline-text-4" id="text-10-0-14">
<p>
let rm delete file to trash
just don't use term+shell directly, use dired/magit&#x2026;
</p>
</div>
</div>
<div id="outline-container-org4f21189" class="outline-4">
<h4 id="org4f21189"><span class="section-number-4">10.0.15.</span> <span class="todo DONE">DONE</span> recentf moving file persisnt</h4>
<div class="outline-text-4" id="text-10-0-15">
<p>
every time I move my file and the path changed but the recentf didn't follow, causing production and memory lost.
just maintin my own recentf list.
</p>
</div>
</div>
<div id="outline-container-org7c04584" class="outline-4">
<h4 id="org7c04584"><span class="section-number-4">10.0.16.</span> <span class="todo DONE">DONE</span> pull request to the porn site list project</h4>
<div class="outline-text-4" id="text-10-0-16">
<p>
fix the columndeeply/hosts 's 127.0.0.0 to 0.0.0.0
</p>

<p>
by clone and compare the problem is that "I include a lost non-porn site in to it".
not just "non-porn" sites, I also get a lot cdn server to block, which fetch from a lot of m3u8 streaming server. it may also block some movies which using the same server as porn sites&#x2026;
so, there is only KLUDGE for thing like blocking porn site, first question: what is porn? really?
to be, the social media like twitter which spread sexual clip? the pornhub teaching mathmatic? the reddit/4chan/zhihu/weibo/&#x2026; even the taobao can sell sex toys with sexual pictures, so blocking internet is blocking porn really? I don't know, it's a question for everyone.
</p>

<p>
finished, by
</p>

<div class="org-src-container">
<pre class="src src-sh">  #!/usr/bin/env bash
set -euo pipefail

HOST_URLS=(
  "https://raw.githubusercontent.com/columndeeply/hosts/main/hosts00"
  "https://raw.githubusercontent.com/columndeeply/hosts/main/hosts01"
  "https://raw.githubusercontent.com/columndeeply/hosts/main/hosts02"
  "https://raw.githubusercontent.com/columndeeply/hosts/main/hosts03"
  "https://raw.githubusercontent.com/columndeeply/hosts/main/hosts04"
  "https://raw.githubusercontent.com/columndeeply/hosts/main/hosts05"
)

TMPDIR="$(mktemp -d)"
REMOTE_DOMAINS="$TMPDIR/remote_domains"
YOUR_DOMAINS="$TMPDIR/your_domains"
OUTPUT="hosts6"

echo "[*] Downloading hostlists..."
&gt; "$REMOTE_DOMAINS"
for url in "${HOST_URLS[@]}"; do
    echo "    -&gt; $url"
    curl -sL "$url" \
        | grep -E "^[0-9:\.]+" \
        | awk '{print $2}' \
        &gt;&gt; "$REMOTE_DOMAINS"
done

echo "[*] Normalizing remote domains..."
sort -u "$REMOTE_DOMAINS" &gt; "$TMPDIR/remote_sorted"

echo "[*] Extracting your domains..."
grep -E "^[0-9:\.]+" /etc/hosts \
    | awk '{print $2}' \
    | sort -u \
    &gt; "$YOUR_DOMAINS"

echo "[*] Generating unique domains (hosts6)..."
comm -23 "$YOUR_DOMAINS" "$TMPDIR/remote_sorted" \
    | awk '{print "0.0.0.0", $1}' \
    &gt; "$OUTPUT"

echo "[+] Done. Unique domains saved in $OUTPUT"
echo "    Total: $(wc -l &lt; "$OUTPUT")"

</pre>
</div>

<p>
get uniq hosts, and update to github. it's I only get 23240 unique lines.
</p>

<p>
add 17868 new hosts
</p>

<p>
Used to maintain my hostslist, write a tempermonkey script with ublacklist addon to block chinese keyword search result automatically.
</p>

<p>
mainly it blocked sexual model gallary sites/Pirate JAV/and chinese porn m3u8 CDN which I filter from a github m3u8 collection repos/or anything non-programming like socialmedia/news/shopping&#x2026;, occationally the script blocks org/edu/gov sites too.
</p>

<p>
I remove duplicate hosts in yours and delete non-porn sites, but there still too many which I can't checkout they all.
</p>

<p>
BTW, I didn't update my hostslist for a long time, because I just find blocking search engine and "hot" social-media instead porn sites is way more easier, I now use tavily/chatgpt/github in emacs only.
</p>

<p>
BTW, seems like use 0.0.0.0 instaed of 127.0.0.1 is faster.
</p>
</div>
</div>
<div id="outline-container-orgf6ff9bc" class="outline-4">
<h4 id="orgf6ff9bc"><span class="section-number-4">10.0.17.</span> <span class="todo DONE">DONE</span> make <a href="file:///home/leeao/Leere/Leetcode/README.html">Leetcode</a> fresh tasks list</h4>
<div class="outline-text-4" id="text-10-0-17">
<ul class="org-ul">
<li>have already?</li>
<li>yes/no, yes, edit that file, no, get the files(testcase/question.md/solution.xxx)</li>
<li>edit the files question to include src in end, solution.xxx to have mode line in header.</li>
<li>download image to local, turn md in org format, and delete md one.</li>
<li>add a allorg, to include all under src dir's question.org</li>
<li>支持无网本地测试，在源代码文件头部中加入mode line，在题目文件尾部中加入include 源代码</li>
<li>根据题号在相同的目录下抓取不同题目和几个指定语言，并下载至本地图片，再转化md为org格式</li>
<li>支持在根目录中得到src的所有org file的include</li>
<li>md to org的==问题</li>
<li>based on leetgo to creat a leetcode elisp pkg</li>
<li>test leetcode emacs pkg instead</li>
</ul>
</div>
</div>
<div id="outline-container-org755f6af" class="outline-4">
<h4 id="org755f6af"><span class="section-number-4">10.0.18.</span> <span class="todo DONE">DONE</span> learn how to reference in org</h4>
<div class="outline-text-4" id="text-10-0-18">
<p>
\cite, org-cite-insert unable to insert problem
<b>M-RET</b> to enter cite list.
</p>
</div>
</div>
<div id="outline-container-orge320cec" class="outline-4">
<h4 id="orge320cec"><span class="section-number-4">10.0.19.</span> <span class="todo DONE">DONE</span> upload large files into the github repo</h4>
<div class="outline-text-4" id="text-10-0-19">
<p>
use sed to filter, use what to split into small files.
</p>
</div>
</div>
<div id="outline-container-orga1e0343" class="outline-4">
<h4 id="orga1e0343"><span class="section-number-4">10.0.20.</span> <span class="todo DONE">DONE</span> try to package real-mono-theme to melpa</h4>
<div class="outline-text-4" id="text-10-0-20">
<p>
minic almost-mono-theme, creat recipe, make pr
wait for mainter check. I am familaring with github, feeling awesome!
</p>
</div>
<ol class="org-ol">
<li><a id="orga352a47"></a>reply from melpa maintiner<br />
<div class="outline-text-5" id="text-10-0-20-1">
<p>
Thanks for this. I'm encouraged that you looked at other monochrome themes and went with a comprehensive approach here.
</p>

<p>
Typically themes are not byte compiled but you still want to maintain conventions across these "stub" files -
</p>

<p>
⸺ real-mono-sea-theme.el with byte-compile using Emacs 30.1:
</p>

<p>
real-mono-sea-theme.el:1:1: Warning: file has no `lexical-binding' directive on its first line
</p>

<p>
⸺ real-mono-old-theme.el with byte-compile using Emacs 30.1:
</p>

<p>
real-mono-old-theme.el:1:1: Warning: file has no `lexical-binding' directive on its first line
</p>

<p>
⸺ real-mono-girl-theme.el with byte-compile using Emacs 30.1:
</p>

<p>
real-mono-girl-theme.el:1:1: Warning: file has no `lexical-binding' directive on its first line
</p>

<p>
⸺ real-mono-eink-theme.el with byte-compile using Emacs 30.1:
</p>

<p>
real-mono-eink-theme.el:1:1: Warning: file has no `lexical-binding' directive on its first line
</p>

<p>
⸺ real-mono-dark-theme.el with byte-compile using Emacs 30.1:
</p>

<p>
real-mono-dark-theme.el:1:1: Warning: file has no `lexical-binding' directive on its first line
</p>

<p>
⸺ real-mono-sea-theme.el with package-lint 20250828.1506 and package-lint-main-file = "real-mono-themes.el":
</p>

<p>
1 issue found:
1:0: error: There is no `provide' form.
</p>

<p>
⸺ real-mono-old-theme.el with package-lint 20250828.1506 and package-lint-main-file = "real-mono-themes.el":
</p>

<p>
1 issue found:
1:0: error: There is no `provide' form.
</p>

<p>
⸺ real-mono-girl-theme.el with package-lint 20250828.1506 and package-lint-main-file = "real-mono-themes.el":
</p>

<p>
1 issue found:
1:0: error: There is no `provide' form.
</p>

<p>
⸺ real-mono-eink-theme.el with package-lint 20250828.1506 and package-lint-main-file = "real-mono-themes.el":
</p>

<p>
1 issue found:
1:0: error: There is no `provide' form.
</p>

<p>
⸺ real-mono-dark-theme.el with package-lint 20250828.1506 and package-lint-main-file = "real-mono-themes.el":
</p>

<p>
1 issue found:
1:0: error: There is no `provide' form.
</p>

<p>
⸺ real-mono-themes.el with melpazoid:
</p>

<ul class="org-ul">
<li>real-mono-themes.el#L469: It's safer to sharp-quote function names; use `#'`</li>
</ul>

<p>
⸺ real-mono-sea-theme.el with checkdoc 0.6.2 (fix within reason):
</p>

<p>
real-mono-sea-theme.el:0: The first line should be of the form: ";;; package &#x2014; Summary"
real-mono-sea-theme.el:0: You should have a section marked ";;; Commentary:"
real-mono-sea-theme.el:2: You should have a section marked ";;; Code:"
real-mono-sea-theme.el:2: The footer should be: (provide 'real-mono-sea-theme)\n;;; real-mono-sea-theme.el ends here
</p>

<p>
⸺ real-mono-old-theme.el with checkdoc 0.6.2 (fix within reason):
</p>

<p>
real-mono-old-theme.el:0: The first line should be of the form: ";;; package &#x2014; Summary"
real-mono-old-theme.el:0: You should have a section marked ";;; Commentary:"
real-mono-old-theme.el:2: You should have a section marked ";;; Code:"
real-mono-old-theme.el:2: The footer should be: (provide 'real-mono-old-theme)\n;;; real-mono-old-theme.el ends here
</p>

<p>
⸺ real-mono-girl-theme.el with checkdoc 0.6.2 (fix within reason):
</p>

<p>
real-mono-girl-theme.el:0: The first line should be of the form: ";;; package &#x2014; Summary"
real-mono-girl-theme.el:0: You should have a section marked ";;; Commentary:"
real-mono-girl-theme.el:2: You should have a section marked ";;; Code:"
real-mono-girl-theme.el:2: The footer should be: (provide 'real-mono-girl-theme)\n;;; real-mono-girl-theme.el ends here
</p>

<p>
⸺ real-mono-eink-theme.el with checkdoc 0.6.2 (fix within reason):
</p>

<p>
real-mono-eink-theme.el:0: The first line should be of the form: ";;; package &#x2014; Summary"
real-mono-eink-theme.el:0: You should have a section marked ";;; Commentary:"
real-mono-eink-theme.el:2: You should have a section marked ";;; Code:"
real-mono-eink-theme.el:2: The footer should be: (provide 'real-mono-eink-theme)\n;;; real-mono-eink-theme.el ends here
</p>

<p>
⸺ real-mono-dark-theme.el with checkdoc 0.6.2 (fix within reason):
</p>

<p>
real-mono-dark-theme.el:0: The first line should be of the form: ";;; package &#x2014; Summary"
real-mono-dark-theme.el:0: You should have a section marked ";;; Commentary:"
real-mono-dark-theme.el:2: You should have a section marked ";;; Code:"
real-mono-dark-theme.el:2: The footer should be: (provide 'real-mono-dark-theme)\n;;; real-mono-dark-theme.el ends here
</p>

<p>
⸺ Package and license:
</p>

<p>
Please specify :fetcher before :repo in your recipe
real-mono-dark-theme.el needs formal license boilerplate and/or an SPDX-License-Identifier
real-mono-eink-theme.el needs formal license boilerplate and/or an SPDX-License-Identifier
real-mono-girl-theme.el needs formal license boilerplate and/or an SPDX-License-Identifier
real-mono-old-theme.el needs formal license boilerplate and/or an SPDX-License-Identifier
real-mono-sea-theme.el needs formal lic
</p>

<p>
ense boilerplate and/or an SPDX-License-Identifier
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-org8166aa9" class="outline-4">
<h4 id="org8166aa9"><span class="section-number-4">10.0.21.</span> <span class="todo DONE">DONE</span> creat new account's github repos for github.io</h4>
<div class="outline-text-4" id="text-10-0-21">
<p>
have a usrname.github.io public repo, have index.html in it, in <a href="https://qingsongliao.github.io">url</a>
</p>
</div>
</div>
<div id="outline-container-org7df6d9c" class="outline-4">
<h4 id="org7df6d9c"><span class="section-number-4">10.0.22.</span> <span class="todo DONE">DONE</span> upload Purezen to github</h4>
<div class="outline-text-4" id="text-10-0-22">
<ul class="org-ul">
<li>description: theme that really monochrome
A collection of real monochrome emacs themes in a couple of variants.</li>
<li>clone a monochrome and study it
<a href="https://github.com/cryon/almost-mono-themes">https://github.com/cryon/almost-mono-themes</a></li>
<li>minic a theme to creat a repo
<a href="https://github.com/qingsongliao/real-mono-themes">https://github.com/qingsongliao/real-mono-themes</a></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7292a33" class="outline-2">
<h2 id="org7292a33"><span class="section-number-2">11.</span> 嵌入式软件招聘常见要求</h2>
<div class="outline-text-2" id="text-11">
<ul class="org-ul">
<li>本科及以上学历，嵌入式软件工作经验，电子、通信或计算机相关专业；</li>
<li>有ARM Linux软件的开发经验，熟练使用C++和C语言；</li>
<li>熟悉Linux常用设备操作，有spi、can、WiFi、audio、video相关驱动开发经验优先；</li>
<li>熟悉多线程、多进程和socket网络编程，有并发程序开发经验和良好的设计思路；</li>
<li>有机器人相关嵌入式设计或者实时系统经验优先。</li>

<li>负责yocto &amp; android 的构建（Build）与升级（OS Upgrade），确保系统的稳定性和兼容性。</li>
<li>参与新硬件平台的 Bringup，包括 CPU、GPU、Memory 等核心组件的初始化和调试。</li>
<li>分析和解决系统稳定性问题，优化系统架构设计，提升整体性能和可靠性。</li>
<li>研究客户系统功能需求，定制和优化系统功能，满足客户特定场景的需求。</li>
<li>解决系统性能问题，包括 CPU、GPU、Memory 等资源的优化与调度。</li>
<li>主导基线升级（Baseline Upgrade），确保系统与最新技术和安全标准同步。</li>

<li>具备操作系统（如 Android、Linux）的构建与升级经验，熟悉系统启动流程和内核开发。</li>
<li>有硬件平台 Bringup 经验，熟悉 CPU、GPU、Memory 等核心组件的初始化和调试。</li>
<li>具备系统架构设计能力，能够优化系统性能并解决稳定性问题。</li>
<li>有基线升级经验，熟悉版本管理和代码合并流程。</li>
<li>具备客户需求分析和功能定制能力，能够根据客户需求优化系统功能。</li>
<li>熟悉性能优化工具（如 perf, ftrace, gprof 等），能够解决 CPU、GPU、Memory 相关的性能问题。</li>
<li>有嵌入式系统开发经验，熟悉低功耗设计和优化。</li>
<li>熟悉虚拟化技术（如 KVM, QEMU）和容器化技术（如 Docker, Kubernetes）。</li>
<li>有MTK芯片平台开发经验</li>
</ul>
</div>
</div>
<div id="outline-container-orge11e523" class="outline-2">
<h2 id="orge11e523"><span class="section-number-2">12.</span> 嵌入式招聘常见笔试问题</h2>
</div>
<div id="outline-container-org41f649e" class="outline-2">
<h2 id="org41f649e"><span class="section-number-2">13.</span> 嵌入式招聘常见面试问题</h2>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">第一个嘈杂的提示，如果你进入了HTML版本，<a href="https://nestorliao.github.io/index.pdf">请点此处进入PDF版本。</a></p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">本书的牛“图片”均出自于GNU.org的自由艺术。GNU 计划，又称革奴计划，是由Richard Stallman在1983年9月27日公开发起的，目标是创建一套完全自由的操作系统，将牛作为 gnu和emacs 的象征是因为gnu在英文中本身就有“牛羚, 角马”的意思，有趣的是gnu本意为Gnu is Not Unix… 再问里面的 gnu 什么意思? 还是Gnu's Not Unix&#x2013;a recursive acronym，就像是中国的俗语“山上有座庙”，无穷尽也。</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">我父亲那边的车行亲戚</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">当然还有大佬们的谥美之词: python的蛇叔说用emacs就像是开了几十年的私家车/rust的离职语言之父一天60%时间在emacs中/ruby作者道“emacs改变了我的人生”/大概所有函数式语言的作者都得用emacs… java的高司今自己写了一个新emacs并相当不爽richard stallman，linus自己维护了mircoemacs… 还别说那些库程序员了，curl/ffmpeg等作者…，ffmpeg的天才程序员也开发了qemu/先进的pi算法/用llm作压缩工具，没错他也维护了个emacs。更别说richard stallman了，他开始了gcc/gdb，也开始了emacs了gnu，开源世界自君开。总之，emacs是个好玩的计算机历史产物，似乎仍没有过时。</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">把什么现代诗选和中国皇帝传都丢了吧，再看下去这辈子就毁了! 只留下两本书，互联网浅薄与雅思7天词汇，一是提醒我互联网对大脑的“伤害”另一个是提升下我的大脑，最近几年或十年特别是高考后，感觉自己的脑子雾雾的。</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">我有点网瘾，所以通过家里的路由器限制一下。速度200kps，限制热门社交媒体的域名，时间上只有下午二点到五点能用。每次无限制上网都有一种沉迷的感觉，看黄片刷新闻作为瘾症生意在互联网真是完美载体，总之，戒断的痛苦真是难受啊!!!</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7" role="doc-backlink">7</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">晚上又用母亲的手机上网了，怎么试都发现这个github.io是404, 下载下来好像是html本身的问题。切换了一下账号发现看不了那个号了，问了下chatgpt发现github有新号防bot功能，没法只能重新用回我的NestorLiao账号<a href="https://github.com/orgs/community/discussions/55609?utm_source=chatgpt.com">https://github.com/orgs/community/discussions/55609?utm_source=chatgpt.com</a>。</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Qingsong Liao</p>
<p class="date">Created: 2025-11-29 Sat 20:42</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
