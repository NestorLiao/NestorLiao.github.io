* My LLVM Databas Tl;DR
- Prevent Brain Rot ::
  + Internet is full of trash
  + Informative Comment often very long
  + Comments are more easy and interactive to consum than blog or manual.
  + Huaman are just llvm
- Conclusion :: Quick search needs to *Skim* reading and copy it.

- *Good Resources Rank*
  *Manual* :: instruments
  *Books* :: slow or quick cure pain pill
  *Source* Code :: the only one true babel
  *ChatGPT* :: The new information channel of our time
  *Blog* :: fragment of  Books or gold
  *Forum Comments* :: addictive drug, but may helpful
  *Video* :: shit, if it is college course, it Just Knowledge Illusion
  *Discord/QQ* :: a fucking  massive shit
  *Chinese* Version :: degrade

- The *Ture Tools* of human
  + Hands - Control Emacs
  + Eyes - Read Plain Text
  + Brain - Process Information

- To Keep my Tools working *Quickly and Accurately*.
  + Break :: 番茄工作法， GTD，极简主义
  + Sleep :: 规律睡眠，褪黑素， 墨水屏，运动量，安静
  + 运动 :: 跑步，走路，冥想，独轮车，壶铃，Fitcross
    - while you can listen to podcast
  + 饮食 :: 多素，白肉，少糖，少油，健康食品
    - longevity is easy
  + 权力过程 :: 性，意义，社交，财富，知识，音乐，编程，工作，集体
    - 编程 :: Emacs，Rust/Python/Zig/C，Linux
    - 性 :: just turn off the fucking porn.
    - 意义 :: to the mars


* Books
** 暗时间－刘未鹏

* EmacsChina
** Org-mode
    - 语法层面：我认为org-mode要优于Markdown
        - md方言太多，org-mode比较统一
        - org-mode大纲下自定义属性有很强的扩展性，现在魔改的md也不过是在文档级别加Frontmatter。因此org-mode天然比md粒度更细，这就能做很多有意思的事情。
    - 生态层面：org-mode的生态使其可以适应我的需求，而非让我适应工具
        - org的生态
            - 原生功能丰富而灵活，还可以根据个人需求扩展插件或者简单hack。仅列举部分我认为几个其他软件无法替代的场景
                - 编程：因为org-babel，我认为所有想学习编程的朋友都应该尝试org-mode
                - 科研：文献管理、latex、pdf导出，一套下来非常顺滑
                - 视频笔记：自卖自夸一下org-media-note 9，这是我目前所知对视频或音频做笔记最方便的工具。感谢org-mode提供了强大而灵活的链接机制。
                - 灵活的笔记方式：其他软件大多需要按着规定好的组织方式来，org-mode就很灵活。记笔记的方式也可以适应个人习惯。capture模版就不说了，说一个个人实例，记笔记时，我的注意力很容易发散到这条笔记相关的其他点上。因此我设置在在新建笔记时要求设置effort，计时完成会音乐提示，这时我就可以review一下，我是不是还在进行这个工作，接下来是应该继续这个笔记还是有其他更重要的事情做。
        - emacs的生态：极致的编辑功能和极强的整体协作能力
    - 宏观层面：我在年度征文 | 构建可持续发展的个人工作流：认识篇 - 少数派 17中有谈过我比较关注的几点
        - 编辑体验和对笔记的理解是专业的
        - 自由软件不用担心发展方向​与个人的需求不一致，个人也认同键盘中心、文本中心、Hackability的​价值观。键盘中心带来的书写快感是其他笔记软件很难具备
        - 优秀而开放的社区
** Emacs 与汽车电子嵌入式
[[https://emacs-china.org/t/emacs-stm32/20864][embedded emacs]]
[[https://emacs-china.org/t/c/19859][学C++越学越有味是怎么回事]]
我各种编辑器都用，vim、Source Insight、sublime text、Notepad++、emacs、VS Code等等。说起来，我不算是高手，但是我不觉得我掌握的技巧很弱。当然，我说的主要是考虑我作为开发者的身份来说。毕竟，开发者（或许单指我说的汽车电子嵌入式控制这个领域吧）工作过程中，写代码的时间相对来说少，看代码以及文档花费的时间很多。按照平时的工作效率，我基本也算是一个10X程序员了，我在公司多个项目中悬赏想找到一个人能够达到我1/6的开发速度，给他们2次挑战机会没人挑战成功。说这个结果，不是说我水平厉害，最起码作为开发者我不算是很差。与我大多数的同行相比，我的编辑器使用高效上也有优势。 如果，跟我一样面对的是资源有限，各种编程范式、编程模式都不好去灵活运用的时候。编辑器的语义分析，可读性增强的功能差了的确是有劣势。 再说，很多人提到的其他编辑器的缺点。比如说，VS Code是不是卡等等。如果再次限定在我这个行业，比较大的工程也不过百万行代码。没有任何编辑器会卡！这样看，其实，很多时候从零开始的话，emacs肯定会被整个细分的行业工程师扔掉。而我个人，是我这个行业中我接触到的人中不多的用emacs的。
说回我自己，为什么用呢？其实，我觉得能够吸引我的几个地方：1， org-mode； 2，dired-mode，我的的确确感觉这个很大程度上算是OS级别的功能，我觉得我对OS的文件管理期待也就到此了； 3，多功能混合，人键合一。
我觉得emacs好用，但是我真是一点把握都没有去说服我的同行工程师去学习。
所谓IDE和编辑器的对立，或者VIM对Emacs对IDE的“战争”只是段子而已。 彻底领会Emacs的本质后，其他所有IDE和编辑器都自然精通了。
我最开始是用IDE，确实好用。然后接触Emacs，用了一段时间觉得比较复杂，转去折腾Vim，折腾了一套好用的vim配置后，觉得没什么意思了，后来又回来折腾Emacs+evil。现在干脆完全不用evil，直接用Emacs的风格。用Emacs让我感觉最爽的是，你会觉得整个软件的就是你自己开发的（其实只是组合别人的各种包），符合自己的品味。总的来说就是一句话：享受自由的感觉真好！

与其说再次流行，个人觉得明确目标人群、培养使用生态更有效。
我从来没有成功安利过emacs，当然我也没有很积极地推广，但本质上来讲，不用一个工具是因为没有到非它不可的地步。
Emacs有很多天然的短板，比如作为一个知识管理方案，它的收集、跨平台的短板太明显；作为事务管理方案，缺少提醒、同步协作；作为IDE，debug、自动补全等都不是自带功能。当然，很多短板都可以通过扩展解决，但是这也是一个推广的门槛。
你很难让emacs在设计师人群流行，在看重资料收集、捕捉的人群中流行，在经常出差的人群中流行，在畏惧英语的人群中流行。对这些人而言，有不少其他的更易用的替代方案。对我个人而言，我是在知识管理从收集转向应用之后，发现org-mode是 唯一一个 满足把书籍、论文、代码、笔记、待办事项合为一体，管理我生活方方面面的方案。在清楚自己的需求之后，也能帮助你在众多方案中做出合理的选择。
也因为它是唯一的方案，你会发现虽然圈子小，但是圈子关注的问题跟自己高度集中。比如拿知识管理来说，当初看到roam之后，我就觉得在emacs中也不难实现，粗略搜索发现果然有人开发了相关package。用emacs的给我感觉是，有很多用户会用org-mode进行知识管理，整个生态也会不断地借鉴新的知识管理方法和工具。有人用org-mode做了十几年的笔记，这点让其他笔记难望项背。这也让我有很强的安全感：我可以一直生活在这个生态系统，根据我的需求调整，而不用花费精力迁移笔记和项目。
所以我觉得关于emacs的讨论如果不只是围绕技术，而是关于怎么应用在生活工作场景可能会吸引到更多人。客观来讲，关注怎么读书、推进项目、管理文献、整理笔记的人比关注技术的人要多得多。如果有更多人了解到这些事情不只可以由Things、Evernote这样的软件实现，emacs在深度使用上会有更好地表现。那么配合一些start-up的配置包，总有人会愿意额外地学习emacs来构建更适合自己的系统，因为emacs在某些情境确实是最优、甚至是唯一的解决方案。对于社区而言，这少部分用户也是优质的用户。
所以，论坛现在的分区要不要再开一个 学习效率 的分区？更侧重讨论在emacs中如何配合使用org-mode、drill、anki等package，提升个人工作、学习的效率？
PS 在我回复的时候，三次看到这个帖子处于XXX回复中的状态，感觉挺温馨的 :smiley:

我才开始学Emacs时把自带的calculator好好把玩了一下。现在，由于疫情，我用不了组里的一台装有很多商业软件的台式机。我就用Emacs里面的calc做了我的科研中许多涉及到统计的工作。
对于学术界的人而言，Emacs的吸引力在于很多趁手的小功能。但说实话，如果不是因为我现在要做一些简单的统计的工作，我也不会知道，Emacs的calc其实是个计算机代数系统。
我之前看到这篇博文中 使用Calc做微积分 - 暗无天日 53 将Emacs的calc戏称为“穷人的matlab”。我想，理工科的本科生实验课程中的数据处理，基本上都可以用Emacs的calc完成，似乎可以凭这一点向本科生推荐Emacs。回过头来，我才发现，本科时为了实验的数据处理，而花费时间去找破解版的matlab、学习matlab，有点可笑。我当时不知道Emacs里面除了calculator外，还有个calc。
其实我当时想学习使用Emacs，有个原因是我想从事的研究方向的一位大牛，卡耐基梅隆大学的John Kitchin，是Emacs的一位重度使用者。我后来听过他们组的报告，其中有几个学生的presentation，似乎是Emacs做出来的。

在reddit上看到了一篇很不错的elisp编程介绍: Emergency Elisp 43，通过和java对比介绍，很详细。介绍elisp基本语法，不涉及emacs api。通读一遍后，扫除了我知识上的一些盲区。

为什么啰嗦这么一大通呢？
就是因为，一直以来泛滥于程序员社群的“语言之争”，背后真正的原因其实并不在于语言实质上的优劣，而在于观察者的眼睛。
在观察者的眼睛里面，语言并非一门工具，而是自己花了N多时间（其中尤数C++为最）来“修炼”的技能，对于这样的技能，被否定无疑等同于自己被否定。
所以，从心理学上讲，语言并不是工具（尽管一直有这么一种呼吁），而是信仰。
这样的信仰在越是花得时间久的语言上越是激烈。
有趣的是，几乎所有的“热闹”的社群都有这样的现象，Java、Python、Ruby…莫不如是；
因为就算语言本身不复杂，程序员仍然还是要投入大量的精力去学习各种各样的框架类库
（想想Java的那些框架？）。因此这些语言社区的信仰未必不比C++社群的强烈。

在业界有两种C++程序员角色：一种是应用程序员，另一种是库程序员。这两者的界限不是绝对的，同一个人可以戴上应用程序员的帽子，写应用逻辑代码，也可以换上库程序员的帽子，开发程序库给前一类程序员用。
作为应用程序员不需要各种高级技巧，代码越朴实易懂越好。一个公司里的大部分C++程序员都是作为应用程序员在工作。
作为库程序员，则需要对C++语言有更深入全面的了解，这样才能写出既容易使用，又不容易误用，还拥有极高效能的程序库。
C++语言的很多高级特性，是为库程序员服务的，应用程序员并不需要掌握，也不提倡使用。这是因为我们不希望把一个大型程序本身固有的复杂度散布在代码的各个角落里。我们希望把大部分的复杂度集中在少量关键的程序库组件里，由具有高度技巧的库程序员，经过千锤百炼，打造出高效，健壮，可复用的组件。从而可以在大部分的代码里消除掉这些复杂度。
 (鄙人在Snapchat的C++语言平台团队负责编写和维护公用库，撰写代码规范和最佳实践指导)

 C++比Python开发效率低这个是事实吧。业界用C++的地方大抵不是因为C++是一门很优美的语言，而是因为没有什么更好的选择。譬如游戏引擎，以及性质类似的Snapchat的增强现实滤镜，达成可接受的性能要求需要对硬件的精细控制，能做到这一点的语言并不太多。在这类应用里，光是算法Big O复杂度对了是远远不够的，同样是O(N)的算法，高度优化的C++和没优化的C++性能可以相差十倍百倍。你需要考虑数据在内存里的布局，CPU缓存效率，函数调用开销，动态分派开销，多线程锁定开销，原子操作开销，以及指令级并行（SIMD）等等等等。C++允许你微调所有这些东西来把性能推到硬件能允许的上限，同时提供了比较强的抽象能力（当然比不上LISP，但是比Java要强得多）。

 我建议你不要进行这种自虐行为。C++基本上是C的超集，并没有人禁止你在C++里写C，如果你不喜欢写class，完全可以不写，但是仍然可以利用C++的其他特性，例如更好的类型系统。

用C实现容器和泛型算法在性能上是不可能和C++竞争的。最明显的例子就是C++的std::sort吊打qsort。这是语言的本质决定的。如果要做容器，也是一样被吊打。这是因为C缺乏用模版表达类型的能力，所以动态的数据结构不得不依赖类型擦除的指针，但是大家知道一旦你malloc一回，性能就直降两个数量级，通过指针间接访问数据，性能又降一个数量级。

我现在越来越觉得这些关于 C++ 开发效率低的说法很扯淡，比如说 Python 开发效率高，无非就是因为库比较全工具链比较方便。这些玩意都是人写的，它有，只是说明别人给你写好了，而已。你需要的话自己写个就好⋯⋯反正这些基础设施只需要写一次。

当然 C++ build 和 deploy 麻烦点，但是也没有差到需要用 Python⋯⋯
** Emacs 与 信仰
“曾经的我对技术一窍不通，但现在我已经掌握编程能力、开始努力争取自己的计算自主权。虽然还有很长的路要走，但我至少已经迈开了步伐。”
近日，自由软件基金会（FSF）宣布了 2021 年自由软件奖得主。该系列奖项在 LibrePlanet 2022 会议上颁发，得奖者主要是为软件自由事业做出重大贡献的个人、团队以及社区。鼓舞人心的是，非技术出身的 Protesilaos Stavrou（简称“Prot”）今年获得了“杰出新自由软件贡献者”奖项（Award for Outstanding New Free Software Contributor），该奖颁发给对自由软件社区作出杰出贡献的社区新成员。
FSF 在给 Prot 的颁奖词中写道：自 2019 年以来，这位哲学家通过他的博客文章、会议演讲、直播视频和代码贡献成为 GNU Emacs 社区的中流砥柱。
是的你没看错，今天的主角 Prot 是热衷于研究哲学的文科生，出生于1998年，非技术背景，大学学的是人文学科，近几年才开始接触技术。因此，他对于自己获奖一事感到非常意外。
FSF 执行董事 Zo Kooyman 表示：“Protesilaos 对于那些社区中刚起步的人来说是一个非常鼓舞人心的榜样。这表明，一个人不需要有几十年的经验也可以为自由软件做出贡献，甚至成为特定项目的核心。”
不少网友也表达了对 Prot 的祝贺和敬意：
Prot 是我遇到过的最能言善辩、谦逊、谨慎和健康的人之一。想到他在没有任何技术背景的情况下接触 Emacs 和 Lisp 并刚刚开始贡献，这简直是疯了。为你干杯，Prot！——gitrog
他在几乎没有背景的情况下拿起它（Emacs 和 Lisp）的速度是惊人的。2016 年学习 Linux/UNIX，2019 年才开始使用 Emacs。另一个有趣的事实：他做那些教程视频的主要目的是练习他的英语。——BeetleB
GNU EMACS 是一个可扩展、可定制、免费、自由的文本编辑器。同时，它也是一个集成开发环境。根据 Prot 的自述，过去两年半里，他编写了几千行 Elisp 并为核心 Emacs 做出贡献，包括两个完整、辅助功能齐备的可定制主题——modus-themes。
“当我来到 Emacs 时，当我切换到 Emacs 时，当我两年半前加入这个环境时，我发现了我需要的一切。有高质量的文档，面向 GNU Emacs 的优秀程序，大量的博客和教程等等，当然还有与不同的人的互动，你总能从中学到新的东西。”Prot 在获奖感言中强调，“虽然这个奖项是授予个人的，但我认为这实际上是关于社区的——社区中所有的无名英雄，帮助着一个特定的人实现某些目标。”
“如果没有我们生活中的无名英雄，没有人会取得任何有意义的成就。”Prot 说。
以下内容节选自在 Prot 在 LibrePlanet 2022 会议上的演讲，他分享了自己为什么选择 Emacs 以及对于自由软件的体会和理解，希望能为读者带来启发。
成为 Emacs 的铁粉
这里我想聊聊自己为什么会成为 Emacs 的铁粉。种种高级功能和丰富的软件包当然很好，但这还不足以体现 Emacs 的精髓、特别是它真正的价值主张。毕竟目前大多数现代编辑器都具备插件系统，可以为用户提供几乎一切必要的临时功能，那 Emacs 的特别之处究竟在哪？
答案在于，Emacs 并不是真正的文本编辑器。它其实是一套可编程平台，文本编辑只是其中的主要交互点之一。
Emacs 是由 Lisp 的一种方言编写而成，名为“Emacs Lisp”、也叫“Elisp”。因此，它的绝大多数代码库以及用户配置也是用 Elisp 写成。这意味着对最终用户来说，Emacs 只涉及一种语言、只包含一种范式。于是乎，内置代码和用户开发的插件代码间没有任何区别，真正实现了语言风格上的大一统。
Emacs 的核心就是读取和运行 Elisp 的能力，这被称为评估「evaluation」。在评估 Elisp 时，Emacs 环境可以轻松使用与之对应的返回值。无需重新启动程序，这些扩展就能实时生效，帮助用户以交互方式即刻观察效果。
从这个角度来看，Emacs 相当于是 Lisp 机，可以用来执行任何类型的程序。这里的“程序”可以指代一切，包括 Org 或者 Magit 这样的大功能、也包括精简文本编辑和操作等小应用。
此外，Emacs 还是自文档化的，意味着它能理解变量的值何时发生变化、并在对应的帮助缓冲区中通知用户。同理，Emacs 也能反映出各类函数的新值与当前状况的关联。
最后，Emacs 是纯免费软件，直接提供内置工具及所有已安装包的完整源代码。如此一来，文档中的显示内容就和实际程序的执行内容融合了起来，毫无隔阂滞碍。
我把 Emacs 当成集成计算环境
我是 2019 年夏天起开始用 Emacs 的，之前对 Lisp 没有任何了解，编程水平也不高。我上大学时学的是人文学科，所有硬核技术都是最近几年才逐渐掌握的。
Emacs 之所以吸引我，是因为 Lisp 机表现出了巨大的潜力。我想要的是一种不同于以往日常计算工具的集成开发层，我希望拥有统一的主题、精确的排版、相通的操作 / 交互模式。另外，我还希望能在不同上下文或界面之间建立联系：我的邮件客户端应该能跟任务调度器和文件管理器直接对话，我在编写文本时使用的配置也需要直接适用于编程界面等等。
Emacs 通过自身及第三方包 / 自定义代码全面满足了我的一切需求。如果大家愿意稍微学学 Elisp，那 Emacs 可以说是蕴藏着无穷无尽的可能。下面，咱们就一起来看几个无需多高技术水平就能实现的常见工作流程：
使用补全框架对文件内容进行异步搜索，将结果放在专用缓冲区内并就地编辑。最后，把变更传播至所有相关文件。
捕捉当前电子邮件内容并据此生成待办事项。任务还可包含一条返回原始消息的链接，并能够在议程当中显示相应的预定日期与截止日期。
在 Dired 中标记某些文件，再将它们添加到正在撰写的电子邮件当中。Dired 可以逐个标记条目，也可以使用正则表达式和其他高级命令。
记录一组以 Dired 为起点的操作（「键盘宏」），跳转至特定文件，执行某些变更、返回文件管理器，再在下一个文件中重复这个过程。
在以上各种用例中，用户完全不需要学习任何新知识。例如，键盘宏等各类功能在哪里都能直接用。更重要的是，这些功能既能单独起效、也可以协同工作。
因此，Emacs 得以将各种界面连通起来，而且完全不会因为上下文切换而引起任何冲突。
Emacs 的最后一项优势，就是易用性和规模化使用时的便捷性。例如，我想用自定义代码制作本次演讲中的演示内容。因为画面只占据文档的一小部分，所以很多朋友会以为这是一张预先构建的 PPT。并不是，我可以直接编辑里面的普通文本。所以我用的其实是 Emacs 当中的极简化“专注模式”，这种模式在演示、阅读、写作和编程等场景中都有很好的表现。
而且我在 Emacs 中的所有操作都只需要实现一次。我不需要在电子邮件客户端里设置一个定制专注模式、再为文本编辑器 / 处理器或者议程规划器设置更多其他专注模式。完全不需要，使用同一个模式即可。另外，我也不需要单独的工具进行文本编写和呈现，所有功能都是统一且互通的，又好又简单！
除此之外，底层配置也全部在 Elisp 中完成，这又进一步简化了整体效果。在使用 Emacs 之前，我往往得为每个应用程序使用不同的范式和 / 或语言。例如，Thurderbird 和 Libreoffice 各自的设置菜单就不同，而且彼此间无法互通。Mutt 有自己的配置方式、Vim 和 Tmux 也是，终端模拟器还是，逼着人反反复复做无用功。
我并不是说应用程序就不该有自己的配置方式。我只是建议它们应该组合使用，而目前毫无关联、彼此割裂的状态肯定不够好。用户只能竭尽全力用一个个功能孤岛拼凑出整体系统。而且即使付出巨大的努力，其中仍可能存在不足之处甚至安全缺陷，毕竟这些程序并非来自同一平台、使用的也不是同一种语言。
而在 Emacs 当中，每个新的功能包都会自动获取其他包内的已有内容，例如相同的字体配置和主题、通用的操作和交互模式等等。以此为基础，我们就能极大加快工作流的推进速度。Emacs 内部发生的一切都存在于同一环境当中，所有上下文均可相互关联，用户也能够随意建立这种关联。这种高度集成化和独特的统一性体验，也构成了 Emacs 价值主张的核心。
一致性与自主性
就使用许可而言，Emacs 属于自由软件。但它为最终用户带来的自由绝不限于法律或者道德层面，更体现在实用层面——也就是前文提到的集成计算环境。
Emacs 的可扩展性，使得用户能够利用自己的计算设备真正执行极为广泛的处理任务。与此同时，Elisp 的统一特性降低了准入门槛，彻底消除了以往全方位知识库需要在缺少共通基础的前提下拼凑应用程序的困境。
日常生活中的自由极可宝贵，而 Emacs 这款工具正是自由向往的代表，也帮助我们尽可能拉近了开发目标与计算机呈现结果之间的距离。
软件的自由，体现在计算手段的所有权当中。基于灵活的所有权，我们才能在计算空间中自主发展。这种自主性让我们能够随意为既定目标选择工具，摆脱由硬编码、甚至是固定实体服务带来的种种束缚。
在我看来，日常使用的各种应用程序间的集成性缺失绝对是个值得关注的大问题。我觉得自己在其中得不到应有的权利，也无法让工具充分按自己的意愿行事。于是最大的矛盾出现了：自由软件反而限制了我的自主性、让我变得不自由。这就造成了 1+1
换句话说，这些工具在“教我们做事”，而作为用户的我们完全影响不到这些“教条”的制定。
但在 Emacs 的帮助下，我终于在自己的日常计算中消除了这些异构性与异质性元素。现在，我的几乎一切创作都在 Emacs 上进行：读写、文件管理、任务规划组织、电子邮件往来、音乐收藏与播放、互联网浏览等等。唯一的例外，就是我确实还离不开图形网络浏览器。
再聊点抽象的。自由这个概念包含两个层面：名义自由与实质自由。前者体现在代码库遵循的许可上，后者则体现在代码库自身的内容——即整个使用感受，以及代码库如何与特定环境中的其他程序或工作流程相匹配。我觉得软件自由这个议题特别有意思，值得深入发掘。正确性、可组合性和可扩展性都是软件代码的基本属性，只有把这些属性有机结合起来、才能让程序在实践当中充分发挥能力。所以我们需要的是实质自由，而不只是许可条款层面的名义自由。
假定有这么一款程序，它既没有任何说明文档、代码的编写方式也极难理解。虽然它遵循自由许可，但种种现实却在提醒我们，它在用户体验层面跟自由自主没有任何关系。用户很难理解这款程序的内部运作逻辑、自然看不懂它为什么会给出最终结果。结合个人经验，我觉得这就是典型的名义自由——只存在于许可条款当中、在实际体验中完全不见踪影的“自由”，绝对不是真正的自由。
使用 Emacs 的经历还让我意识到，作为软件技术社区，我们的关注点必须始终投射在最终用户身上，我们就不该发布那些用户无权操作的代码。相反，我们应该放开手脚，允许用户自主管理计算方式。自由软件不只是要替代专有代码，它更重要的象征意义在于激励人们改变对于自主思想的态度。社区和用户间的关系不仅仅是予取予求，还应该引导用户习惯于争取自由、承担责任。
而这样做的终极目的，就是让人们从曾经长期束缚我们的版权制度中解放出来，将权利交换给用户。是的，代码本身并不是终极目标，所以开源社区一定得勇于从公式化的版权文件中走出来。“要么接受、要么放弃”的一刀切方法既不能赋予用户权利，也无法培养他们的自主性。一个优秀的项目，不仅应该易访问、可配置、配备完善的说明文档，同时也应该为自由事业的发展做出贡献。
而推进这项事业的第一步，就是打通软件壁垒、让一切程序都能协同工作。最终，用户将学会如何掌管自己的整台计算机，这样每个人才能真正成为自由软件新时代的一分子。
Emacs 社区和我的社区贡献历程
说了这么半天 Emacs，其实我们也有自己的社区。Emacs 社区欢迎新人的加入，希望借此传播知识、分享观点。Emacs 社区对开发质量一直有着极高要求，并把这当成关乎用户自由与否的大事。目前，正规 Emacs 软件包均提供详尽文档，允许用户通过多种选项配置出自己想要的使用体验。
Emacs 社区很清楚，我们不能对最终用户的主动性施加控制。因此，所有相关代码都具备良好的可扩展性与定制空间。社区始终抱持这样的观点——自由是一种主体间的体验展开，因此单从法律层面放开约束还远远不够。于是，Emacs 提倡一种强大的文档文化，每份 Elisp 表单都必须用自然语言解释其作用，每个功能包都必须提供使用与配置说明。我们希望用这样的方式保障最低限度的计算自由。
这就是 Emacs 的行事风格，而且一路延伸至核心应用。作为 Lisp 机，Emacs 在设计之初就充分为最终用户赋权，重新审视一切既有规则。例如，我的 Elisp 学习之路就是从编写小型函数封装开始，用于调整某些默认操作的执行方式。我想补充“move down a line”（下移一行）命令的功能，让它能支持下移特定多行。Emacs 则可以实时评估代码，而且开放完整的源代码及相关说明文档。正是有了这样的开放性，我才能了解如何定义函数，再通过反复试验编写出人生中第一条自定义 Elisp。
之后，我又继续调整 Emacs，希望实现有益于自己日常工作的微小优化。在此期间，我逐渐掌握了 Elisp，并运用这些新知识得心应手地操作 Emacs。过去两年半里，我编写了几千行 Elisp 并为核心 Emacs 做出贡献，包括两个完整、辅助功能齐备的可定制主题，这就是 modus-themes。
换个角度来看，我在成为 Emacs 用户的头三个月里，学到的编程知识要比自己之前三年参与自由软件社区中还多。对我来说，这就是社区引导最终用户成长、满足最终用户需求的最佳案例。曾经的我对技术一窍不通，但现在我已经掌握编程能力、开始努力争取自己的计算自主权。虽然还有很长的路要走，但我至少已经迈开了步伐。

** Emacs people

先评估工作所需技能，如果缺失就先弥补。待你有信心找工作时再玩emacs。但也有可能你已经准备了很充份，却依然没找到自己满意的工作哦。一个事情是不是正事，有时候要看你怎么看它了。对你来说emacs不是正事，因为你没有充份认识到它的价值。可对某些人来说它就是正事中的正事，因为对他来说非常具有价值。

厨师要有好的锅，炒菜才不粘锅，但不能一直打磨锅不炒菜，持续炒菜的作用是活下去，才有时间继续打磨工具，良性循环。
首先要热爱生活，知道有意义的事情和自己感兴趣的交叉点在哪里？只要能好好持续的活下去，不要着急，玩emacs就和其他人养宠物和下棋一样，都是良性爱好。
工具本身没有错，只打磨宝剑不用剑的原因往往是对自己认识还不够导致的，然后总是拿打磨工具当做逃避的手段。

你和我当初的情况一样，这确实是要makefile。
makefile是一个工程管理工具，指导程序应该如何一步一步被编译出来，而补全就是根据每一步的编译指令“gcc ……” 来推断每个文件里面可以看到哪些库（注意“能看到”与“实际include”的区别），因此便能够据此提供补全功能。
你如果和我当初一样是刚刚进入Linux世界的话，那我猜测你之前是用keil做单片机开发的。那么你就需要去网上找找你所开发的单片机的对应makefile工程，我记得GitHub上面就有，然后尝试着编写一个gpio的点灯程序试试能否编译烧录。
编译器应该是交叉编译器“gcc-none-arm-eabi”，好像是这个名，太久没有用记不清了，可能顺序不一样，但是none和arm是要有的，none指裸板（即无操作系统的平台），arm指芯片架构。
烧录我不太记得清了，记得是下载一个驱动（pacman和apt仓库好像都有，名字忘记了）然后再下载一个串口通信的软件，就能够烧录了。
 最后我觉得Linux做单片机开发对于初学者来说，心智负担实在是太大了，不如还是先使用keil，stm32cubeide（这个好像有Linux版，但是当时折腾了好久也没有烧录上）来做开发比较好。

 因为自己当时太傲慢，太蠢了，遇到问题如果谷歌不到就放弃了，完全不懂得上咱们论坛问问，或者去stackoverflow之类的地方用英文问别人应该怎么做，什么都自己摸索。。。然后自己摸索了许久，然后发现总是有问题，就放弃了。
仔细回忆一下，大概是一开始是根本不知道怎么搞，后面通过折腾知道了需要自己弄项目管理的工具还有交叉编译器，Keil 是用 .uproj（大概这名）文件来管理项目的，而Linux上面只能用makefile或者CMake，于是就自己学Makefile和CMake。。。后面发现需要调试串口的时候又卡住了，Linux下面的串口调试怎么也接不到STM32发出来的串口信息（当时我只用Linux），一直卡着调不出来，又不想重装回Windows，负反馈太大，就失去兴趣了。
后面上了大三了专业课压力又大，又要准备考研了，于是就没有整过它了。现在考完研(没考上😢)，也快毕业了，搞毕业论文，又要二战，更加没时间弄这个了。
不过当时学的时候还是蛮快乐的，因为当时我是用『寄存器』的视角去学习的（好像当时STM32学习的三层视角：寄存器、官方库函数、HAL库函数），虽然痛苦而且没有什么项目成果，但是却让我理解起计算机底层更加深入了233

我也凑个热闹，说说自己的经历。
开始用 Emacs 很早了，二十多年前，还是大学时期，当时 Linux 在国内还是处于开始阶段，只见到过几种发型版，其中一个还是清华 Linux Club 在 RedHat 之上加的中文支持。后来发现了 Debian，一直用到了现在。
VI 不太会用，只好用 Emacs。如果没记错的话，当时用的 Emacs 版本是 19 还是 20。当时也想着用 Emacs 一统江湖来着，用 gnus / mail / elfeed / erc 等等什么的，后来都不玩了。主要还是写程序，C / Java，JDEE 用了一段也弃了，再加上 LaTeX 写东西，也就这样了。一直也对 Org 无感，比较麻烦。
后来工作也是，开着一个 Emacs， 大黑全屏，跟别人都不一样。后来一个同事也玩 Emacs，Org 之类的，带动了一些人。这是第一次见到有 Emacs 同好。
后来在咱们论坛上看到了 Space Emacs，试用下来还不错，hyrbid mode，space leader key 还是好用些，也比较习惯。同时也学习了 VI，至此 VI 技能才从会 dd/yy 升级一些。
发现 AsciiDoc，用来写东西很好。
对 Space Emacs 不满，各种原因吧，换回常规 Emacs 配置，照抄一大波。不过一直以来我的 Emacs 配置极少，聊聊十数个包，多是 customize 就能出来的东西。现在慢慢多了起来。
再来就是试用了 meow，能接受，就用了下来。
总的来说，自己的需求相当低，那就是写东西，程序也是写，其他东西也是写，只要这个目的能很好地达到，符合自己的习惯，Emacs 就很好。其他的基本不在 Emacs 里做。当然了，开发的时候，边上开个 IDE 来解决语法错误还是很有必要的，但随着 LSP 的进步，这一项在自己的小项目中已经可以不用了。即便是 Magit，也多是用来选择文件 stage，其他功能也很少用，都是 git 命令行解决。
纵观自己和 Emacs 的历史，就是君子之交，平淡如水，不火热（不总折腾），也不远离（天天在用），没去帮它进步（去开发改进或开发新包），也算是尽自己一分力（看到新奇的也玩一玩，偶尔也提个 PR 啥的），就是个稳定、安静的佛系使用者。

* Blogs
** TODO 973 days with emacs
** TODO Emacs with Pedals
