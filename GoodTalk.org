* Tl;DR: My LLVM Databas
- Favourite Media Consumption:
  + Movie: 天空之城－以及吉卜力其他作品
  + Music 流派: 数学摇滚
  + Music Band:Beatles, Toe, Pink Floyd
  + Anime: Sonny Boy, 孤独摇滚, K-ON, Air
  + Game: Elden Ring, Celeste, KSP, MC, 围攻
  + 虚构类Book: 树上春树, 余华, 刘慈欣, 老子
  + 纪实类Book: 人类简史, 百科全书

- Prevent Brain Rot ::
  + Internet is full of INFORMATION and TRASH
  + Computer and Internet both ADDICTIVE
  + Comments and Short Blog are Driving people SKIMMING READING.
  + HUAMAN are  LLVM
    Conclusion :: We Must Be Carefully SELECT our INPUT.

- *Good Resources Rank*
  *Manual* :: instruments
  *Books* :: slow or quick cure pain pill
  *Source* Code :: the only one true babel
  *ChatGPT* :: The new information channel of our time
  *Blog* :: fragment of  Books or gold
  *Forum Comments* :: addictive drug, but may helpful
  *Video* :: shit, if it is college course, it Just Knowledge Illusion
  *Discord/QQ* :: a fucking  massive shit
  *Chinese* Version :: degrade

- The *Ture Tools* of human
  + Hands - Control Emacs
  + Eyes - Read Plain Text
  + Brain - Process Information

- To Keep my Tools working *Quickly and Accurately*.
  + Break :: 番茄工作法， GTD，极简主义
  + Sleep :: 规律睡眠，褪黑素， 墨水屏，运动量，安静
  + 运动 :: 跑步，走路，冥想，独轮车，壶铃，Fitcross
    - while you can listen to podcast
  + 饮食 :: 多素，白肉，少糖，少油，健康食品
    - longevity is easy
  + 权力过程 :: 性，意义，社交，财富，知识，音乐，编程，工作，集体
    - 编程 :: Emacs，Rust/Python/Zig/C，Linux
    - 性 :: just turn off the fucking porn.
    - 意义 :: to the mars


Project/Opensource
NixOS+Emacs> Beej to C/Network> C+CSAPP > Scheme+SICP> DDIA> JYYOS >Zig+CSAPP> Rust/Zig+Linux> Go Out and Work.

One step by step
Less is More
FAST: Forget, Active, State, Teach
Get Sleep, Don't anxious, No pressure.

Life-time tooling, Emacs+ Linux.
Low-level of computer, do csapp.
High-order of computer, do sicp.
Real-world of computer, do ddia.

我的聚光灯：冥想，散步，壶铃，墨水，阅读，写作，睡眠，赞美太阳，Emacs，Linux ※ Qtmd互联网
我的星光：学习进步，找到兴趣，学好技术，找到好工作，找到另一半，成为好父母，成为更好的自己
我的日光：硬件与计算机底层，编辑阅读理解能力，从零开始创造的能力
自己是谁？
装明白的人,不消费的人,不一样的人
喜欢小众、反思、心灵神游和深思
不喜大众、迷失、抓人眼球和分心

骇客会以非常特别的方式攻击网站：
让大量电脑同时登录该网站，以此压倒其管理流量的能力，
导致其他人无法造访，网站流量也就下降。
这种瘫痪网站的方法，称为「阻断服务攻击」。
我们的心智都在经历类阻断服务攻击。
「我们就是那个伺服器，所有东西都在向我们发送讯息，
以此来吸引我们的注意力……削弱了对任何事情做出反应的能力。
它让我们处于分心或瘫痪的状态。」我们应接不暇。
他说：「讯息填满了你的世界，
而你找不到一个能看到全貌的地方，也无法发现自己分心且设法解决。
它可以殖民你的整个世界。」
你筋疲力竭而「无力反抗」。

* Internet
** Jobs
1.负责开发、调试、维护Camera//audio/ota/Android fw 等问题；
2.负责SOC 的板级开发与调试；
3.负责客户现场开发支持；
任职要求：
1.EE/计算机/控制等相关专业，本科及以上学历，2年及以上工作经验；
2.熟悉linux内核工作原理，熟悉内核任务工作机制；
3.熟悉I2C/SPI等总线接口，熟悉linux device tree，熟悉linux驱动开发框架或者Android系统。
4.熟悉makefile，熟悉linux调试工具；
5.有Camera/Android fw开发经验优先；



** EmacsChina
*** Org-mode
    - 语法层面：我认为org-mode要优于Markdown
        - md方言太多，org-mode比较统一
        - org-mode大纲下自定义属性有很强的扩展性，现在魔改的md也不过是在文档级别加Frontmatter。因此org-mode天然比md粒度更细，这就能做很多有意思的事情。
    - 生态层面：org-mode的生态使其可以适应我的需求，而非让我适应工具
        - org的生态
            - 原生功能丰富而灵活，还可以根据个人需求扩展插件或者简单hack。仅列举部分我认为几个其他软件无法替代的场景
                - 编程：因为org-babel，我认为所有想学习编程的朋友都应该尝试org-mode
                - 科研：文献管理、latex、pdf导出，一套下来非常顺滑
                - 视频笔记：自卖自夸一下org-media-note 9，这是我目前所知对视频或音频做笔记最方便的工具。感谢org-mode提供了强大而灵活的链接机制。
                - 灵活的笔记方式：其他软件大多需要按着规定好的组织方式来，org-mode就很灵活。记笔记的方式也可以适应个人习惯。capture模版就不说了，说一个个人实例，记笔记时，我的注意力很容易发散到这条笔记相关的其他点上。因此我设置在在新建笔记时要求设置effort，计时完成会音乐提示，这时我就可以review一下，我是不是还在进行这个工作，接下来是应该继续这个笔记还是有其他更重要的事情做。
        - emacs的生态：极致的编辑功能和极强的整体协作能力
    - 宏观层面：我在年度征文 | 构建可持续发展的个人工作流：认识篇 - 少数派 17中有谈过我比较关注的几点
        - 编辑体验和对笔记的理解是专业的
        - 自由软件不用担心发展方向​与个人的需求不一致，个人也认同键盘中心、文本中心、Hackability的​价值观。键盘中心带来的书写快感是其他笔记软件很难具备
        - 优秀而开放的社区
*** Emacs 与汽车电子嵌入式
[[https://emacs-china.org/t/emacs-stm32/20864][embedded emacs]]
[[https://emacs-china.org/t/c/19859][学C++越学越有味是怎么回事]]
我各种编辑器都用，vim、Source Insight、sublime text、Notepad++、emacs、VS Code等等。说起来，我不算是高手，但是我不觉得我掌握的技巧很弱。当然，我说的主要是考虑我作为开发者的身份来说。毕竟，开发者（或许单指我说的汽车电子嵌入式控制这个领域吧）工作过程中，写代码的时间相对来说少，看代码以及文档花费的时间很多。按照平时的工作效率，我基本也算是一个10X程序员了，我在公司多个项目中悬赏想找到一个人能够达到我1/6的开发速度，给他们2次挑战机会没人挑战成功。说这个结果，不是说我水平厉害，最起码作为开发者我不算是很差。与我大多数的同行相比，我的编辑器使用高效上也有优势。 如果，跟我一样面对的是资源有限，各种编程范式、编程模式都不好去灵活运用的时候。编辑器的语义分析，可读性增强的功能差了的确是有劣势。 再说，很多人提到的其他编辑器的缺点。比如说，VS Code是不是卡等等。如果再次限定在我这个行业，比较大的工程也不过百万行代码。没有任何编辑器会卡！这样看，其实，很多时候从零开始的话，emacs肯定会被整个细分的行业工程师扔掉。而我个人，是我这个行业中我接触到的人中不多的用emacs的。
说回我自己，为什么用呢？其实，我觉得能够吸引我的几个地方：1， org-mode； 2，dired-mode，我的的确确感觉这个很大程度上算是OS级别的功能，我觉得我对OS的文件管理期待也就到此了； 3，多功能混合，人键合一。
我觉得emacs好用，但是我真是一点把握都没有去说服我的同行工程师去学习。
所谓IDE和编辑器的对立，或者VIM对Emacs对IDE的“战争”只是段子而已。 彻底领会Emacs的本质后，其他所有IDE和编辑器都自然精通了。
我最开始是用IDE，确实好用。然后接触Emacs，用了一段时间觉得比较复杂，转去折腾Vim，折腾了一套好用的vim配置后，觉得没什么意思了，后来又回来折腾Emacs+evil。现在干脆完全不用evil，直接用Emacs的风格。用Emacs让我感觉最爽的是，你会觉得整个软件的就是你自己开发的（其实只是组合别人的各种包），符合自己的品味。总的来说就是一句话：享受自由的感觉真好！

与其说再次流行，个人觉得明确目标人群、培养使用生态更有效。
我从来没有成功安利过emacs，当然我也没有很积极地推广，但本质上来讲，不用一个工具是因为没有到非它不可的地步。
Emacs有很多天然的短板，比如作为一个知识管理方案，它的收集、跨平台的短板太明显；作为事务管理方案，缺少提醒、同步协作；作为IDE，debug、自动补全等都不是自带功能。当然，很多短板都可以通过扩展解决，但是这也是一个推广的门槛。
你很难让emacs在设计师人群流行，在看重资料收集、捕捉的人群中流行，在经常出差的人群中流行，在畏惧英语的人群中流行。对这些人而言，有不少其他的更易用的替代方案。对我个人而言，我是在知识管理从收集转向应用之后，发现org-mode是 唯一一个 满足把书籍、论文、代码、笔记、待办事项合为一体，管理我生活方方面面的方案。在清楚自己的需求之后，也能帮助你在众多方案中做出合理的选择。
也因为它是唯一的方案，你会发现虽然圈子小，但是圈子关注的问题跟自己高度集中。比如拿知识管理来说，当初看到roam之后，我就觉得在emacs中也不难实现，粗略搜索发现果然有人开发了相关package。用emacs的给我感觉是，有很多用户会用org-mode进行知识管理，整个生态也会不断地借鉴新的知识管理方法和工具。有人用org-mode做了十几年的笔记，这点让其他笔记难望项背。这也让我有很强的安全感：我可以一直生活在这个生态系统，根据我的需求调整，而不用花费精力迁移笔记和项目。
所以我觉得关于emacs的讨论如果不只是围绕技术，而是关于怎么应用在生活工作场景可能会吸引到更多人。客观来讲，关注怎么读书、推进项目、管理文献、整理笔记的人比关注技术的人要多得多。如果有更多人了解到这些事情不只可以由Things、Evernote这样的软件实现，emacs在深度使用上会有更好地表现。那么配合一些start-up的配置包，总有人会愿意额外地学习emacs来构建更适合自己的系统，因为emacs在某些情境确实是最优、甚至是唯一的解决方案。对于社区而言，这少部分用户也是优质的用户。
所以，论坛现在的分区要不要再开一个 学习效率 的分区？更侧重讨论在emacs中如何配合使用org-mode、drill、anki等package，提升个人工作、学习的效率？
PS 在我回复的时候，三次看到这个帖子处于XXX回复中的状态，感觉挺温馨的 :smiley:

我才开始学Emacs时把自带的calculator好好把玩了一下。现在，由于疫情，我用不了组里的一台装有很多商业软件的台式机。我就用Emacs里面的calc做了我的科研中许多涉及到统计的工作。
对于学术界的人而言，Emacs的吸引力在于很多趁手的小功能。但说实话，如果不是因为我现在要做一些简单的统计的工作，我也不会知道，Emacs的calc其实是个计算机代数系统。
我之前看到这篇博文中 使用Calc做微积分 - 暗无天日 53 将Emacs的calc戏称为“穷人的matlab”。我想，理工科的本科生实验课程中的数据处理，基本上都可以用Emacs的calc完成，似乎可以凭这一点向本科生推荐Emacs。回过头来，我才发现，本科时为了实验的数据处理，而花费时间去找破解版的matlab、学习matlab，有点可笑。我当时不知道Emacs里面除了calculator外，还有个calc。
其实我当时想学习使用Emacs，有个原因是我想从事的研究方向的一位大牛，卡耐基梅隆大学的John Kitchin，是Emacs的一位重度使用者。我后来听过他们组的报告，其中有几个学生的presentation，似乎是Emacs做出来的。

在reddit上看到了一篇很不错的elisp编程介绍: Emergency Elisp 43，通过和java对比介绍，很详细。介绍elisp基本语法，不涉及emacs api。通读一遍后，扫除了我知识上的一些盲区。

为什么啰嗦这么一大通呢？
就是因为，一直以来泛滥于程序员社群的“语言之争”，背后真正的原因其实并不在于语言实质上的优劣，而在于观察者的眼睛。
在观察者的眼睛里面，语言并非一门工具，而是自己花了N多时间（其中尤数C++为最）来“修炼”的技能，对于这样的技能，被否定无疑等同于自己被否定。
所以，从心理学上讲，语言并不是工具（尽管一直有这么一种呼吁），而是信仰。
这样的信仰在越是花得时间久的语言上越是激烈。
有趣的是，几乎所有的“热闹”的社群都有这样的现象，Java、Python、Ruby…莫不如是；
因为就算语言本身不复杂，程序员仍然还是要投入大量的精力去学习各种各样的框架类库
（想想Java的那些框架？）。因此这些语言社区的信仰未必不比C++社群的强烈。

在业界有两种C++程序员角色：一种是应用程序员，另一种是库程序员。这两者的界限不是绝对的，同一个人可以戴上应用程序员的帽子，写应用逻辑代码，也可以换上库程序员的帽子，开发程序库给前一类程序员用。
作为应用程序员不需要各种高级技巧，代码越朴实易懂越好。一个公司里的大部分C++程序员都是作为应用程序员在工作。
作为库程序员，则需要对C++语言有更深入全面的了解，这样才能写出既容易使用，又不容易误用，还拥有极高效能的程序库。
C++语言的很多高级特性，是为库程序员服务的，应用程序员并不需要掌握，也不提倡使用。这是因为我们不希望把一个大型程序本身固有的复杂度散布在代码的各个角落里。我们希望把大部分的复杂度集中在少量关键的程序库组件里，由具有高度技巧的库程序员，经过千锤百炼，打造出高效，健壮，可复用的组件。从而可以在大部分的代码里消除掉这些复杂度。
 (鄙人在Snapchat的C++语言平台团队负责编写和维护公用库，撰写代码规范和最佳实践指导)

 C++比Python开发效率低这个是事实吧。业界用C++的地方大抵不是因为C++是一门很优美的语言，而是因为没有什么更好的选择。譬如游戏引擎，以及性质类似的Snapchat的增强现实滤镜，达成可接受的性能要求需要对硬件的精细控制，能做到这一点的语言并不太多。在这类应用里，光是算法Big O复杂度对了是远远不够的，同样是O(N)的算法，高度优化的C++和没优化的C++性能可以相差十倍百倍。你需要考虑数据在内存里的布局，CPU缓存效率，函数调用开销，动态分派开销，多线程锁定开销，原子操作开销，以及指令级并行（SIMD）等等等等。C++允许你微调所有这些东西来把性能推到硬件能允许的上限，同时提供了比较强的抽象能力（当然比不上LISP，但是比Java要强得多）。

 我建议你不要进行这种自虐行为。C++基本上是C的超集，并没有人禁止你在C++里写C，如果你不喜欢写class，完全可以不写，但是仍然可以利用C++的其他特性，例如更好的类型系统。

用C实现容器和泛型算法在性能上是不可能和C++竞争的。最明显的例子就是C++的std::sort吊打qsort。这是语言的本质决定的。如果要做容器，也是一样被吊打。这是因为C缺乏用模版表达类型的能力，所以动态的数据结构不得不依赖类型擦除的指针，但是大家知道一旦你malloc一回，性能就直降两个数量级，通过指针间接访问数据，性能又降一个数量级。

我现在越来越觉得这些关于 C++ 开发效率低的说法很扯淡，比如说 Python 开发效率高，无非就是因为库比较全工具链比较方便。这些玩意都是人写的，它有，只是说明别人给你写好了，而已。你需要的话自己写个就好⋯⋯反正这些基础设施只需要写一次。

当然 C++ build 和 deploy 麻烦点，但是也没有差到需要用 Python⋯⋯
*** Emacs 与 信仰
“曾经的我对技术一窍不通，但现在我已经掌握编程能力、开始努力争取自己的计算自主权。虽然还有很长的路要走，但我至少已经迈开了步伐。”
近日，自由软件基金会（FSF）宣布了 2021 年自由软件奖得主。该系列奖项在 LibrePlanet 2022 会议上颁发，得奖者主要是为软件自由事业做出重大贡献的个人、团队以及社区。鼓舞人心的是，非技术出身的 Protesilaos Stavrou（简称“Prot”）今年获得了“杰出新自由软件贡献者”奖项（Award for Outstanding New Free Software Contributor），该奖颁发给对自由软件社区作出杰出贡献的社区新成员。
FSF 在给 Prot 的颁奖词中写道：自 2019 年以来，这位哲学家通过他的博客文章、会议演讲、直播视频和代码贡献成为 GNU Emacs 社区的中流砥柱。
是的你没看错，今天的主角 Prot 是热衷于研究哲学的文科生，出生于1998年，非技术背景，大学学的是人文学科，近几年才开始接触技术。因此，他对于自己获奖一事感到非常意外。
FSF 执行董事 Zo Kooyman 表示：“Protesilaos 对于那些社区中刚起步的人来说是一个非常鼓舞人心的榜样。这表明，一个人不需要有几十年的经验也可以为自由软件做出贡献，甚至成为特定项目的核心。”
不少网友也表达了对 Prot 的祝贺和敬意：
Prot 是我遇到过的最能言善辩、谦逊、谨慎和健康的人之一。想到他在没有任何技术背景的情况下接触 Emacs 和 Lisp 并刚刚开始贡献，这简直是疯了。为你干杯，Prot！——gitrog
他在几乎没有背景的情况下拿起它（Emacs 和 Lisp）的速度是惊人的。2016 年学习 Linux/UNIX，2019 年才开始使用 Emacs。另一个有趣的事实：他做那些教程视频的主要目的是练习他的英语。——BeetleB
GNU EMACS 是一个可扩展、可定制、免费、自由的文本编辑器。同时，它也是一个集成开发环境。根据 Prot 的自述，过去两年半里，他编写了几千行 Elisp 并为核心 Emacs 做出贡献，包括两个完整、辅助功能齐备的可定制主题——modus-themes。
“当我来到 Emacs 时，当我切换到 Emacs 时，当我两年半前加入这个环境时，我发现了我需要的一切。有高质量的文档，面向 GNU Emacs 的优秀程序，大量的博客和教程等等，当然还有与不同的人的互动，你总能从中学到新的东西。”Prot 在获奖感言中强调，“虽然这个奖项是授予个人的，但我认为这实际上是关于社区的——社区中所有的无名英雄，帮助着一个特定的人实现某些目标。”
“如果没有我们生活中的无名英雄，没有人会取得任何有意义的成就。”Prot 说。
以下内容节选自在 Prot 在 LibrePlanet 2022 会议上的演讲，他分享了自己为什么选择 Emacs 以及对于自由软件的体会和理解，希望能为读者带来启发。
成为 Emacs 的铁粉
这里我想聊聊自己为什么会成为 Emacs 的铁粉。种种高级功能和丰富的软件包当然很好，但这还不足以体现 Emacs 的精髓、特别是它真正的价值主张。毕竟目前大多数现代编辑器都具备插件系统，可以为用户提供几乎一切必要的临时功能，那 Emacs 的特别之处究竟在哪？
答案在于，Emacs 并不是真正的文本编辑器。它其实是一套可编程平台，文本编辑只是其中的主要交互点之一。
Emacs 是由 Lisp 的一种方言编写而成，名为“Emacs Lisp”、也叫“Elisp”。因此，它的绝大多数代码库以及用户配置也是用 Elisp 写成。这意味着对最终用户来说，Emacs 只涉及一种语言、只包含一种范式。于是乎，内置代码和用户开发的插件代码间没有任何区别，真正实现了语言风格上的大一统。
Emacs 的核心就是读取和运行 Elisp 的能力，这被称为评估「evaluation」。在评估 Elisp 时，Emacs 环境可以轻松使用与之对应的返回值。无需重新启动程序，这些扩展就能实时生效，帮助用户以交互方式即刻观察效果。
从这个角度来看，Emacs 相当于是 Lisp 机，可以用来执行任何类型的程序。这里的“程序”可以指代一切，包括 Org 或者 Magit 这样的大功能、也包括精简文本编辑和操作等小应用。
此外，Emacs 还是自文档化的，意味着它能理解变量的值何时发生变化、并在对应的帮助缓冲区中通知用户。同理，Emacs 也能反映出各类函数的新值与当前状况的关联。
最后，Emacs 是纯免费软件，直接提供内置工具及所有已安装包的完整源代码。如此一来，文档中的显示内容就和实际程序的执行内容融合了起来，毫无隔阂滞碍。
我把 Emacs 当成集成计算环境
我是 2019 年夏天起开始用 Emacs 的，之前对 Lisp 没有任何了解，编程水平也不高。我上大学时学的是人文学科，所有硬核技术都是最近几年才逐渐掌握的。
Emacs 之所以吸引我，是因为 Lisp 机表现出了巨大的潜力。我想要的是一种不同于以往日常计算工具的集成开发层，我希望拥有统一的主题、精确的排版、相通的操作 / 交互模式。另外，我还希望能在不同上下文或界面之间建立联系：我的邮件客户端应该能跟任务调度器和文件管理器直接对话，我在编写文本时使用的配置也需要直接适用于编程界面等等。
Emacs 通过自身及第三方包 / 自定义代码全面满足了我的一切需求。如果大家愿意稍微学学 Elisp，那 Emacs 可以说是蕴藏着无穷无尽的可能。下面，咱们就一起来看几个无需多高技术水平就能实现的常见工作流程：
使用补全框架对文件内容进行异步搜索，将结果放在专用缓冲区内并就地编辑。最后，把变更传播至所有相关文件。
捕捉当前电子邮件内容并据此生成待办事项。任务还可包含一条返回原始消息的链接，并能够在议程当中显示相应的预定日期与截止日期。
在 Dired 中标记某些文件，再将它们添加到正在撰写的电子邮件当中。Dired 可以逐个标记条目，也可以使用正则表达式和其他高级命令。
记录一组以 Dired 为起点的操作（「键盘宏」），跳转至特定文件，执行某些变更、返回文件管理器，再在下一个文件中重复这个过程。
在以上各种用例中，用户完全不需要学习任何新知识。例如，键盘宏等各类功能在哪里都能直接用。更重要的是，这些功能既能单独起效、也可以协同工作。
因此，Emacs 得以将各种界面连通起来，而且完全不会因为上下文切换而引起任何冲突。
Emacs 的最后一项优势，就是易用性和规模化使用时的便捷性。例如，我想用自定义代码制作本次演讲中的演示内容。因为画面只占据文档的一小部分，所以很多朋友会以为这是一张预先构建的 PPT。并不是，我可以直接编辑里面的普通文本。所以我用的其实是 Emacs 当中的极简化“专注模式”，这种模式在演示、阅读、写作和编程等场景中都有很好的表现。
而且我在 Emacs 中的所有操作都只需要实现一次。我不需要在电子邮件客户端里设置一个定制专注模式、再为文本编辑器 / 处理器或者议程规划器设置更多其他专注模式。完全不需要，使用同一个模式即可。另外，我也不需要单独的工具进行文本编写和呈现，所有功能都是统一且互通的，又好又简单！
除此之外，底层配置也全部在 Elisp 中完成，这又进一步简化了整体效果。在使用 Emacs 之前，我往往得为每个应用程序使用不同的范式和 / 或语言。例如，Thurderbird 和 Libreoffice 各自的设置菜单就不同，而且彼此间无法互通。Mutt 有自己的配置方式、Vim 和 Tmux 也是，终端模拟器还是，逼着人反反复复做无用功。
我并不是说应用程序就不该有自己的配置方式。我只是建议它们应该组合使用，而目前毫无关联、彼此割裂的状态肯定不够好。用户只能竭尽全力用一个个功能孤岛拼凑出整体系统。而且即使付出巨大的努力，其中仍可能存在不足之处甚至安全缺陷，毕竟这些程序并非来自同一平台、使用的也不是同一种语言。
而在 Emacs 当中，每个新的功能包都会自动获取其他包内的已有内容，例如相同的字体配置和主题、通用的操作和交互模式等等。以此为基础，我们就能极大加快工作流的推进速度。Emacs 内部发生的一切都存在于同一环境当中，所有上下文均可相互关联，用户也能够随意建立这种关联。这种高度集成化和独特的统一性体验，也构成了 Emacs 价值主张的核心。
一致性与自主性
就使用许可而言，Emacs 属于自由软件。但它为最终用户带来的自由绝不限于法律或者道德层面，更体现在实用层面——也就是前文提到的集成计算环境。
Emacs 的可扩展性，使得用户能够利用自己的计算设备真正执行极为广泛的处理任务。与此同时，Elisp 的统一特性降低了准入门槛，彻底消除了以往全方位知识库需要在缺少共通基础的前提下拼凑应用程序的困境。
日常生活中的自由极可宝贵，而 Emacs 这款工具正是自由向往的代表，也帮助我们尽可能拉近了开发目标与计算机呈现结果之间的距离。
软件的自由，体现在计算手段的所有权当中。基于灵活的所有权，我们才能在计算空间中自主发展。这种自主性让我们能够随意为既定目标选择工具，摆脱由硬编码、甚至是固定实体服务带来的种种束缚。
在我看来，日常使用的各种应用程序间的集成性缺失绝对是个值得关注的大问题。我觉得自己在其中得不到应有的权利，也无法让工具充分按自己的意愿行事。于是最大的矛盾出现了：自由软件反而限制了我的自主性、让我变得不自由。这就造成了 1+1
换句话说，这些工具在“教我们做事”，而作为用户的我们完全影响不到这些“教条”的制定。
但在 Emacs 的帮助下，我终于在自己的日常计算中消除了这些异构性与异质性元素。现在，我的几乎一切创作都在 Emacs 上进行：读写、文件管理、任务规划组织、电子邮件往来、音乐收藏与播放、互联网浏览等等。唯一的例外，就是我确实还离不开图形网络浏览器。
再聊点抽象的。自由这个概念包含两个层面：名义自由与实质自由。前者体现在代码库遵循的许可上，后者则体现在代码库自身的内容——即整个使用感受，以及代码库如何与特定环境中的其他程序或工作流程相匹配。我觉得软件自由这个议题特别有意思，值得深入发掘。正确性、可组合性和可扩展性都是软件代码的基本属性，只有把这些属性有机结合起来、才能让程序在实践当中充分发挥能力。所以我们需要的是实质自由，而不只是许可条款层面的名义自由。
假定有这么一款程序，它既没有任何说明文档、代码的编写方式也极难理解。虽然它遵循自由许可，但种种现实却在提醒我们，它在用户体验层面跟自由自主没有任何关系。用户很难理解这款程序的内部运作逻辑、自然看不懂它为什么会给出最终结果。结合个人经验，我觉得这就是典型的名义自由——只存在于许可条款当中、在实际体验中完全不见踪影的“自由”，绝对不是真正的自由。
使用 Emacs 的经历还让我意识到，作为软件技术社区，我们的关注点必须始终投射在最终用户身上，我们就不该发布那些用户无权操作的代码。相反，我们应该放开手脚，允许用户自主管理计算方式。自由软件不只是要替代专有代码，它更重要的象征意义在于激励人们改变对于自主思想的态度。社区和用户间的关系不仅仅是予取予求，还应该引导用户习惯于争取自由、承担责任。
而这样做的终极目的，就是让人们从曾经长期束缚我们的版权制度中解放出来，将权利交换给用户。是的，代码本身并不是终极目标，所以开源社区一定得勇于从公式化的版权文件中走出来。“要么接受、要么放弃”的一刀切方法既不能赋予用户权利，也无法培养他们的自主性。一个优秀的项目，不仅应该易访问、可配置、配备完善的说明文档，同时也应该为自由事业的发展做出贡献。
而推进这项事业的第一步，就是打通软件壁垒、让一切程序都能协同工作。最终，用户将学会如何掌管自己的整台计算机，这样每个人才能真正成为自由软件新时代的一分子。
Emacs 社区和我的社区贡献历程
说了这么半天 Emacs，其实我们也有自己的社区。Emacs 社区欢迎新人的加入，希望借此传播知识、分享观点。Emacs 社区对开发质量一直有着极高要求，并把这当成关乎用户自由与否的大事。目前，正规 Emacs 软件包均提供详尽文档，允许用户通过多种选项配置出自己想要的使用体验。
Emacs 社区很清楚，我们不能对最终用户的主动性施加控制。因此，所有相关代码都具备良好的可扩展性与定制空间。社区始终抱持这样的观点——自由是一种主体间的体验展开，因此单从法律层面放开约束还远远不够。于是，Emacs 提倡一种强大的文档文化，每份 Elisp 表单都必须用自然语言解释其作用，每个功能包都必须提供使用与配置说明。我们希望用这样的方式保障最低限度的计算自由。
这就是 Emacs 的行事风格，而且一路延伸至核心应用。作为 Lisp 机，Emacs 在设计之初就充分为最终用户赋权，重新审视一切既有规则。例如，我的 Elisp 学习之路就是从编写小型函数封装开始，用于调整某些默认操作的执行方式。我想补充“move down a line”（下移一行）命令的功能，让它能支持下移特定多行。Emacs 则可以实时评估代码，而且开放完整的源代码及相关说明文档。正是有了这样的开放性，我才能了解如何定义函数，再通过反复试验编写出人生中第一条自定义 Elisp。
之后，我又继续调整 Emacs，希望实现有益于自己日常工作的微小优化。在此期间，我逐渐掌握了 Elisp，并运用这些新知识得心应手地操作 Emacs。过去两年半里，我编写了几千行 Elisp 并为核心 Emacs 做出贡献，包括两个完整、辅助功能齐备的可定制主题，这就是 modus-themes。
换个角度来看，我在成为 Emacs 用户的头三个月里，学到的编程知识要比自己之前三年参与自由软件社区中还多。对我来说，这就是社区引导最终用户成长、满足最终用户需求的最佳案例。曾经的我对技术一窍不通，但现在我已经掌握编程能力、开始努力争取自己的计算自主权。虽然还有很长的路要走，但我至少已经迈开了步伐。

*** Emacs people

先评估工作所需技能，如果缺失就先弥补。待你有信心找工作时再玩emacs。但也有可能你已经准备了很充份，却依然没找到自己满意的工作哦。一个事情是不是正事，有时候要看你怎么看它了。对你来说emacs不是正事，因为你没有充份认识到它的价值。可对某些人来说它就是正事中的正事，因为对他来说非常具有价值。

厨师要有好的锅，炒菜才不粘锅，但不能一直打磨锅不炒菜，持续炒菜的作用是活下去，才有时间继续打磨工具，良性循环。
首先要热爱生活，知道有意义的事情和自己感兴趣的交叉点在哪里？只要能好好持续的活下去，不要着急，玩emacs就和其他人养宠物和下棋一样，都是良性爱好。
工具本身没有错，只打磨宝剑不用剑的原因往往是对自己认识还不够导致的，然后总是拿打磨工具当做逃避的手段。

你和我当初的情况一样，这确实是要makefile。
makefile是一个工程管理工具，指导程序应该如何一步一步被编译出来，而补全就是根据每一步的编译指令“gcc ……” 来推断每个文件里面可以看到哪些库（注意“能看到”与“实际include”的区别），因此便能够据此提供补全功能。
你如果和我当初一样是刚刚进入Linux世界的话，那我猜测你之前是用keil做单片机开发的。那么你就需要去网上找找你所开发的单片机的对应makefile工程，我记得GitHub上面就有，然后尝试着编写一个gpio的点灯程序试试能否编译烧录。
编译器应该是交叉编译器“gcc-none-arm-eabi”，好像是这个名，太久没有用记不清了，可能顺序不一样，但是none和arm是要有的，none指裸板（即无操作系统的平台），arm指芯片架构。
烧录我不太记得清了，记得是下载一个驱动（pacman和apt仓库好像都有，名字忘记了）然后再下载一个串口通信的软件，就能够烧录了。
 最后我觉得Linux做单片机开发对于初学者来说，心智负担实在是太大了，不如还是先使用keil，stm32cubeide（这个好像有Linux版，但是当时折腾了好久也没有烧录上）来做开发比较好。

 因为自己当时太傲慢，太蠢了，遇到问题如果谷歌不到就放弃了，完全不懂得上咱们论坛问问，或者去stackoverflow之类的地方用英文问别人应该怎么做，什么都自己摸索。。。然后自己摸索了许久，然后发现总是有问题，就放弃了。
仔细回忆一下，大概是一开始是根本不知道怎么搞，后面通过折腾知道了需要自己弄项目管理的工具还有交叉编译器，Keil 是用 .uproj（大概这名）文件来管理项目的，而Linux上面只能用makefile或者CMake，于是就自己学Makefile和CMake。。。后面发现需要调试串口的时候又卡住了，Linux下面的串口调试怎么也接不到STM32发出来的串口信息（当时我只用Linux），一直卡着调不出来，又不想重装回Windows，负反馈太大，就失去兴趣了。
后面上了大三了专业课压力又大，又要准备考研了，于是就没有整过它了。现在考完研(没考上😢)，也快毕业了，搞毕业论文，又要二战，更加没时间弄这个了。
不过当时学的时候还是蛮快乐的，因为当时我是用『寄存器』的视角去学习的（好像当时STM32学习的三层视角：寄存器、官方库函数、HAL库函数），虽然痛苦而且没有什么项目成果，但是却让我理解起计算机底层更加深入了233

我也凑个热闹，说说自己的经历。
开始用 Emacs 很早了，二十多年前，还是大学时期，当时 Linux 在国内还是处于开始阶段，只见到过几种发型版，其中一个还是清华 Linux Club 在 RedHat 之上加的中文支持。后来发现了 Debian，一直用到了现在。
VI 不太会用，只好用 Emacs。如果没记错的话，当时用的 Emacs 版本是 19 还是 20。当时也想着用 Emacs 一统江湖来着，用 gnus / mail / elfeed / erc 等等什么的，后来都不玩了。主要还是写程序，C / Java，JDEE 用了一段也弃了，再加上 LaTeX 写东西，也就这样了。一直也对 Org 无感，比较麻烦。
后来工作也是，开着一个 Emacs， 大黑全屏，跟别人都不一样。后来一个同事也玩 Emacs，Org 之类的，带动了一些人。这是第一次见到有 Emacs 同好。
后来在咱们论坛上看到了 Space Emacs，试用下来还不错，hyrbid mode，space leader key 还是好用些，也比较习惯。同时也学习了 VI，至此 VI 技能才从会 dd/yy 升级一些。
发现 AsciiDoc，用来写东西很好。
对 Space Emacs 不满，各种原因吧，换回常规 Emacs 配置，照抄一大波。不过一直以来我的 Emacs 配置极少，聊聊十数个包，多是 customize 就能出来的东西。现在慢慢多了起来。
再来就是试用了 meow，能接受，就用了下来。
总的来说，自己的需求相当低，那就是写东西，程序也是写，其他东西也是写，只要这个目的能很好地达到，符合自己的习惯，Emacs 就很好。其他的基本不在 Emacs 里做。当然了，开发的时候，边上开个 IDE 来解决语法错误还是很有必要的，但随着 LSP 的进步，这一项在自己的小项目中已经可以不用了。即便是 Magit，也多是用来选择文件 stage，其他功能也很少用，都是 git 命令行解决。
纵观自己和 Emacs 的历史，就是君子之交，平淡如水，不火热（不总折腾），也不远离（天天在用），没去帮它进步（去开发改进或开发新包），也算是尽自己一分力（看到新奇的也玩一玩，偶尔也提个 PR 啥的），就是个稳定、安静的佛系使用者。

** Blogs
*** 973 days with emacs
*** Emacs with Pedals
*** TeachYourselfCS
**** Programming
        Don’t be the person who “never quite understood” something like recursion.
        Structure and Interpretation of Computer Programs
        Brian Harvey’s Berkeley CS 61A
**** Computer Architecture
        If you don’t have a solid mental model of how a computer actually works, all of your higher-level abstractions will be brittle.
        Computer Systems: A Programmer's Perspective
        Berkeley CS 61C
**** Algorithms and Data Structures
        If you don’t know how to use ubiquitous data structures like stacks, queues, trees, and graphs, you won’t be able to solve challenging problems.
        The Algorithm Design Manual
        Steven Skiena’s lectures
**** Math for CS
        CS is basically a runaway branch of applied math, so learning math will give you a competitive advantage.
        Mathematics for Computer Science
        Tom Leighton’s MIT 6.042J
**** Operating Systems
        Most aof the code you write is run by an operating system, so you should know how those interact.
        Operating Systems: Three Easy Pieces
        Berkeley CS 162
**** Computer Networking
        The Internet turned out to be a big deal: understand how it works to unlock its full potential.
        Computer Networking: A Top-Down Approach
        Stanford CS 144
**** Databases
        Data is at the heart of most significant programs, but few understand how database systems actually work.
        Readings in Database Systems
        Joe Hellerstein’s Berkeley CS 186
**** Languages and Compilers
        If you understand how languages and compilers actually work, you’ll write better code and learn new languages more easily.
        Crafting Interpreters
        Alex Aiken’s course on edX
**** Distributed Systems
        These days, most systems are distributed systems.
        Designing Data-Intensive Applications by Martin Kleppmann
        MIT 6.824
****
** ChatGPT
*** Prompt
Custom Instructions:

I use ChatGPT as a tool for programming and health guide help only. Please avoid any content related to the following:

    Explicit Content: Do not provide any answers or links related to Horrible News, World Disaster, World News, Discussion on X.com/Reddit.com , Porn, Adult content, Recently Breaking News, Social Anxiety, Social Phenomenon, anything sexual or anything will take me hours to dive into rabbit hole, including but not limited to: sexy model pictures, adult sites, news sites, Trump , Ted Kaczynski, Luigi Mangione, or someone similar and anything with sex-related content.

    Political, News, and Entertainment Topics: Avoid discussing political news, memes, sports, entertainment, or anything related to celebrities or social media trends.

    Specific Topics to Avoid:
        Anything related to China, Chinese culture, or Chinese websites (e.g., 爱情岛, 吃瓜网, 成人视频, 美女, 色情, 黄色, 乱伦, AI换脸, 情爱, 动漫, 国产, 日本, etc).
        Websites or terms related to explicit content (e.g., Twitter, Reddit, Pornhub, Mia Khalifa, Jav, adult sites, ACG, anime,  r18, 51, 91, xiurenwang, daji toxic, Ted Kaczynski, Murder News, Celebrity News, LGBTQ , Spread Hate, Asian Culture, World Disaster,    etc.).

    Programing Focus: Only answer questions related to programming and coding. If the question is not related to programming, please respond with "I'm unable to assist with that."

    Response Speed: Please reply slowly and thoughtfully, focusing only on coding-related content.

*** Read Bin file in emacs
**** 1. *Hex View in Emacs*
:PROPERTIES:
:CUSTOM_ID: hex-view-in-emacs
:END:
You can view the binary content of a file as a hex dump directly in
Emacs: - Open the file in Emacs: =C-x C-f ./init312=. - Switch to *Hexl
mode* to see the file as a hex dump: =emacs   M-x hexl-mode=

This will display the binary content in a human-readable hexadecimal
format, similar to =hexdump -C=.

--------------

**** 2. *View Disassembled Code in Emacs*
:PROPERTIES:
:CUSTOM_ID: view-disassembled-code-in-emacs
:END:
You can use =objdump= output and view it within Emacs: - Run the
=objdump= command and redirect the output to a file:
=bash   objdump -d ./init312 > init312.asm= - Open =init312.asm= in
Emacs: =emacs   C-x C-f init312.asm= - Use =M-x asm-mode= for syntax
highlighting and better readability of the assembly code.

Alternatively, you can integrate this into Emacs using =compile= or
=shell-command= to directly run =objdump= and show results in Emacs.

--------------

**** 3. *Use =strings= in Emacs*
:PROPERTIES:
:CUSTOM_ID: use-strings-in-emacs
:END:
If you're only interested in extracting readable strings: 1. Run
=strings= on the file and save output to a temporary file:
=bash    strings ./init312 > init312.strings= 2. Open =init312.strings=
in Emacs with: =emacs    C-x C-f init312.strings=

For a quicker approach, you can run =M-x shell-command= in Emacs:

#+begin_src emacs
M-x shell-command RET strings ./init312 RET
#+end_src

This shows the output directly in a new Emacs buffer.

--------------

**** 4. *Using Dired for Quick Commands*
:PROPERTIES:
:CUSTOM_ID: using-dired-for-quick-commands
:END:
When browsing in =dired=: 1. Navigate to the binary file. 2. Press =!=
(run shell command) and enter commands like: =bash    objdump -d %s=
This will disassemble the file and show the output in a separate buffer.

--------------

**** 5. *Use External Packages for Binary Inspection*
:PROPERTIES:
:CUSTOM_ID: use-external-packages-for-binary-inspection
:END:
***** *=nhexl-mode=*:
:PROPERTIES:
:CUSTOM_ID: nhexl-mode
:END:
For advanced hex editing and inspection, install and enable
=nhexl-mode=:

#+begin_src emacs-lisp
M-x package-install RET nhexl-mode RET
#+end_src

Activate it with:

#+begin_src emacs
M-x nhexl-mode
#+end_src

***** *=xdisphex=*:
:PROPERTIES:
:CUSTOM_ID: xdisphex
:END:
For disassembling binaries directly in Emacs: 1. Install the =xdisphex=
package. 2. Use it to inspect binaries and ELF headers.

--------------

**** 6. *Customizing Eshell Output*
:PROPERTIES:
:CUSTOM_ID: customizing-eshell-output
:END:
To make Eshell output clearer, configure Eshell to show colorized output
or pipe results to =less=:

#+begin_src sh
objdump -d ./init312 | less
#+end_src

For better readability, use Eshell aliases:

#+begin_src emacs
alias objdump='objdump -d $1 | less'
#+end_src

--------------

**** Summary
:PROPERTIES:
:CUSTOM_ID: summary
:END:
For your use case: - Use =hexl-mode= or =nhexl-mode= for hex dumps. -
Use =asm-mode= for disassembled output. - Run =strings= via
=M-x shell-command= for readable strings. - Explore Dired commands for
convenience.

Let me know if you'd like detailed instructions for any specific
approach!
*** Health


## Factors Contributing to Low Life Expectancy

1. **Health Issues**: Software engineers often face a range of physical ailments due to their sedentary work environment. Common issues include:
   - Eye strain     (eink&decent light)
   - Headaches   (regular walk and eat health)
   - Neck and back pain (ergo keyboard & standing desk)
   - Carpal tunnel syndrome[1].   (ergo keyboard/colemak/emacs/pedals)

2. **Lifestyle Choices**: Many in the profession engage in unhealthy habits, such as:
   - Poor eating habits, often relying on junk food and skipping meals.(no junk food)
   - Excessive caffeine consumption.(no coffee)
   - Irregular sleep patterns leading to chronic fatigue and insomnia[1].(disconnect & 褪黑素)

3. **Mental Health Strain**: The pressures of the job contribute to significant mental health challenges:
   - High levels of stress and anxiety from tight deadlines and demanding clients.
   - Feelings of burnout due to constant learning and adapting to new technologies.
   - Increased rates of depression, which can lead to serious health complications like heart disease and diabetes[1].

4. **Work Environment**: The nature of software engineering often involves long hours at a desk, contributing to a lack of physical activity, which is critical for maintaining overall health[1].

## Implications

The combination of these factors suggests that software engineers may be sacrificing their health for career success. While they may earn substantial salaries early in their careers, the toll on their physical and mental well-being raises concerns about long-term sustainability in the profession.

In summary, while software engineering is a lucrative field, the associated health risks and lifestyle choices appear to significantly impact life expectancy, warranting attention from both professionals and employers in the industry.

Citations:
[1] https://postamate.com/2023/08/why-software-engineers-have-short-life-expectancy/
[2] https://improvingsoftware.com/2009/05/19/programmers-before-you-turn-40-get-a-plan-b/
[3] https://news.ycombinator.com/item?id=35605382
[4] https://www.reddit.com/r/learnprogramming/comments/snufyd/are_there_many_programmers_still_working_in_their/
[5] https://javascript.plainenglish.io/2-regrets-of-a-55-years-old-retired-software-engineer-4c4fafc1bd2b?gi=87b07cae20a7
[6] https://news.ycombinator.com/item?id=23366546
[7] https://www.youtube.com/watch?v=3J6ZpoPWauI



以下是基于 **Lex Fridman** 和 **Stanford 博士 Andrew Huberman** 的日程安排中文版，包括设定闹钟时间和简要概述：  

---

### **早晨计划（专注与启动）**  
#### **⏰ 9:00 起床**  
- **总结**: 起床后迅速喝水（500ml，加一点盐或电解质），并进行5–10分钟的阳光浴，激活大脑和身体。  

#### **⏰ 9:15–9:45 早间冥想**  
- **总结**: 10分钟的冥想或写日记，列出当天1–3个最重要的目标。  

#### **⏰ 10:00 早餐**  
- **总结**: 营养均衡的早餐提供能量：如鸡蛋+牛油果+坚果，配绿茶或黑咖啡。  

#### **⏰ 10:30–12:30 深度工作 1**  
- **总结**: 全天最重要的深度任务，使用 **番茄工作法**（25分钟专注+5分钟休息）。  

---

### **中午计划（休息与补充能量）**  
#### **⏰ 12:30–1:00 午间散步**  
- **总结**: 在户外步行15–30分钟，同时听播客或有声书，放松身心。  

#### **⏰ 1:00 午餐**  
- **总结**: 吃优质蛋白（如三文鱼、鸡肉），配上全谷物和绿叶蔬菜，饭后可吃蓝莓或黑巧克力作为点心。  

#### **⏰ 1:30–2:00 学习时间**  
- **总结**: 阅读技术书籍或观看与专业相关的课程，拓展知识。  

#### **⏰ 2:00–4:00 深度工作 2**  
- **总结**: 再次进入深度工作状态，处理需要长期专注的项目任务。  

---

### **下午计划（校准与运动）**  
#### **⏰ 4:00–4:30 午间休息**  
- **总结**: 20分钟的小睡，或练习深呼吸，重置精神。  

#### **⏰ 4:30–6:00 锻炼时间**  
- **总结**: 进行中等强度锻炼（如力量训练、瑜伽或慢跑）。可选择在运动后进行冷水浴（3–5分钟）。  

#### **⏰ 6:00 晚餐**  
- **总结**: 健康清淡的晚餐：鸡胸肉/豆腐+烤红薯+西兰花，配上一杯草本茶放松心情。  

---

### **晚上计划（学习与总结）**  
#### **⏰ 7:00–9:00 技能提升**  
- **总结**: 投入侧项目或技能学习（如Rust、Zig或eBPF），增加知识储备。  

#### **⏰ 9:00–9:30 日记反思**  
- **总结**: 总结当天的学习内容、遇到的挑战和解决方案。  

#### **⏰ 9:30–10:30 放松时间**  
- **总结**: 低刺激活动：阅读、轻量伸展或整理环境，避免电子屏幕干扰。  

---

### **夜晚计划（睡前准备）**  
#### **⏰ 10:30 准备入睡**  
- **总结**: 减弱灯光，避免蓝光刺激，进行10分钟的感恩日记或简单冥想。  

#### **⏰ 11:00–12:00 自由时间**  
- **总结**: 听轻音乐，规划第二天的日程，或从事个人兴趣爱好。  

#### **⏰ 12:00 睡觉**  
- **总结**: 确保7–9小时的高质量睡眠。  

---

### **闹钟时间总结**  
| **时间** | **活动**          | **简要总结**                                         |  
|----------|-------------------|-----------------------------------------------------|  
| 9:00     | 起床              | 喝水+阳光浴，启动身体和大脑。                         |  
| 9:15     | 早间冥想          | 冥想或写日记，规划当天目标。                          |  
| 10:00    | 早餐              | 蛋白质+健康脂肪+茶或咖啡，提供全天能量。              |  
| 10:30    | 深度工作 1        | 处理最复杂的任务，保持专注。                          |  
| 12:30    | 午间散步          | 户外活动，听播客，放松心情。                          |  
| 1:00     | 午餐              | 健康均衡饮食，增强午后工作效率。                      |  
| 2:00     | 深度工作 2        | 继续完成重要项目或学习。                              |  
| 4:00     | 午间休息          | 小睡或冥想，重置精神。                                |  
| 4:30     | 锻炼              | 中等强度运动，保持身体活力。                          |  
| 6:00     | 晚餐              | 健康晚餐，适当放松。                                  |  
| 7:00     | 技能提升          | 学习或侧项目进展，专注长期成长。                      |  
| 9:00     | 日记反思          | 记录学习心得和反思成长。                              |  
| 10:30    | 准备入睡          | 减少刺激，做好睡前准备。                              |  
| 12:00    | 睡觉              | 确保充足睡眠，恢复体力和精神。                        |  

这份时间表结合了严格的时间管理和科学建议，有助于提高学习、专注力和整体健康。

* Books

** Programming
*** Beej
**** C Tutor
[[file:beejlearn/Beej's Guide to C Programming.html#lengthmiscellaneous-functions][Beej's Guide to C Programming]]
** Mental
*** 暗时间－刘未鹏

*** Stolen Focus
- 第1章 原因1：速度、转换、过滤太多
  + 有预先承诺的人取得成功，他们明确发誓遵守规定，就能够撑比较久
  + 当你注意快速变幻的事物，人很容易静不下来，好像不动一动、喊一喊，就会感到心烦意乱，情绪无处发泄，快被淹没似的。如今我看著海，它是很古老、永久的事物，远比我更早存在，而且直到许多小烦恼都被遗忘之后，海依然会在那里很久很久。推特让你觉得全世界都关注你和你小小的自尊，都在爱你、恨你或评论你。但海洋让你感觉全世界带给你柔和、湿润的包容，不管你怎么大声呼喊，它从不评论你。
  + 对我来说，每件事都慢了下来。一般而言，我每一、两个小时就会追踪新闻，不停获取引发焦虑的消息，试图搓压出某种概念。
  + 我们现在很像「从消防栓喝水，有太多东西纷至沓来」，把我们淹没在资讯里
  + 这个叫『速度』的东西使人感觉很棒……为何我们沉迷于此，有一部分原因是它棒极了，对吧？你觉得自己跟全世界接轨，发生任何事你 都找得到、学得到。」我们自以为能免费快速获得大量资讯，这是妄想。「这使人筋疲力竭。」 更重要的是，「我们损失的是各面向的深度……深度需要时间，需要反思。
  + 人类吸收资讯的速度有其限制，如果试图突破，只会破坏大脑的理解能力，速读的人不太能处理复杂或具有挑战性的题材
  + 在放弃网路的那个夏天，某日我慢读一本书，慢食一顿饭，慢慢在小镇闲逛后，怀疑自己以前深受精神时差之苦。
  + 刻意练习缓慢，例如瑜伽、太极或静坐，人们的注意力确实显著提高。
  + 他说：「我们必须缩小世界以适应我们的认知频宽。」如果你走太快，能力就会超出负荷并退化。如果你练习用符合人性的速度行动，并将其融入日常生活中，就会开始训练注意力和专注力。「专注练功让你更聪明，有没有吟唱咒语或穿橘色道袍并非重点。」他解释，缓慢可以培养专注力，而快速则削弱专注力。
  + 我们若不以「承认自己能力有限」的前提去生活，就会集体陷入巨大的妄想中, 「人的能力有限，」亚当又说：「我们可以无视于这点，假装自己想要怎样就能怎样，或者承认自己能力有限，然后以更理想的方式生活。」
  + 短期智商损伤是吸食大麻的2倍。这表示就完成工作而言，连嗑药而神智恍惚的人，效率都比经常查看简讯和脸书的人还好。拥有智慧手机的人几乎表现都下降20～30％，对人类这物种来说是很大的智力损失。
  + 「（因为）你的大脑很容易出错。当你从一个任务切换到另一个任务时，大脑必须稍微回溯，找出它暂停的地方。」但大脑无法完美做到这一点，于是小故障开始出现。「没有花时间真正深入思考，让你的想法更肤浅，因为你花 了很多时间去纠错和回溯。」
  + 一个人待在嘈杂的房间里，注意力会降低，工作成果也变糟。

- 第2章 原因2：心流状态削弱
  + 在我看来，自恋是一种注意力的堕落，因为注意力只会转向自己和自我中心。
  + 如果数字上升了，我会很高兴，就好像贪婪的守财奴检查他的股票投资，发现自己比昨天稍微富有那样
  + 上瘾者渴望有个东西能麻木自己心烦不已的空虚感。
  + 我已经有二十多年的时间整天发讯息、收讯息。简讯、脸书、电话，这些方式似乎都是世界在诉说：「我看到你；我听到你；我们需要你；回复信号；更多信号。」如今信号消失了，就像全世 界都在说你不重要。没有持续的信号，似乎意味著你没有了意义。
  + 你可以教鸽子打乒乓球、捡硬币，并且将硬币放入存钱筒；你可以教猪清洁地板。如果你给予正确的奖励，这些动物会专注于非常复杂（但对牠们毫无意义）的事。
  + 处于创作过程的艺术家会忘了时间的存在，仿佛被催眠般进入一种出神状态，这是一种在别处很少见的深度专心,艺术家们花了这么多时间画画，画完后却没有得意地看著自己的作品，也没有炫耀或寻求赞美。几乎所有人都只是把画收起来，然后开始创作另一幅。如果史金纳是对的，人类做事是为了获得奖励和避免惩罚，那艺术家这样做就毫无意义。你已经完成工作，可以享受眼前的奖励，但有创造力的人似乎都对奖励不感兴趣，大多数艺术家甚至认为钱也不重要。米哈里后来对采访者说：「当他们完成时，成品与结果并不重要。」
  + 你需要选择一个目标；确保目标对你有意义；努力把自己推到临界点,「浑然忘我；不知时间流逝；感觉自己比以前更强大。」心流带我走过艰难和挫折，打开了我的注意力。
  + 某种程度来说，当我们不专注时，就没办法使用自己最强大的能力。缺乏心流使我们阻碍了自己，无法发挥原本的潜力。
  + 然后他了解到，莫里奇已学会如何阅读这些岩石，知道它来自哪里，以及化学成分为何。对他来说，这发挥技能的机会触发了心流状态。米哈里一生都在学习心流状态如何拯救人类，现在，当兄弟俩一起凝视闪闪发光的水晶时，他在一生受尽饥饿之苦与折磨的哥哥脸上，看到了心流。
  + 在日常生活中，许多人试图透过躺平摆烂来摆脱分心。我们躺在电视机前，想从一整天的超载中恢复。但如果你只是跳脱分心，进入休息状态，却没有用正在努力实现的积极目标取而代之，那么迟早会被拉回分心。摆脱分心更好的方式是「找到你的心流」。
  + 如果在一天中很早就经历3个小时的心流，那么当天接下来的时间我会感觉放松、有弹性，并且能做点别的事，例如沿著海滩散步、与人聊天、阅读，而且不会感觉局促、烦躁或渴望用手机。心流似乎放松了我的身体，打开我的心智，或许也是因为我知道自己尽力了，我感觉进入一种不同的节奏。那时我意识到，想从注意力丧失的状态恢复过来，仅仅消除分心是不够的，那只会造成空白。你需要去除干扰，再用会引起心流的事物来取代空白。
  + 我想，当人接近死亡时，并不会想到为他按赞和分享的网路援军，而会想到自己的心流时刻。
- 第3章 原因3：身心耗损增加
- 第4章 原因4：持续阅读习惯崩解
- 第5章 原因5：心灵神游被打断
- 第6章 原因6：追踪及操控人的科技兴起（上）
- 第7章 原因6：追踪及操控人的科技兴起（下）
- 第8章 原因7：残酷的乐观主义抬头
- 第9章 初探有效的解决方案
- 第10章 原因8：压力激增，诱发警戒
- 第11章 扳回失速与心神耗损
- 第12章 原因9、10：持续恶化的饮食与环境污染
- 第13章 原因11：如何面对渐增的注意力不足过动症？
- 第14章 原因12：对下一代身心的限制

* Learn
** Setup
*** using eink screen coding.

**** ui: nixos-stylix, firefox-pure white
Use the pure white theme in anywhere, you can do this by using stylix to set pure white as wallpaper to make system level as white style
font constract and eink addons  in firefox.
**** editor
emacs-modules theme without syntax highlighting, and stop using monospace, just try kindle's bookerly font, then you will feel you are reading kindle in such comfor and informative mode.
**** mental
use black++, m1 mode, 5 constract, no color, lees distraction, and more concentrate
You will never care about font or color theme anymore, because emacs+bookerly+eink is such a warm blanket.
**** physical
no lcd/led/any crazy bright square, it's such a nature piece like book, can feel the eye strain anymore.
no addictive colorful attraction, you can just stand up to drink or stretch like we used to be.

** Lang
*** Babel set up elisp,nix/scheme/rust,zig/lua,python/C,C++/bash,python,golang
- [-] set up org code block
  - [X] elisp   [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-elisp.html][doc]]
  - [ ] nix
  - [X] scheme[[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-scheme.html][   doc]]
  - [X] lua    [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-lua.html][doc]]
  - [X] c c++[[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-C.html][  doc]]
  - [X] zig[[https://github.com/jolby/ob-zig.el][     doc]]
  - [X] python[[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-python.html][  doc]]
  - [ ] go - networks
  - [ ] rust
  - [ ] bash

*** elisp

[[/home/leeao/save/books/structure and interpretation of computer programs.epub][SICP]]

*** Rust
[[https://github.com/rust-unofficial/awesome-rust?tab=readme-ov-file][awesome-rust]]
[[https://rustycab.github.io/LearnRustEasy/chapter_1.html][learnrusteasy]]
[[https://doc.rust-lang.org/stable/book/][the rust programming language]]

*** Zig

[[https://github.com/catdevnull/awesome-zig#readme][awesome-zig]]
[[https://pedropark99.github.io/zig-book/Chapters/01-zig-weird.html][zig-book]]


#+source: simple
#+begin_src zig :imports '(std)
const stdout = std.io.getStdOut().writer();
try stdout.print("{s}", .{"hello world"});
#+end_src

#+RESULTS: simple
: hello world



*** Learn Python
#+NAME: hello
#+BEGIN_SRC python :results output :exports code
def print_hello():
    print("Httelltto")

print_hello()
#+END_SRC

#+RESULTS: hello
: Httelltto



**Learn C/C++
[[file:~/save/books/Beej's Guide to C Programming.html#how-to-read-this-book][Beej's Guide to C Programming]]

#+begin_src C++ :includes <stdio.h> <math.h>
    void newline(void)
    {
        printf("hello\n");
    }
  int main(){
      double pi = 3.1416;
      printf("sin(pi/2)=%f\nln1=%f\n", sin(pi/2), log(1.0));
    newline();
      int a=2;
      int b=3;
      int c=5;
      printf("%d\n", a+b+c);
      }
#+end_src

#+RESULTS:
| sin(pi/2)=1.000000 |
| ln1=0.000000      |
| hello             |
| 10               |

** Compelete Thesis
*** TODO Fucking thesis
*** Dasung Screen, Golang to Rust 
** Mastering Emacs [75%]
*** DONE [#A] Learn [[file:Org.org][Org-mode]] to write GTD
CLOSED: [2024-12-16 Mon 17:17]
:PROPERTIES:
:Effort:   0:30
:END:
- [X] Read Though [[https://orgmode.org/orgguide.html#Images][Org Mode Compact Guide]]
*** DONE Learn Magit to Version Control
- [X] [[https://magit.vc/][magit]]
*** DONE Learn Projectile to Begin Projects

*** TODO Read Mastering Emacs 
- [ ] [[nov:/home/leeao/save/books/Mastering Emacs.epub::0:99][Mastering Emacs]]

** Learn SICP to be a religious guy [0%]
*** [[info:eintr#Preface][Info (eintr) Preface]][0%]
- [ ] Why
- [ ] On Reading this Text
- [ ] Who You Are
- [ ] Lisp History
- [ ] Note for Novices
- [ ] Thank You

*** Read Emacs Reference
*** Read Elisp Reference
*** Read Nix.dev
*** [[info:sicp#Dedication][SICP]]

** C&Network-> CS Basic [0%]
*** TODO Learn [[https://beej.us/guide/bgc/html/#foreword][Beej's C tutor]]
*** Learn Beej's Network tutor


*** Linux & ccls& C & Make & CMake & GDB & GCC + Emacs cc-mode = Computer God

** Learn CSAPP in Rust and Zig 
** Read DDIA 

